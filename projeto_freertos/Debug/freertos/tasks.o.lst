   1              		.cpu cortex-m0plus
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"tasks.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.global	pxCurrentTCB
  18              		.section	.bss.pxCurrentTCB,"aw",%nobits
  19              		.align	2
  22              	pxCurrentTCB:
  23 0000 00000000 		.space	4
  24              		.section	.bss.pxReadyTasksLists,"aw",%nobits
  25              		.align	2
  28              	pxReadyTasksLists:
  29 0000 00000000 		.space	100
  29      00000000 
  29      00000000 
  29      00000000 
  29      00000000 
  30              		.section	.bss.xDelayedTaskList1,"aw",%nobits
  31              		.align	2
  34              	xDelayedTaskList1:
  35 0000 00000000 		.space	20
  35      00000000 
  35      00000000 
  35      00000000 
  35      00000000 
  36              		.section	.bss.xDelayedTaskList2,"aw",%nobits
  37              		.align	2
  40              	xDelayedTaskList2:
  41 0000 00000000 		.space	20
  41      00000000 
  41      00000000 
  41      00000000 
  41      00000000 
  42              		.section	.bss.pxDelayedTaskList,"aw",%nobits
  43              		.align	2
  46              	pxDelayedTaskList:
  47 0000 00000000 		.space	4
  48              		.section	.bss.pxOverflowDelayedTaskList,"aw",%nobits
  49              		.align	2
  52              	pxOverflowDelayedTaskList:
  53 0000 00000000 		.space	4
  54              		.section	.bss.xPendingReadyList,"aw",%nobits
  55              		.align	2
  58              	xPendingReadyList:
  59 0000 00000000 		.space	20
  59      00000000 
  59      00000000 
  59      00000000 
  59      00000000 
  60              		.section	.bss.xTasksWaitingTermination,"aw",%nobits
  61              		.align	2
  64              	xTasksWaitingTermination:
  65 0000 00000000 		.space	20
  65      00000000 
  65      00000000 
  65      00000000 
  65      00000000 
  66              		.section	.bss.uxDeletedTasksWaitingCleanUp,"aw",%nobits
  67              		.align	2
  70              	uxDeletedTasksWaitingCleanUp:
  71 0000 00000000 		.space	4
  72              		.section	.bss.xSuspendedTaskList,"aw",%nobits
  73              		.align	2
  76              	xSuspendedTaskList:
  77 0000 00000000 		.space	20
  77      00000000 
  77      00000000 
  77      00000000 
  77      00000000 
  78              		.section	.bss.uxCurrentNumberOfTasks,"aw",%nobits
  79              		.align	2
  82              	uxCurrentNumberOfTasks:
  83 0000 00000000 		.space	4
  84              		.section	.bss.xTickCount,"aw",%nobits
  85              		.align	2
  88              	xTickCount:
  89 0000 00000000 		.space	4
  90              		.section	.bss.uxTopReadyPriority,"aw",%nobits
  91              		.align	2
  94              	uxTopReadyPriority:
  95 0000 00000000 		.space	4
  96              		.section	.bss.xSchedulerRunning,"aw",%nobits
  97              		.align	2
 100              	xSchedulerRunning:
 101 0000 00000000 		.space	4
 102              		.section	.bss.uxPendedTicks,"aw",%nobits
 103              		.align	2
 106              	uxPendedTicks:
 107 0000 00000000 		.space	4
 108              		.section	.bss.xYieldPending,"aw",%nobits
 109              		.align	2
 112              	xYieldPending:
 113 0000 00000000 		.space	4
 114              		.section	.bss.xNumOfOverflows,"aw",%nobits
 115              		.align	2
 118              	xNumOfOverflows:
 119 0000 00000000 		.space	4
 120              		.section	.bss.uxTaskNumber,"aw",%nobits
 121              		.align	2
 124              	uxTaskNumber:
 125 0000 00000000 		.space	4
 126              		.section	.bss.xNextTaskUnblockTime,"aw",%nobits
 127              		.align	2
 130              	xNextTaskUnblockTime:
 131 0000 00000000 		.space	4
 132              		.section	.bss.xIdleTaskHandle,"aw",%nobits
 133              		.align	2
 136              	xIdleTaskHandle:
 137 0000 00000000 		.space	4
 138              		.section	.bss.uxSchedulerSuspended,"aw",%nobits
 139              		.align	2
 142              	uxSchedulerSuspended:
 143 0000 00000000 		.space	4
 144              		.section	.text.xTaskCreate,"ax",%progbits
 145              		.align	2
 146              		.global	xTaskCreate
 147              		.code	16
 148              		.thumb_func
 150              	xTaskCreate:
 151              	.LFB0:
 152              		.file 1 "../freertos/tasks.c"
   1:../freertos/tasks.c **** /*
   2:../freertos/tasks.c ****     FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
   3:../freertos/tasks.c ****     All rights reserved
   4:../freertos/tasks.c **** 
   5:../freertos/tasks.c ****     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
   6:../freertos/tasks.c **** 
   7:../freertos/tasks.c ****     This file is part of the FreeRTOS distribution.
   8:../freertos/tasks.c **** 
   9:../freertos/tasks.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  10:../freertos/tasks.c ****     the terms of the GNU General Public License (version 2) as published by the
  11:../freertos/tasks.c ****     Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
  12:../freertos/tasks.c **** 
  13:../freertos/tasks.c ****     ***************************************************************************
  14:../freertos/tasks.c ****     >>!   NOTE: The modification to the GPL is included to allow you to     !<<
  15:../freertos/tasks.c ****     >>!   distribute a combined work that includes FreeRTOS without being   !<<
  16:../freertos/tasks.c ****     >>!   obliged to provide the source code for proprietary components     !<<
  17:../freertos/tasks.c ****     >>!   outside of the FreeRTOS kernel.                                   !<<
  18:../freertos/tasks.c ****     ***************************************************************************
  19:../freertos/tasks.c **** 
  20:../freertos/tasks.c ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
  21:../freertos/tasks.c ****     WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  22:../freertos/tasks.c ****     FOR A PARTICULAR PURPOSE.  Full license text is available on the following
  23:../freertos/tasks.c ****     link: http://www.freertos.org/a00114.html
  24:../freertos/tasks.c **** 
  25:../freertos/tasks.c ****     ***************************************************************************
  26:../freertos/tasks.c ****      *                                                                       *
  27:../freertos/tasks.c ****      *    FreeRTOS provides completely free yet professionally developed,    *
  28:../freertos/tasks.c ****      *    robust, strictly quality controlled, supported, and cross          *
  29:../freertos/tasks.c ****      *    platform software that is more than just the market leader, it     *
  30:../freertos/tasks.c ****      *    is the industry's de facto standard.                               *
  31:../freertos/tasks.c ****      *                                                                       *
  32:../freertos/tasks.c ****      *    Help yourself get started quickly while simultaneously helping     *
  33:../freertos/tasks.c ****      *    to support the FreeRTOS project by purchasing a FreeRTOS           *
  34:../freertos/tasks.c ****      *    tutorial book, reference manual, or both:                          *
  35:../freertos/tasks.c ****      *    http://www.FreeRTOS.org/Documentation                              *
  36:../freertos/tasks.c ****      *                                                                       *
  37:../freertos/tasks.c ****     ***************************************************************************
  38:../freertos/tasks.c **** 
  39:../freertos/tasks.c ****     http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
  40:../freertos/tasks.c ****     the FAQ page "My application does not run, what could be wrong?".  Have you
  41:../freertos/tasks.c ****     defined configASSERT()?
  42:../freertos/tasks.c **** 
  43:../freertos/tasks.c ****     http://www.FreeRTOS.org/support - In return for receiving this top quality
  44:../freertos/tasks.c ****     embedded software for free we request you assist our global community by
  45:../freertos/tasks.c ****     participating in the support forum.
  46:../freertos/tasks.c **** 
  47:../freertos/tasks.c ****     http://www.FreeRTOS.org/training - Investing in training allows your team to
  48:../freertos/tasks.c ****     be as productive as possible as early as possible.  Now you can receive
  49:../freertos/tasks.c ****     FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
  50:../freertos/tasks.c ****     Ltd, and the world's leading authority on the world's leading RTOS.
  51:../freertos/tasks.c **** 
  52:../freertos/tasks.c ****     http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
  53:../freertos/tasks.c ****     including FreeRTOS+Trace - an indispensable productivity tool, a DOS
  54:../freertos/tasks.c ****     compatible FAT file system, and our tiny thread aware UDP/IP stack.
  55:../freertos/tasks.c **** 
  56:../freertos/tasks.c ****     http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
  57:../freertos/tasks.c ****     Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
  58:../freertos/tasks.c **** 
  59:../freertos/tasks.c ****     http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
  60:../freertos/tasks.c ****     Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
  61:../freertos/tasks.c ****     licenses offer ticketed support, indemnification and commercial middleware.
  62:../freertos/tasks.c **** 
  63:../freertos/tasks.c ****     http://www.SafeRTOS.com - High Integrity Systems also provide a safety
  64:../freertos/tasks.c ****     engineered and independently SIL3 certified version for use in safety and
  65:../freertos/tasks.c ****     mission critical applications that require provable dependability.
  66:../freertos/tasks.c **** 
  67:../freertos/tasks.c ****     1 tab == 4 spaces!
  68:../freertos/tasks.c **** */
  69:../freertos/tasks.c **** 
  70:../freertos/tasks.c **** /* Standard includes. */
  71:../freertos/tasks.c **** #include <stdlib.h>
  72:../freertos/tasks.c **** #include <string.h>
  73:../freertos/tasks.c **** 
  74:../freertos/tasks.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  75:../freertos/tasks.c **** all the API functions to use the MPU wrappers.  That should only be done when
  76:../freertos/tasks.c **** task.h is included from an application file. */
  77:../freertos/tasks.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  78:../freertos/tasks.c **** 
  79:../freertos/tasks.c **** /* FreeRTOS includes. */
  80:../freertos/tasks.c **** #include "FreeRTOS.h"
  81:../freertos/tasks.c **** #include "task.h"
  82:../freertos/tasks.c **** #include "timers.h"
  83:../freertos/tasks.c **** #include "StackMacros.h"
  84:../freertos/tasks.c **** 
  85:../freertos/tasks.c **** /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
  86:../freertos/tasks.c **** MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
  87:../freertos/tasks.c **** header files above, but not in this file, in order to generate the correct
  88:../freertos/tasks.c **** privileged Vs unprivileged linkage and placement. */
  89:../freertos/tasks.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
  90:../freertos/tasks.c **** 
  91:../freertos/tasks.c **** /* Set configUSE_STATS_FORMATTING_FUNCTIONS to 2 to include the stats formatting
  92:../freertos/tasks.c **** functions but without including stdio.h here. */
  93:../freertos/tasks.c **** #if ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 )
  94:../freertos/tasks.c **** 	/* At the bottom of this file are two optional functions that can be used
  95:../freertos/tasks.c **** 	to generate human readable text from the raw data generated by the
  96:../freertos/tasks.c **** 	uxTaskGetSystemState() function.  Note the formatting functions are provided
  97:../freertos/tasks.c **** 	for convenience only, and are NOT considered part of the kernel. */
  98:../freertos/tasks.c **** 	#include <stdio.h>
  99:../freertos/tasks.c **** #endif /* configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) */
 100:../freertos/tasks.c **** 
 101:../freertos/tasks.c **** #if( configUSE_PREEMPTION == 0 )
 102:../freertos/tasks.c **** 	/* If the cooperative scheduler is being used then a yield should not be
 103:../freertos/tasks.c **** 	performed just because a higher priority task has been woken. */
 104:../freertos/tasks.c **** 	#define taskYIELD_IF_USING_PREEMPTION()
 105:../freertos/tasks.c **** #else
 106:../freertos/tasks.c **** 	#define taskYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
 107:../freertos/tasks.c **** #endif
 108:../freertos/tasks.c **** 
 109:../freertos/tasks.c **** /* Values that can be assigned to the ucNotifyState member of the TCB. */
 110:../freertos/tasks.c **** #define taskNOT_WAITING_NOTIFICATION	( ( uint8_t ) 0 )
 111:../freertos/tasks.c **** #define taskWAITING_NOTIFICATION		( ( uint8_t ) 1 )
 112:../freertos/tasks.c **** #define taskNOTIFICATION_RECEIVED		( ( uint8_t ) 2 )
 113:../freertos/tasks.c **** 
 114:../freertos/tasks.c **** /*
 115:../freertos/tasks.c ****  * The value used to fill the stack of a task when the task is created.  This
 116:../freertos/tasks.c ****  * is used purely for checking the high water mark for tasks.
 117:../freertos/tasks.c ****  */
 118:../freertos/tasks.c **** #define tskSTACK_FILL_BYTE	( 0xa5U )
 119:../freertos/tasks.c **** 
 120:../freertos/tasks.c **** /* Sometimes the FreeRTOSConfig.h settings only allow a task to be created using
 121:../freertos/tasks.c **** dynamically allocated RAM, in which case when any task is deleted it is known
 122:../freertos/tasks.c **** that both the task's stack and TCB need to be freed.  Sometimes the
 123:../freertos/tasks.c **** FreeRTOSConfig.h settings only allow a task to be created using statically
 124:../freertos/tasks.c **** allocated RAM, in which case when any task is deleted it is known that neither
 125:../freertos/tasks.c **** the task's stack or TCB should be freed.  Sometimes the FreeRTOSConfig.h
 126:../freertos/tasks.c **** settings allow a task to be created using either statically or dynamically
 127:../freertos/tasks.c **** allocated RAM, in which case a member of the TCB is used to record whether the
 128:../freertos/tasks.c **** stack and/or TCB were allocated statically or dynamically, so when a task is
 129:../freertos/tasks.c **** deleted the RAM that was allocated dynamically is freed again and no attempt is
 130:../freertos/tasks.c **** made to free the RAM that was allocated statically.
 131:../freertos/tasks.c **** tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE is only true if it is possible for a
 132:../freertos/tasks.c **** task to be created using either statically or dynamically allocated RAM.  Note
 133:../freertos/tasks.c **** that if portUSING_MPU_WRAPPERS is 1 then a protected task can be created with
 134:../freertos/tasks.c **** a statically allocated stack and a dynamically allocated TCB. */
 135:../freertos/tasks.c **** #define tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE ( ( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && (
 136:../freertos/tasks.c **** #define tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB 		( ( uint8_t ) 0 )
 137:../freertos/tasks.c **** #define tskSTATICALLY_ALLOCATED_STACK_ONLY 			( ( uint8_t ) 1 )
 138:../freertos/tasks.c **** #define tskSTATICALLY_ALLOCATED_STACK_AND_TCB		( ( uint8_t ) 2 )
 139:../freertos/tasks.c **** 
 140:../freertos/tasks.c **** /*
 141:../freertos/tasks.c ****  * Macros used by vListTask to indicate which state a task is in.
 142:../freertos/tasks.c ****  */
 143:../freertos/tasks.c **** #define tskBLOCKED_CHAR		( 'B' )
 144:../freertos/tasks.c **** #define tskREADY_CHAR		( 'R' )
 145:../freertos/tasks.c **** #define tskDELETED_CHAR		( 'D' )
 146:../freertos/tasks.c **** #define tskSUSPENDED_CHAR	( 'S' )
 147:../freertos/tasks.c **** 
 148:../freertos/tasks.c **** /*
 149:../freertos/tasks.c ****  * Some kernel aware debuggers require the data the debugger needs access to be
 150:../freertos/tasks.c ****  * global, rather than file scope.
 151:../freertos/tasks.c ****  */
 152:../freertos/tasks.c **** #ifdef portREMOVE_STATIC_QUALIFIER
 153:../freertos/tasks.c **** 	#define static
 154:../freertos/tasks.c **** #endif
 155:../freertos/tasks.c **** 
 156:../freertos/tasks.c **** #if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
 157:../freertos/tasks.c **** 
 158:../freertos/tasks.c **** 	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 0 then task selection is
 159:../freertos/tasks.c **** 	performed in a generic way that is not optimised to any particular
 160:../freertos/tasks.c **** 	microcontroller architecture. */
 161:../freertos/tasks.c **** 
 162:../freertos/tasks.c **** 	/* uxTopReadyPriority holds the priority of the highest priority ready
 163:../freertos/tasks.c **** 	state task. */
 164:../freertos/tasks.c **** 	#define taskRECORD_READY_PRIORITY( uxPriority )														\
 165:../freertos/tasks.c **** 	{																									\
 166:../freertos/tasks.c **** 		if( ( uxPriority ) > uxTopReadyPriority )														\
 167:../freertos/tasks.c **** 		{																								\
 168:../freertos/tasks.c **** 			uxTopReadyPriority = ( uxPriority );														\
 169:../freertos/tasks.c **** 		}																								\
 170:../freertos/tasks.c **** 	} /* taskRECORD_READY_PRIORITY */
 171:../freertos/tasks.c **** 
 172:../freertos/tasks.c **** 	/*-----------------------------------------------------------*/
 173:../freertos/tasks.c **** 
 174:../freertos/tasks.c **** 	#define taskSELECT_HIGHEST_PRIORITY_TASK()															\
 175:../freertos/tasks.c **** 	{																									\
 176:../freertos/tasks.c **** 	UBaseType_t uxTopPriority = uxTopReadyPriority;														\
 177:../freertos/tasks.c **** 																										\
 178:../freertos/tasks.c **** 		/* Find the highest priority queue that contains ready tasks. */								\
 179:../freertos/tasks.c **** 		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopPriority ] ) ) )							\
 180:../freertos/tasks.c **** 		{																								\
 181:../freertos/tasks.c **** 			configASSERT( uxTopPriority );																\
 182:../freertos/tasks.c **** 			--uxTopPriority;																			\
 183:../freertos/tasks.c **** 		}																								\
 184:../freertos/tasks.c **** 																										\
 185:../freertos/tasks.c **** 		/* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of						\
 186:../freertos/tasks.c **** 		the	same priority get an equal share of the processor time. */									\
 187:../freertos/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );			\
 188:../freertos/tasks.c **** 		uxTopReadyPriority = uxTopPriority;																\
 189:../freertos/tasks.c **** 	} /* taskSELECT_HIGHEST_PRIORITY_TASK */
 190:../freertos/tasks.c **** 
 191:../freertos/tasks.c **** 	/*-----------------------------------------------------------*/
 192:../freertos/tasks.c **** 
 193:../freertos/tasks.c **** 	/* Define away taskRESET_READY_PRIORITY() and portRESET_READY_PRIORITY() as
 194:../freertos/tasks.c **** 	they are only required when a port optimised method of task selection is
 195:../freertos/tasks.c **** 	being used. */
 196:../freertos/tasks.c **** 	#define taskRESET_READY_PRIORITY( uxPriority )
 197:../freertos/tasks.c **** 	#define portRESET_READY_PRIORITY( uxPriority, uxTopReadyPriority )
 198:../freertos/tasks.c **** 
 199:../freertos/tasks.c **** #else /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 200:../freertos/tasks.c **** 
 201:../freertos/tasks.c **** 	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 1 then task selection is
 202:../freertos/tasks.c **** 	performed in a way that is tailored to the particular microcontroller
 203:../freertos/tasks.c **** 	architecture being used. */
 204:../freertos/tasks.c **** 
 205:../freertos/tasks.c **** 	/* A port optimised version is provided.  Call the port defined macros. */
 206:../freertos/tasks.c **** 	#define taskRECORD_READY_PRIORITY( uxPriority )	portRECORD_READY_PRIORITY( uxPriority, uxTopReadyP
 207:../freertos/tasks.c **** 
 208:../freertos/tasks.c **** 	/*-----------------------------------------------------------*/
 209:../freertos/tasks.c **** 
 210:../freertos/tasks.c **** 	#define taskSELECT_HIGHEST_PRIORITY_TASK()														\
 211:../freertos/tasks.c **** 	{																								\
 212:../freertos/tasks.c **** 	UBaseType_t uxTopPriority;																		\
 213:../freertos/tasks.c **** 																									\
 214:../freertos/tasks.c **** 		/* Find the highest priority list that contains ready tasks. */								\
 215:../freertos/tasks.c **** 		portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );								\
 216:../freertos/tasks.c **** 		configASSERT( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ uxTopPriority ] ) ) > 0 );		\
 217:../freertos/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );		\
 218:../freertos/tasks.c **** 	} /* taskSELECT_HIGHEST_PRIORITY_TASK() */
 219:../freertos/tasks.c **** 
 220:../freertos/tasks.c **** 	/*-----------------------------------------------------------*/
 221:../freertos/tasks.c **** 
 222:../freertos/tasks.c **** 	/* A port optimised version is provided, call it only if the TCB being reset
 223:../freertos/tasks.c **** 	is being referenced from a ready list.  If it is referenced from a delayed
 224:../freertos/tasks.c **** 	or suspended list then it won't be in a ready list. */
 225:../freertos/tasks.c **** 	#define taskRESET_READY_PRIORITY( uxPriority )														\
 226:../freertos/tasks.c **** 	{																									\
 227:../freertos/tasks.c **** 		if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ ( uxPriority ) ] ) ) == ( UBaseType_t ) 0 )	\
 228:../freertos/tasks.c **** 		{																								\
 229:../freertos/tasks.c **** 			portRESET_READY_PRIORITY( ( uxPriority ), ( uxTopReadyPriority ) );							\
 230:../freertos/tasks.c **** 		}																								\
 231:../freertos/tasks.c **** 	}
 232:../freertos/tasks.c **** 
 233:../freertos/tasks.c **** #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 234:../freertos/tasks.c **** 
 235:../freertos/tasks.c **** /*-----------------------------------------------------------*/
 236:../freertos/tasks.c **** 
 237:../freertos/tasks.c **** /* pxDelayedTaskList and pxOverflowDelayedTaskList are switched when the tick
 238:../freertos/tasks.c **** count overflows. */
 239:../freertos/tasks.c **** #define taskSWITCH_DELAYED_LISTS()																	\
 240:../freertos/tasks.c **** {																									\
 241:../freertos/tasks.c **** 	List_t *pxTemp;																					\
 242:../freertos/tasks.c **** 																									\
 243:../freertos/tasks.c **** 	/* The delayed tasks list should be empty when the lists are switched. */						\
 244:../freertos/tasks.c **** 	configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );										\
 245:../freertos/tasks.c **** 																									\
 246:../freertos/tasks.c **** 	pxTemp = pxDelayedTaskList;																		\
 247:../freertos/tasks.c **** 	pxDelayedTaskList = pxOverflowDelayedTaskList;													\
 248:../freertos/tasks.c **** 	pxOverflowDelayedTaskList = pxTemp;																\
 249:../freertos/tasks.c **** 	xNumOfOverflows++;																				\
 250:../freertos/tasks.c **** 	prvResetNextTaskUnblockTime();																	\
 251:../freertos/tasks.c **** }
 252:../freertos/tasks.c **** 
 253:../freertos/tasks.c **** /*-----------------------------------------------------------*/
 254:../freertos/tasks.c **** 
 255:../freertos/tasks.c **** /*
 256:../freertos/tasks.c ****  * Place the task represented by pxTCB into the appropriate ready list for
 257:../freertos/tasks.c ****  * the task.  It is inserted at the end of the list.
 258:../freertos/tasks.c ****  */
 259:../freertos/tasks.c **** #define prvAddTaskToReadyList( pxTCB )																\
 260:../freertos/tasks.c **** 	traceMOVED_TASK_TO_READY_STATE( pxTCB );														\
 261:../freertos/tasks.c **** 	taskRECORD_READY_PRIORITY( ( pxTCB )->uxPriority );												\
 262:../freertos/tasks.c **** 	vListInsertEnd( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xStateListItem ) );
 263:../freertos/tasks.c **** 	tracePOST_MOVED_TASK_TO_READY_STATE( pxTCB )
 264:../freertos/tasks.c **** /*-----------------------------------------------------------*/
 265:../freertos/tasks.c **** 
 266:../freertos/tasks.c **** /*
 267:../freertos/tasks.c ****  * Several functions take an TaskHandle_t parameter that can optionally be NULL,
 268:../freertos/tasks.c ****  * where NULL is used to indicate that the handle of the currently executing
 269:../freertos/tasks.c ****  * task should be used in place of the parameter.  This macro simply checks to
 270:../freertos/tasks.c ****  * see if the parameter is NULL and returns a pointer to the appropriate TCB.
 271:../freertos/tasks.c ****  */
 272:../freertos/tasks.c **** #define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? ( TCB_t * ) pxCurrentTCB : ( T
 273:../freertos/tasks.c **** 
 274:../freertos/tasks.c **** /* The item value of the event list item is normally used to hold the priority
 275:../freertos/tasks.c **** of the task to which it belongs (coded to allow it to be held in reverse
 276:../freertos/tasks.c **** priority order).  However, it is occasionally borrowed for other purposes.  It
 277:../freertos/tasks.c **** is important its value is not updated due to a task priority change while it is
 278:../freertos/tasks.c **** being used for another purpose.  The following bit definition is used to inform
 279:../freertos/tasks.c **** the scheduler that the value should not be changed - in which case it is the
 280:../freertos/tasks.c **** responsibility of whichever module is using the value to ensure it gets set back
 281:../freertos/tasks.c **** to its original value when it is released. */
 282:../freertos/tasks.c **** #if( configUSE_16_BIT_TICKS == 1 )
 283:../freertos/tasks.c **** 	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x8000U
 284:../freertos/tasks.c **** #else
 285:../freertos/tasks.c **** 	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x80000000UL
 286:../freertos/tasks.c **** #endif
 287:../freertos/tasks.c **** 
 288:../freertos/tasks.c **** /*
 289:../freertos/tasks.c ****  * Task control block.  A task control block (TCB) is allocated for each task,
 290:../freertos/tasks.c ****  * and stores task state information, including a pointer to the task's context
 291:../freertos/tasks.c ****  * (the task's run time environment, including register values)
 292:../freertos/tasks.c ****  */
 293:../freertos/tasks.c **** typedef struct tskTaskControlBlock
 294:../freertos/tasks.c **** {
 295:../freertos/tasks.c **** 	volatile StackType_t	*pxTopOfStack;	/*< Points to the location of the last item placed on the task
 296:../freertos/tasks.c **** 
 297:../freertos/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
 298:../freertos/tasks.c **** 		xMPU_SETTINGS	xMPUSettings;		/*< The MPU settings are defined as part of the port layer.  THIS MU
 299:../freertos/tasks.c **** 	#endif
 300:../freertos/tasks.c **** 
 301:../freertos/tasks.c **** 	ListItem_t			xStateListItem;	/*< The list that the state list item of a task is reference from den
 302:../freertos/tasks.c **** 	ListItem_t			xEventListItem;		/*< Used to reference a task from an event list. */
 303:../freertos/tasks.c **** 	UBaseType_t			uxPriority;			/*< The priority of the task.  0 is the lowest priority. */
 304:../freertos/tasks.c **** 	StackType_t			*pxStack;			/*< Points to the start of the stack. */
 305:../freertos/tasks.c **** 	char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when created.
 306:../freertos/tasks.c **** 
 307:../freertos/tasks.c **** 	#if ( ( portSTACK_GROWTH > 0 ) || ( configRECORD_STACK_HIGH_ADDRESS == 1 ) )
 308:../freertos/tasks.c **** 		StackType_t		*pxEndOfStack;		/*< Points to the highest valid address for the stack. */
 309:../freertos/tasks.c **** 	#endif
 310:../freertos/tasks.c **** 
 311:../freertos/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
 312:../freertos/tasks.c **** 		UBaseType_t		uxCriticalNesting;	/*< Holds the critical section nesting depth for ports that do no
 313:../freertos/tasks.c **** 	#endif
 314:../freertos/tasks.c **** 
 315:../freertos/tasks.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 316:../freertos/tasks.c **** 		UBaseType_t		uxTCBNumber;		/*< Stores a number that increments each time a TCB is created.  It al
 317:../freertos/tasks.c **** 		UBaseType_t		uxTaskNumber;		/*< Stores a number specifically for use by third party trace code. *
 318:../freertos/tasks.c **** 	#endif
 319:../freertos/tasks.c **** 
 320:../freertos/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 321:../freertos/tasks.c **** 		UBaseType_t		uxBasePriority;		/*< The priority last assigned to the task - used by the priority i
 322:../freertos/tasks.c **** 		UBaseType_t		uxMutexesHeld;
 323:../freertos/tasks.c **** 	#endif
 324:../freertos/tasks.c **** 
 325:../freertos/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
 326:../freertos/tasks.c **** 		TaskHookFunction_t pxTaskTag;
 327:../freertos/tasks.c **** 	#endif
 328:../freertos/tasks.c **** 
 329:../freertos/tasks.c **** 	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )
 330:../freertos/tasks.c **** 		void *pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];
 331:../freertos/tasks.c **** 	#endif
 332:../freertos/tasks.c **** 
 333:../freertos/tasks.c **** 	#if( configGENERATE_RUN_TIME_STATS == 1 )
 334:../freertos/tasks.c **** 		uint32_t		ulRunTimeCounter;	/*< Stores the amount of time the task has spent in the Running state
 335:../freertos/tasks.c **** 	#endif
 336:../freertos/tasks.c **** 
 337:../freertos/tasks.c **** 	#if ( configUSE_NEWLIB_REENTRANT == 1 )
 338:../freertos/tasks.c **** 		/* Allocate a Newlib reent structure that is specific to this task.
 339:../freertos/tasks.c **** 		Note Newlib support has been included by popular demand, but is not
 340:../freertos/tasks.c **** 		used by the FreeRTOS maintainers themselves.  FreeRTOS is not
 341:../freertos/tasks.c **** 		responsible for resulting newlib operation.  User must be familiar with
 342:../freertos/tasks.c **** 		newlib and must provide system-wide implementations of the necessary
 343:../freertos/tasks.c **** 		stubs. Be warned that (at the time of writing) the current newlib design
 344:../freertos/tasks.c **** 		implements a system-wide malloc() that must be provided with locks. */
 345:../freertos/tasks.c **** 		struct	_reent xNewLib_reent;
 346:../freertos/tasks.c **** 	#endif
 347:../freertos/tasks.c **** 
 348:../freertos/tasks.c **** 	#if( configUSE_TASK_NOTIFICATIONS == 1 )
 349:../freertos/tasks.c **** 		volatile uint32_t ulNotifiedValue;
 350:../freertos/tasks.c **** 		volatile uint8_t ucNotifyState;
 351:../freertos/tasks.c **** 	#endif
 352:../freertos/tasks.c **** 
 353:../freertos/tasks.c **** 	/* See the comments above the definition of
 354:../freertos/tasks.c **** 	tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE. */
 355:../freertos/tasks.c **** 	#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )
 356:../freertos/tasks.c **** 		uint8_t	ucStaticallyAllocated; 		/*< Set to pdTRUE if the task is a statically allocated to ensur
 357:../freertos/tasks.c **** 	#endif
 358:../freertos/tasks.c **** 
 359:../freertos/tasks.c **** 	#if( INCLUDE_xTaskAbortDelay == 1 )
 360:../freertos/tasks.c **** 		uint8_t ucDelayAborted;
 361:../freertos/tasks.c **** 	#endif
 362:../freertos/tasks.c **** 
 363:../freertos/tasks.c **** } tskTCB;
 364:../freertos/tasks.c **** 
 365:../freertos/tasks.c **** /* The old tskTCB name is maintained above then typedefed to the new TCB_t name
 366:../freertos/tasks.c **** below to enable the use of older kernel aware debuggers. */
 367:../freertos/tasks.c **** typedef tskTCB TCB_t;
 368:../freertos/tasks.c **** 
 369:../freertos/tasks.c **** /*lint -e956 A manual analysis and inspection has been used to determine which
 370:../freertos/tasks.c **** static variables must be declared volatile. */
 371:../freertos/tasks.c **** 
 372:../freertos/tasks.c **** PRIVILEGED_DATA TCB_t * volatile pxCurrentTCB = NULL;
 373:../freertos/tasks.c **** 
 374:../freertos/tasks.c **** /* Lists for ready and blocked tasks. --------------------*/
 375:../freertos/tasks.c **** PRIVILEGED_DATA static List_t pxReadyTasksLists[ configMAX_PRIORITIES ];/*< Prioritised ready tasks
 376:../freertos/tasks.c **** PRIVILEGED_DATA static List_t xDelayedTaskList1;						/*< Delayed tasks. */
 377:../freertos/tasks.c **** PRIVILEGED_DATA static List_t xDelayedTaskList2;						/*< Delayed tasks (two lists are used - one f
 378:../freertos/tasks.c **** PRIVILEGED_DATA static List_t * volatile pxDelayedTaskList;				/*< Points to the delayed task list 
 379:../freertos/tasks.c **** PRIVILEGED_DATA static List_t * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task
 380:../freertos/tasks.c **** PRIVILEGED_DATA static List_t xPendingReadyList;						/*< Tasks that have been readied while the sc
 381:../freertos/tasks.c **** 
 382:../freertos/tasks.c **** #if( INCLUDE_vTaskDelete == 1 )
 383:../freertos/tasks.c **** 
 384:../freertos/tasks.c **** 	PRIVILEGED_DATA static List_t xTasksWaitingTermination;				/*< Tasks that have been deleted - but 
 385:../freertos/tasks.c **** 	PRIVILEGED_DATA static volatile UBaseType_t uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
 386:../freertos/tasks.c **** 
 387:../freertos/tasks.c **** #endif
 388:../freertos/tasks.c **** 
 389:../freertos/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 390:../freertos/tasks.c **** 
 391:../freertos/tasks.c **** 	PRIVILEGED_DATA static List_t xSuspendedTaskList;					/*< Tasks that are currently suspended. */
 392:../freertos/tasks.c **** 
 393:../freertos/tasks.c **** #endif
 394:../freertos/tasks.c **** 
 395:../freertos/tasks.c **** /* Other file private variables. --------------------------------*/
 396:../freertos/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxCurrentNumberOfTasks 	= ( UBaseType_t ) 0U;
 397:../freertos/tasks.c **** PRIVILEGED_DATA static volatile TickType_t xTickCount 				= ( TickType_t ) 0U;
 398:../freertos/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxTopReadyPriority 		= tskIDLE_PRIORITY;
 399:../freertos/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xSchedulerRunning 		= pdFALSE;
 400:../freertos/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxPendedTicks 			= ( UBaseType_t ) 0U;
 401:../freertos/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xYieldPending 			= pdFALSE;
 402:../freertos/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xNumOfOverflows 			= ( BaseType_t ) 0;
 403:../freertos/tasks.c **** PRIVILEGED_DATA static UBaseType_t uxTaskNumber 					= ( UBaseType_t ) 0U;
 404:../freertos/tasks.c **** PRIVILEGED_DATA static volatile TickType_t xNextTaskUnblockTime		= ( TickType_t ) 0U; /* Initialise
 405:../freertos/tasks.c **** PRIVILEGED_DATA static TaskHandle_t xIdleTaskHandle					= NULL;			/*< Holds the handle of the idle 
 406:../freertos/tasks.c **** 
 407:../freertos/tasks.c **** /* Context switches are held pending while the scheduler is suspended.  Also,
 408:../freertos/tasks.c **** interrupts must not manipulate the xStateListItem of a TCB, or any of the
 409:../freertos/tasks.c **** lists the xStateListItem can be referenced from, if the scheduler is suspended.
 410:../freertos/tasks.c **** If an interrupt needs to unblock a task while the scheduler is suspended then it
 411:../freertos/tasks.c **** moves the task's event list item into the xPendingReadyList, ready for the
 412:../freertos/tasks.c **** kernel to move the task from the pending ready list into the real ready list
 413:../freertos/tasks.c **** when the scheduler is unsuspended.  The pending ready list itself can only be
 414:../freertos/tasks.c **** accessed from a critical section. */
 415:../freertos/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxSchedulerSuspended	= ( UBaseType_t ) pdFALSE;
 416:../freertos/tasks.c **** 
 417:../freertos/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
 418:../freertos/tasks.c **** 
 419:../freertos/tasks.c **** 	PRIVILEGED_DATA static uint32_t ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/counter
 420:../freertos/tasks.c **** 	PRIVILEGED_DATA static uint32_t ulTotalRunTime = 0UL;		/*< Holds the total amount of execution tim
 421:../freertos/tasks.c **** 
 422:../freertos/tasks.c **** #endif
 423:../freertos/tasks.c **** 
 424:../freertos/tasks.c **** /*lint +e956 */
 425:../freertos/tasks.c **** 
 426:../freertos/tasks.c **** /*-----------------------------------------------------------*/
 427:../freertos/tasks.c **** 
 428:../freertos/tasks.c **** /* Callback function prototypes. --------------------------*/
 429:../freertos/tasks.c **** #if(  configCHECK_FOR_STACK_OVERFLOW > 0 )
 430:../freertos/tasks.c **** 	extern void vApplicationStackOverflowHook( TaskHandle_t xTask, char *pcTaskName );
 431:../freertos/tasks.c **** #endif
 432:../freertos/tasks.c **** 
 433:../freertos/tasks.c **** #if( configUSE_TICK_HOOK > 0 )
 434:../freertos/tasks.c **** 	extern void vApplicationTickHook( void );
 435:../freertos/tasks.c **** #endif
 436:../freertos/tasks.c **** 
 437:../freertos/tasks.c **** #if( configSUPPORT_STATIC_ALLOCATION == 1 )
 438:../freertos/tasks.c **** 	extern void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxI
 439:../freertos/tasks.c **** #endif
 440:../freertos/tasks.c **** 
 441:../freertos/tasks.c **** /* File private functions. --------------------------------*/
 442:../freertos/tasks.c **** 
 443:../freertos/tasks.c **** /**
 444:../freertos/tasks.c ****  * Utility task that simply returns pdTRUE if the task referenced by xTask is
 445:../freertos/tasks.c ****  * currently in the Suspended state, or pdFALSE if the task referenced by xTask
 446:../freertos/tasks.c ****  * is in any other state.
 447:../freertos/tasks.c ****  */
 448:../freertos/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 449:../freertos/tasks.c **** 	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
 450:../freertos/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
 451:../freertos/tasks.c **** 
 452:../freertos/tasks.c **** /*
 453:../freertos/tasks.c ****  * Utility to ready all the lists used by the scheduler.  This is called
 454:../freertos/tasks.c ****  * automatically upon the creation of the first task.
 455:../freertos/tasks.c ****  */
 456:../freertos/tasks.c **** static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
 457:../freertos/tasks.c **** 
 458:../freertos/tasks.c **** /*
 459:../freertos/tasks.c ****  * The idle task, which as all tasks is implemented as a never ending loop.
 460:../freertos/tasks.c ****  * The idle task is automatically created and added to the ready lists upon
 461:../freertos/tasks.c ****  * creation of the first user task.
 462:../freertos/tasks.c ****  *
 463:../freertos/tasks.c ****  * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
 464:../freertos/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
 465:../freertos/tasks.c ****  *
 466:../freertos/tasks.c ****  * void prvIdleTask( void *pvParameters );
 467:../freertos/tasks.c ****  *
 468:../freertos/tasks.c ****  */
 469:../freertos/tasks.c **** static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
 470:../freertos/tasks.c **** 
 471:../freertos/tasks.c **** /*
 472:../freertos/tasks.c ****  * Utility to free all memory allocated by the scheduler to hold a TCB,
 473:../freertos/tasks.c ****  * including the stack pointed to by the TCB.
 474:../freertos/tasks.c ****  *
 475:../freertos/tasks.c ****  * This does not free memory allocated by the task itself (i.e. memory
 476:../freertos/tasks.c ****  * allocated by calls to pvPortMalloc from within the tasks application code).
 477:../freertos/tasks.c ****  */
 478:../freertos/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 479:../freertos/tasks.c **** 
 480:../freertos/tasks.c **** 	static void prvDeleteTCB( TCB_t *pxTCB ) PRIVILEGED_FUNCTION;
 481:../freertos/tasks.c **** 
 482:../freertos/tasks.c **** #endif
 483:../freertos/tasks.c **** 
 484:../freertos/tasks.c **** /*
 485:../freertos/tasks.c ****  * Used only by the idle task.  This checks to see if anything has been placed
 486:../freertos/tasks.c ****  * in the list of tasks waiting to be deleted.  If so the task is cleaned up
 487:../freertos/tasks.c ****  * and its TCB deleted.
 488:../freertos/tasks.c ****  */
 489:../freertos/tasks.c **** static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
 490:../freertos/tasks.c **** 
 491:../freertos/tasks.c **** /*
 492:../freertos/tasks.c ****  * The currently executing task is entering the Blocked state.  Add the task to
 493:../freertos/tasks.c ****  * either the current or the overflow delayed task list.
 494:../freertos/tasks.c ****  */
 495:../freertos/tasks.c **** static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockInde
 496:../freertos/tasks.c **** 
 497:../freertos/tasks.c **** /*
 498:../freertos/tasks.c ****  * Fills an TaskStatus_t structure with information on each task that is
 499:../freertos/tasks.c ****  * referenced from the pxList list (which may be a ready list, a delayed list,
 500:../freertos/tasks.c ****  * a suspended list, etc.).
 501:../freertos/tasks.c ****  *
 502:../freertos/tasks.c ****  * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
 503:../freertos/tasks.c ****  * NORMAL APPLICATION CODE.
 504:../freertos/tasks.c ****  */
 505:../freertos/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 506:../freertos/tasks.c **** 
 507:../freertos/tasks.c **** 	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, 
 508:../freertos/tasks.c **** 
 509:../freertos/tasks.c **** #endif
 510:../freertos/tasks.c **** 
 511:../freertos/tasks.c **** /*
 512:../freertos/tasks.c ****  * Searches pxList for a task with name pcNameToQuery - returning a handle to
 513:../freertos/tasks.c ****  * the task if it is found, or NULL if the task is not found.
 514:../freertos/tasks.c ****  */
 515:../freertos/tasks.c **** #if ( INCLUDE_xTaskGetHandle == 1 )
 516:../freertos/tasks.c **** 
 517:../freertos/tasks.c **** 	static TCB_t *prvSearchForNameWithinSingleList( List_t *pxList, const char pcNameToQuery[] ) PRIVI
 518:../freertos/tasks.c **** 
 519:../freertos/tasks.c **** #endif
 520:../freertos/tasks.c **** 
 521:../freertos/tasks.c **** /*
 522:../freertos/tasks.c ****  * When a task is created, the stack of the task is filled with a known value.
 523:../freertos/tasks.c ****  * This function determines the 'high water mark' of the task stack by
 524:../freertos/tasks.c ****  * determining how much of the stack remains at the original preset value.
 525:../freertos/tasks.c ****  */
 526:../freertos/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
 527:../freertos/tasks.c **** 
 528:../freertos/tasks.c **** 	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte ) PRIVILEGED_FUNCTION;
 529:../freertos/tasks.c **** 
 530:../freertos/tasks.c **** #endif
 531:../freertos/tasks.c **** 
 532:../freertos/tasks.c **** /*
 533:../freertos/tasks.c ****  * Return the amount of time, in ticks, that will pass before the kernel will
 534:../freertos/tasks.c ****  * next move a task from the Blocked state to the Running state.
 535:../freertos/tasks.c ****  *
 536:../freertos/tasks.c ****  * This conditional compilation should use inequality to 0, not equality to 1.
 537:../freertos/tasks.c ****  * This is to ensure portSUPPRESS_TICKS_AND_SLEEP() can be called when user
 538:../freertos/tasks.c ****  * defined low power mode implementations require configUSE_TICKLESS_IDLE to be
 539:../freertos/tasks.c ****  * set to a value other than 1.
 540:../freertos/tasks.c ****  */
 541:../freertos/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
 542:../freertos/tasks.c **** 
 543:../freertos/tasks.c **** 	static TickType_t prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;
 544:../freertos/tasks.c **** 
 545:../freertos/tasks.c **** #endif
 546:../freertos/tasks.c **** 
 547:../freertos/tasks.c **** /*
 548:../freertos/tasks.c ****  * Set xNextTaskUnblockTime to the time at which the next Blocked state task
 549:../freertos/tasks.c ****  * will exit the Blocked state.
 550:../freertos/tasks.c ****  */
 551:../freertos/tasks.c **** static void prvResetNextTaskUnblockTime( void );
 552:../freertos/tasks.c **** 
 553:../freertos/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
 554:../freertos/tasks.c **** 
 555:../freertos/tasks.c **** 	/*
 556:../freertos/tasks.c **** 	 * Helper function used to pad task names with spaces when printing out
 557:../freertos/tasks.c **** 	 * human readable tables of task information.
 558:../freertos/tasks.c **** 	 */
 559:../freertos/tasks.c **** 	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName ) PRIVILEGED_FUNCTION;
 560:../freertos/tasks.c **** 
 561:../freertos/tasks.c **** #endif
 562:../freertos/tasks.c **** 
 563:../freertos/tasks.c **** /*
 564:../freertos/tasks.c ****  * Called after a Task_t structure has been allocated either statically or
 565:../freertos/tasks.c ****  * dynamically to fill in the structure's members.
 566:../freertos/tasks.c ****  */
 567:../freertos/tasks.c **** static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
 568:../freertos/tasks.c **** 									const char * const pcName,
 569:../freertos/tasks.c **** 									const uint32_t ulStackDepth,
 570:../freertos/tasks.c **** 									void * const pvParameters,
 571:../freertos/tasks.c **** 									UBaseType_t uxPriority,
 572:../freertos/tasks.c **** 									TaskHandle_t * const pxCreatedTask,
 573:../freertos/tasks.c **** 									TCB_t *pxNewTCB,
 574:../freertos/tasks.c **** 									const MemoryRegion_t * const xRegions ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char
 575:../freertos/tasks.c **** 
 576:../freertos/tasks.c **** /*
 577:../freertos/tasks.c ****  * Called after a new task has been created and initialised to place the task
 578:../freertos/tasks.c ****  * under the control of the scheduler.
 579:../freertos/tasks.c ****  */
 580:../freertos/tasks.c **** static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB ) PRIVILEGED_FUNCTION;
 581:../freertos/tasks.c **** 
 582:../freertos/tasks.c **** /*-----------------------------------------------------------*/
 583:../freertos/tasks.c **** 
 584:../freertos/tasks.c **** #if( configSUPPORT_STATIC_ALLOCATION == 1 )
 585:../freertos/tasks.c **** 
 586:../freertos/tasks.c **** 	TaskHandle_t xTaskCreateStatic(	TaskFunction_t pxTaskCode,
 587:../freertos/tasks.c **** 									const char * const pcName,
 588:../freertos/tasks.c **** 									const uint32_t ulStackDepth,
 589:../freertos/tasks.c **** 									void * const pvParameters,
 590:../freertos/tasks.c **** 									UBaseType_t uxPriority,
 591:../freertos/tasks.c **** 									StackType_t * const puxStackBuffer,
 592:../freertos/tasks.c **** 									StaticTask_t * const pxTaskBuffer ) /*lint !e971 Unqualified char types are allowed for st
 593:../freertos/tasks.c **** 	{
 594:../freertos/tasks.c **** 	TCB_t *pxNewTCB;
 595:../freertos/tasks.c **** 	TaskHandle_t xReturn;
 596:../freertos/tasks.c **** 
 597:../freertos/tasks.c **** 		configASSERT( puxStackBuffer != NULL );
 598:../freertos/tasks.c **** 		configASSERT( pxTaskBuffer != NULL );
 599:../freertos/tasks.c **** 
 600:../freertos/tasks.c **** 		if( ( pxTaskBuffer != NULL ) && ( puxStackBuffer != NULL ) )
 601:../freertos/tasks.c **** 		{
 602:../freertos/tasks.c **** 			/* The memory used for the task's TCB and stack are passed into this
 603:../freertos/tasks.c **** 			function - use them. */
 604:../freertos/tasks.c **** 			pxNewTCB = ( TCB_t * ) pxTaskBuffer; /*lint !e740 Unusual cast is ok as the structures are desig
 605:../freertos/tasks.c **** 			pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
 606:../freertos/tasks.c **** 
 607:../freertos/tasks.c **** 			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )
 608:../freertos/tasks.c **** 			{
 609:../freertos/tasks.c **** 				/* Tasks can be created statically or dynamically, so note this
 610:../freertos/tasks.c **** 				task was created statically in case the task is later deleted. */
 611:../freertos/tasks.c **** 				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 612:../freertos/tasks.c **** 			}
 613:../freertos/tasks.c **** 			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
 614:../freertos/tasks.c **** 
 615:../freertos/tasks.c **** 			prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNe
 616:../freertos/tasks.c **** 			prvAddNewTaskToReadyList( pxNewTCB );
 617:../freertos/tasks.c **** 		}
 618:../freertos/tasks.c **** 		else
 619:../freertos/tasks.c **** 		{
 620:../freertos/tasks.c **** 			xReturn = NULL;
 621:../freertos/tasks.c **** 		}
 622:../freertos/tasks.c **** 
 623:../freertos/tasks.c **** 		return xReturn;
 624:../freertos/tasks.c **** 	}
 625:../freertos/tasks.c **** 
 626:../freertos/tasks.c **** #endif /* SUPPORT_STATIC_ALLOCATION */
 627:../freertos/tasks.c **** /*-----------------------------------------------------------*/
 628:../freertos/tasks.c **** 
 629:../freertos/tasks.c **** #if( portUSING_MPU_WRAPPERS == 1 )
 630:../freertos/tasks.c **** 
 631:../freertos/tasks.c **** 	BaseType_t xTaskCreateRestricted( const TaskParameters_t * const pxTaskDefinition, TaskHandle_t *p
 632:../freertos/tasks.c **** 	{
 633:../freertos/tasks.c **** 	TCB_t *pxNewTCB;
 634:../freertos/tasks.c **** 	BaseType_t xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 635:../freertos/tasks.c **** 
 636:../freertos/tasks.c **** 		configASSERT( pxTaskDefinition->puxStackBuffer );
 637:../freertos/tasks.c **** 
 638:../freertos/tasks.c **** 		if( pxTaskDefinition->puxStackBuffer != NULL )
 639:../freertos/tasks.c **** 		{
 640:../freertos/tasks.c **** 			/* Allocate space for the TCB.  Where the memory comes from depends
 641:../freertos/tasks.c **** 			on the implementation of the port malloc function and whether or
 642:../freertos/tasks.c **** 			not static allocation is being used. */
 643:../freertos/tasks.c **** 			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
 644:../freertos/tasks.c **** 
 645:../freertos/tasks.c **** 			if( pxNewTCB != NULL )
 646:../freertos/tasks.c **** 			{
 647:../freertos/tasks.c **** 				/* Store the stack location in the TCB. */
 648:../freertos/tasks.c **** 				pxNewTCB->pxStack = pxTaskDefinition->puxStackBuffer;
 649:../freertos/tasks.c **** 
 650:../freertos/tasks.c **** 				/* Tasks can be created statically or dynamically, so note
 651:../freertos/tasks.c **** 				this task had a statically allocated stack in case it is
 652:../freertos/tasks.c **** 				later deleted.  The TCB was allocated dynamically. */
 653:../freertos/tasks.c **** 				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_ONLY;
 654:../freertos/tasks.c **** 
 655:../freertos/tasks.c **** 				prvInitialiseNewTask(	pxTaskDefinition->pvTaskCode,
 656:../freertos/tasks.c **** 										pxTaskDefinition->pcName,
 657:../freertos/tasks.c **** 										( uint32_t ) pxTaskDefinition->usStackDepth,
 658:../freertos/tasks.c **** 										pxTaskDefinition->pvParameters,
 659:../freertos/tasks.c **** 										pxTaskDefinition->uxPriority,
 660:../freertos/tasks.c **** 										pxCreatedTask, pxNewTCB,
 661:../freertos/tasks.c **** 										pxTaskDefinition->xRegions );
 662:../freertos/tasks.c **** 
 663:../freertos/tasks.c **** 				prvAddNewTaskToReadyList( pxNewTCB );
 664:../freertos/tasks.c **** 				xReturn = pdPASS;
 665:../freertos/tasks.c **** 			}
 666:../freertos/tasks.c **** 		}
 667:../freertos/tasks.c **** 
 668:../freertos/tasks.c **** 		return xReturn;
 669:../freertos/tasks.c **** 	}
 670:../freertos/tasks.c **** 
 671:../freertos/tasks.c **** #endif /* portUSING_MPU_WRAPPERS */
 672:../freertos/tasks.c **** /*-----------------------------------------------------------*/
 673:../freertos/tasks.c **** 
 674:../freertos/tasks.c **** #if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
 675:../freertos/tasks.c **** 
 676:../freertos/tasks.c **** 	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
 677:../freertos/tasks.c **** 							const char * const pcName,
 678:../freertos/tasks.c **** 							const uint16_t usStackDepth,
 679:../freertos/tasks.c **** 							void * const pvParameters,
 680:../freertos/tasks.c **** 							UBaseType_t uxPriority,
 681:../freertos/tasks.c **** 							TaskHandle_t * const pxCreatedTask ) /*lint !e971 Unqualified char types are allowed for str
 682:../freertos/tasks.c **** 	{
 153              		.loc 1 682 0
 154              		.cfi_startproc
 155 0000 90B5     		push	{r4, r7, lr}
 156              		.cfi_def_cfa_offset 12
 157              		.cfi_offset 4, -12
 158              		.cfi_offset 7, -8
 159              		.cfi_offset 14, -4
 160 0002 8DB0     		sub	sp, sp, #52
 161              		.cfi_def_cfa_offset 64
 162 0004 04AF     		add	r7, sp, #16
 163              		.cfi_def_cfa 7, 48
 164 0006 F860     		str	r0, [r7, #12]
 165 0008 B960     		str	r1, [r7, #8]
 166 000a 3B60     		str	r3, [r7]
 167 000c BB1D     		add	r3, r7, #6
 168 000e 1A80     		strh	r2, [r3]
 169              	.LBB2:
 683:../freertos/tasks.c **** 	TCB_t *pxNewTCB;
 684:../freertos/tasks.c **** 	BaseType_t xReturn;
 685:../freertos/tasks.c **** 
 686:../freertos/tasks.c **** 		/* If the stack grows down then allocate the stack then the TCB so the stack
 687:../freertos/tasks.c **** 		does not grow into the TCB.  Likewise if the stack grows up then allocate
 688:../freertos/tasks.c **** 		the TCB then the stack. */
 689:../freertos/tasks.c **** 		#if( portSTACK_GROWTH > 0 )
 690:../freertos/tasks.c **** 		{
 691:../freertos/tasks.c **** 			/* Allocate space for the TCB.  Where the memory comes from depends on
 692:../freertos/tasks.c **** 			the implementation of the port malloc function and whether or not static
 693:../freertos/tasks.c **** 			allocation is being used. */
 694:../freertos/tasks.c **** 			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
 695:../freertos/tasks.c **** 
 696:../freertos/tasks.c **** 			if( pxNewTCB != NULL )
 697:../freertos/tasks.c **** 			{
 698:../freertos/tasks.c **** 				/* Allocate space for the stack used by the task being created.
 699:../freertos/tasks.c **** 				The base of the stack memory stored in the TCB so the task can
 700:../freertos/tasks.c **** 				be deleted later if required. */
 701:../freertos/tasks.c **** 				pxNewTCB->pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( Sta
 702:../freertos/tasks.c **** 
 703:../freertos/tasks.c **** 				if( pxNewTCB->pxStack == NULL )
 704:../freertos/tasks.c **** 				{
 705:../freertos/tasks.c **** 					/* Could not allocate the stack.  Delete the allocated TCB. */
 706:../freertos/tasks.c **** 					vPortFree( pxNewTCB );
 707:../freertos/tasks.c **** 					pxNewTCB = NULL;
 708:../freertos/tasks.c **** 				}
 709:../freertos/tasks.c **** 			}
 710:../freertos/tasks.c **** 		}
 711:../freertos/tasks.c **** 		#else /* portSTACK_GROWTH */
 712:../freertos/tasks.c **** 		{
 713:../freertos/tasks.c **** 		StackType_t *pxStack;
 714:../freertos/tasks.c **** 
 715:../freertos/tasks.c **** 			/* Allocate space for the stack used by the task being created. */
 716:../freertos/tasks.c **** 			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) 
 170              		.loc 1 716 0
 171 0010 BB1D     		add	r3, r7, #6
 172 0012 1B88     		ldrh	r3, [r3]
 173 0014 9B00     		lsl	r3, r3, #2
 174 0016 181C     		mov	r0, r3
 175 0018 FFF7FEFF 		bl	pvPortMalloc
 176 001c 031C     		mov	r3, r0
 177 001e 7B61     		str	r3, [r7, #20]
 717:../freertos/tasks.c **** 
 718:../freertos/tasks.c **** 			if( pxStack != NULL )
 178              		.loc 1 718 0
 179 0020 7B69     		ldr	r3, [r7, #20]
 180 0022 002B     		cmp	r3, #0
 181 0024 10D0     		beq	.L2
 719:../freertos/tasks.c **** 			{
 720:../freertos/tasks.c **** 				/* Allocate space for the TCB. */
 721:../freertos/tasks.c **** 				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the cas
 182              		.loc 1 721 0
 183 0026 7420     		mov	r0, #116
 184 0028 FFF7FEFF 		bl	pvPortMalloc
 185 002c 031C     		mov	r3, r0
 186 002e FB61     		str	r3, [r7, #28]
 722:../freertos/tasks.c **** 
 723:../freertos/tasks.c **** 				if( pxNewTCB != NULL )
 187              		.loc 1 723 0
 188 0030 FB69     		ldr	r3, [r7, #28]
 189 0032 002B     		cmp	r3, #0
 190 0034 03D0     		beq	.L3
 724:../freertos/tasks.c **** 				{
 725:../freertos/tasks.c **** 					/* Store the stack location in the TCB. */
 726:../freertos/tasks.c **** 					pxNewTCB->pxStack = pxStack;
 191              		.loc 1 726 0
 192 0036 FB69     		ldr	r3, [r7, #28]
 193 0038 7A69     		ldr	r2, [r7, #20]
 194 003a 1A63     		str	r2, [r3, #48]
 195 003c 06E0     		b	.L5
 196              	.L3:
 727:../freertos/tasks.c **** 				}
 728:../freertos/tasks.c **** 				else
 729:../freertos/tasks.c **** 				{
 730:../freertos/tasks.c **** 					/* The stack cannot be used as the TCB was not created.  Free
 731:../freertos/tasks.c **** 					it again. */
 732:../freertos/tasks.c **** 					vPortFree( pxStack );
 197              		.loc 1 732 0
 198 003e 7B69     		ldr	r3, [r7, #20]
 199 0040 181C     		mov	r0, r3
 200 0042 FFF7FEFF 		bl	vPortFree
 201 0046 01E0     		b	.L5
 202              	.L2:
 733:../freertos/tasks.c **** 				}
 734:../freertos/tasks.c **** 			}
 735:../freertos/tasks.c **** 			else
 736:../freertos/tasks.c **** 			{
 737:../freertos/tasks.c **** 				pxNewTCB = NULL;
 203              		.loc 1 737 0
 204 0048 0023     		mov	r3, #0
 205 004a FB61     		str	r3, [r7, #28]
 206              	.L5:
 207              	.LBE2:
 738:../freertos/tasks.c **** 			}
 739:../freertos/tasks.c **** 		}
 740:../freertos/tasks.c **** 		#endif /* portSTACK_GROWTH */
 741:../freertos/tasks.c **** 
 742:../freertos/tasks.c **** 		if( pxNewTCB != NULL )
 208              		.loc 1 742 0
 209 004c FB69     		ldr	r3, [r7, #28]
 210 004e 002B     		cmp	r3, #0
 211 0050 15D0     		beq	.L6
 743:../freertos/tasks.c **** 		{
 744:../freertos/tasks.c **** 			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )
 745:../freertos/tasks.c **** 			{
 746:../freertos/tasks.c **** 				/* Tasks can be created statically or dynamically, so note this
 747:../freertos/tasks.c **** 				task was created dynamically in case it is later deleted. */
 748:../freertos/tasks.c **** 				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
 749:../freertos/tasks.c **** 			}
 750:../freertos/tasks.c **** 			#endif /* configSUPPORT_STATIC_ALLOCATION */
 751:../freertos/tasks.c **** 
 752:../freertos/tasks.c **** 			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, p
 212              		.loc 1 752 0
 213 0052 BB1D     		add	r3, r7, #6
 214 0054 1A88     		ldrh	r2, [r3]
 215 0056 F868     		ldr	r0, [r7, #12]
 216 0058 B968     		ldr	r1, [r7, #8]
 217 005a 3B68     		ldr	r3, [r7]
 218 005c 3C6B     		ldr	r4, [r7, #48]
 219 005e 0094     		str	r4, [sp]
 220 0060 7C6B     		ldr	r4, [r7, #52]
 221 0062 0194     		str	r4, [sp, #4]
 222 0064 FC69     		ldr	r4, [r7, #28]
 223 0066 0294     		str	r4, [sp, #8]
 224 0068 0024     		mov	r4, #0
 225 006a 0394     		str	r4, [sp, #12]
 226 006c FFF7FEFF 		bl	prvInitialiseNewTask
 753:../freertos/tasks.c **** 			prvAddNewTaskToReadyList( pxNewTCB );
 227              		.loc 1 753 0
 228 0070 FB69     		ldr	r3, [r7, #28]
 229 0072 181C     		mov	r0, r3
 230 0074 FFF7FEFF 		bl	prvAddNewTaskToReadyList
 754:../freertos/tasks.c **** 			xReturn = pdPASS;
 231              		.loc 1 754 0
 232 0078 0123     		mov	r3, #1
 233 007a BB61     		str	r3, [r7, #24]
 234 007c 02E0     		b	.L7
 235              	.L6:
 755:../freertos/tasks.c **** 		}
 756:../freertos/tasks.c **** 		else
 757:../freertos/tasks.c **** 		{
 758:../freertos/tasks.c **** 			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 236              		.loc 1 758 0
 237 007e 0123     		mov	r3, #1
 238 0080 5B42     		neg	r3, r3
 239 0082 BB61     		str	r3, [r7, #24]
 240              	.L7:
 759:../freertos/tasks.c **** 		}
 760:../freertos/tasks.c **** 
 761:../freertos/tasks.c **** 		return xReturn;
 241              		.loc 1 761 0
 242 0084 BB69     		ldr	r3, [r7, #24]
 762:../freertos/tasks.c **** 	}
 243              		.loc 1 762 0
 244 0086 181C     		mov	r0, r3
 245 0088 BD46     		mov	sp, r7
 246 008a 09B0     		add	sp, sp, #36
 247              		@ sp needed
 248 008c 90BD     		pop	{r4, r7, pc}
 249              		.cfi_endproc
 250              	.LFE0:
 252 008e C046     		.section	.text.prvInitialiseNewTask,"ax",%progbits
 253              		.align	2
 254              		.code	16
 255              		.thumb_func
 257              	prvInitialiseNewTask:
 258              	.LFB1:
 763:../freertos/tasks.c **** 
 764:../freertos/tasks.c **** #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
 765:../freertos/tasks.c **** /*-----------------------------------------------------------*/
 766:../freertos/tasks.c **** 
 767:../freertos/tasks.c **** static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
 768:../freertos/tasks.c **** 									const char * const pcName,
 769:../freertos/tasks.c **** 									const uint32_t ulStackDepth,
 770:../freertos/tasks.c **** 									void * const pvParameters,
 771:../freertos/tasks.c **** 									UBaseType_t uxPriority,
 772:../freertos/tasks.c **** 									TaskHandle_t * const pxCreatedTask,
 773:../freertos/tasks.c **** 									TCB_t *pxNewTCB,
 774:../freertos/tasks.c **** 									const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed fo
 775:../freertos/tasks.c **** {
 259              		.loc 1 775 0
 260              		.cfi_startproc
 261 0000 80B5     		push	{r7, lr}
 262              		.cfi_def_cfa_offset 8
 263              		.cfi_offset 7, -8
 264              		.cfi_offset 14, -4
 265 0002 86B0     		sub	sp, sp, #24
 266              		.cfi_def_cfa_offset 32
 267 0004 00AF     		add	r7, sp, #0
 268              		.cfi_def_cfa_register 7
 269 0006 F860     		str	r0, [r7, #12]
 270 0008 B960     		str	r1, [r7, #8]
 271 000a 7A60     		str	r2, [r7, #4]
 272 000c 3B60     		str	r3, [r7]
 776:../freertos/tasks.c **** StackType_t *pxTopOfStack;
 777:../freertos/tasks.c **** UBaseType_t x;
 778:../freertos/tasks.c **** 
 779:../freertos/tasks.c **** 	#if( portUSING_MPU_WRAPPERS == 1 )
 780:../freertos/tasks.c **** 		/* Should the task be created in privileged mode? */
 781:../freertos/tasks.c **** 		BaseType_t xRunPrivileged;
 782:../freertos/tasks.c **** 		if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
 783:../freertos/tasks.c **** 		{
 784:../freertos/tasks.c **** 			xRunPrivileged = pdTRUE;
 785:../freertos/tasks.c **** 		}
 786:../freertos/tasks.c **** 		else
 787:../freertos/tasks.c **** 		{
 788:../freertos/tasks.c **** 			xRunPrivileged = pdFALSE;
 789:../freertos/tasks.c **** 		}
 790:../freertos/tasks.c **** 		uxPriority &= ~portPRIVILEGE_BIT;
 791:../freertos/tasks.c **** 	#endif /* portUSING_MPU_WRAPPERS == 1 */
 792:../freertos/tasks.c **** 
 793:../freertos/tasks.c **** 	/* Avoid dependency on memset() if it is not required. */
 794:../freertos/tasks.c **** 	#if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTa
 795:../freertos/tasks.c **** 	{
 796:../freertos/tasks.c **** 		/* Fill the stack with a known value to assist debugging. */
 797:../freertos/tasks.c **** 		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof(
 273              		.loc 1 797 0
 274 000e BB6A     		ldr	r3, [r7, #40]
 275 0010 1A6B     		ldr	r2, [r3, #48]
 276 0012 7B68     		ldr	r3, [r7, #4]
 277 0014 9B00     		lsl	r3, r3, #2
 278 0016 101C     		mov	r0, r2
 279 0018 A521     		mov	r1, #165
 280 001a 1A1C     		mov	r2, r3
 281 001c FFF7FEFF 		bl	memset
 798:../freertos/tasks.c **** 	}
 799:../freertos/tasks.c **** 	#endif /* ( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( ( configUSE_TRACE_FACILITY == 1 ) || ( INC
 800:../freertos/tasks.c **** 
 801:../freertos/tasks.c **** 	/* Calculate the top of stack address.  This depends on whether the stack
 802:../freertos/tasks.c **** 	grows from high memory to low (as per the 80x86) or vice versa.
 803:../freertos/tasks.c **** 	portSTACK_GROWTH is used to make the result positive or negative as required
 804:../freertos/tasks.c **** 	by the port. */
 805:../freertos/tasks.c **** 	#if( portSTACK_GROWTH < 0 )
 806:../freertos/tasks.c **** 	{
 807:../freertos/tasks.c **** 		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 282              		.loc 1 807 0
 283 0020 BB6A     		ldr	r3, [r7, #40]
 284 0022 1A6B     		ldr	r2, [r3, #48]
 285 0024 7B68     		ldr	r3, [r7, #4]
 286 0026 3D49     		ldr	r1, .L20
 287 0028 5B18     		add	r3, r3, r1
 288 002a 9B00     		lsl	r3, r3, #2
 289 002c D318     		add	r3, r2, r3
 290 002e 3B61     		str	r3, [r7, #16]
 808:../freertos/tasks.c **** 		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTE
 291              		.loc 1 808 0
 292 0030 3B69     		ldr	r3, [r7, #16]
 293 0032 0722     		mov	r2, #7
 294 0034 9343     		bic	r3, r2
 295 0036 3B61     		str	r3, [r7, #16]
 809:../freertos/tasks.c **** 
 810:../freertos/tasks.c **** 		/* Check the alignment of the calculated top of stack is correct. */
 811:../freertos/tasks.c **** 		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALI
 296              		.loc 1 811 0
 297 0038 3A69     		ldr	r2, [r7, #16]
 298 003a 0723     		mov	r3, #7
 299 003c 1340     		and	r3, r2
 300 003e 01D0     		beq	.L10
 301              		.loc 1 811 0 is_stmt 0 discriminator 1
 302              	@ 811 "../freertos/tasks.c" 1
 303 0040 72B6     		 cpsid i 
 304              	@ 0 "" 2
 305              		.code	16
 306              	.L11:
 307 0042 FEE7     		b	.L11
 308              	.L10:
 812:../freertos/tasks.c **** 		#if( configRECORD_STACK_HIGH_ADDRESS == 1 )
 813:../freertos/tasks.c **** 		{
 814:../freertos/tasks.c **** 			/* Also record the stack's high address, which may assist
 815:../freertos/tasks.c **** 			debugging. */
 816:../freertos/tasks.c **** 			pxNewTCB->pxEndOfStack = pxTopOfStack;
 817:../freertos/tasks.c **** 		}
 818:../freertos/tasks.c **** 		#endif /* configRECORD_STACK_HIGH_ADDRESS */
 819:../freertos/tasks.c **** 	}
 820:../freertos/tasks.c **** 	#else /* portSTACK_GROWTH */
 821:../freertos/tasks.c **** 	{
 822:../freertos/tasks.c **** 		pxTopOfStack = pxNewTCB->pxStack;
 823:../freertos/tasks.c **** 
 824:../freertos/tasks.c **** 		/* Check the alignment of the stack buffer is correct. */
 825:../freertos/tasks.c **** 		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxNewTCB->pxStack & ( portPOINTER_SIZE_TYPE ) portBYT
 826:../freertos/tasks.c **** 
 827:../freertos/tasks.c **** 		/* The other extreme of the stack space is required if stack checking is
 828:../freertos/tasks.c **** 		performed. */
 829:../freertos/tasks.c **** 		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 830:../freertos/tasks.c **** 	}
 831:../freertos/tasks.c **** 	#endif /* portSTACK_GROWTH */
 832:../freertos/tasks.c **** 
 833:../freertos/tasks.c **** 	/* Store the task name in the TCB. */
 834:../freertos/tasks.c **** 	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 309              		.loc 1 834 0 is_stmt 1
 310 0044 0023     		mov	r3, #0
 311 0046 7B61     		str	r3, [r7, #20]
 312 0048 13E0     		b	.L12
 313              	.L15:
 835:../freertos/tasks.c **** 	{
 836:../freertos/tasks.c **** 		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 314              		.loc 1 836 0
 315 004a BA68     		ldr	r2, [r7, #8]
 316 004c 7B69     		ldr	r3, [r7, #20]
 317 004e D318     		add	r3, r2, r3
 318 0050 1A78     		ldrb	r2, [r3]
 319 0052 B86A     		ldr	r0, [r7, #40]
 320 0054 3023     		mov	r3, #48
 321 0056 7969     		ldr	r1, [r7, #20]
 322 0058 4118     		add	r1, r0, r1
 323 005a CB18     		add	r3, r1, r3
 324 005c 1A71     		strb	r2, [r3, #4]
 837:../freertos/tasks.c **** 
 838:../freertos/tasks.c **** 		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
 839:../freertos/tasks.c **** 		configMAX_TASK_NAME_LEN characters just in case the memory after the
 840:../freertos/tasks.c **** 		string is not accessible (extremely unlikely). */
 841:../freertos/tasks.c **** 		if( pcName[ x ] == 0x00 )
 325              		.loc 1 841 0
 326 005e BA68     		ldr	r2, [r7, #8]
 327 0060 7B69     		ldr	r3, [r7, #20]
 328 0062 D318     		add	r3, r2, r3
 329 0064 1B78     		ldrb	r3, [r3]
 330 0066 002B     		cmp	r3, #0
 331 0068 00D1     		bne	.L13
 842:../freertos/tasks.c **** 		{
 843:../freertos/tasks.c **** 			break;
 332              		.loc 1 843 0
 333 006a 05E0     		b	.L14
 334              	.L13:
 834:../freertos/tasks.c **** 	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 335              		.loc 1 834 0
 336 006c 7B69     		ldr	r3, [r7, #20]
 337 006e 0133     		add	r3, r3, #1
 338 0070 7B61     		str	r3, [r7, #20]
 339              	.L12:
 834:../freertos/tasks.c **** 	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 340              		.loc 1 834 0 is_stmt 0 discriminator 1
 341 0072 7B69     		ldr	r3, [r7, #20]
 342 0074 132B     		cmp	r3, #19
 343 0076 E8D9     		bls	.L15
 344              	.L14:
 844:../freertos/tasks.c **** 		}
 845:../freertos/tasks.c **** 		else
 846:../freertos/tasks.c **** 		{
 847:../freertos/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
 848:../freertos/tasks.c **** 		}
 849:../freertos/tasks.c **** 	}
 850:../freertos/tasks.c **** 
 851:../freertos/tasks.c **** 	/* Ensure the name string is terminated in the case that the string length
 852:../freertos/tasks.c **** 	was greater or equal to configMAX_TASK_NAME_LEN. */
 853:../freertos/tasks.c **** 	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 345              		.loc 1 853 0 is_stmt 1
 346 0078 BA6A     		ldr	r2, [r7, #40]
 347 007a 4723     		mov	r3, #71
 348 007c 0021     		mov	r1, #0
 349 007e D154     		strb	r1, [r2, r3]
 854:../freertos/tasks.c **** 
 855:../freertos/tasks.c **** 	/* This is used as an array index so must ensure it's not too large.  First
 856:../freertos/tasks.c **** 	remove the privilege bit if one is present. */
 857:../freertos/tasks.c **** 	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 350              		.loc 1 857 0
 351 0080 3B6A     		ldr	r3, [r7, #32]
 352 0082 042B     		cmp	r3, #4
 353 0084 01D9     		bls	.L16
 858:../freertos/tasks.c **** 	{
 859:../freertos/tasks.c **** 		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 354              		.loc 1 859 0
 355 0086 0423     		mov	r3, #4
 356 0088 3B62     		str	r3, [r7, #32]
 357              	.L16:
 860:../freertos/tasks.c **** 	}
 861:../freertos/tasks.c **** 	else
 862:../freertos/tasks.c **** 	{
 863:../freertos/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
 864:../freertos/tasks.c **** 	}
 865:../freertos/tasks.c **** 
 866:../freertos/tasks.c **** 	pxNewTCB->uxPriority = uxPriority;
 358              		.loc 1 866 0
 359 008a BB6A     		ldr	r3, [r7, #40]
 360 008c 3A6A     		ldr	r2, [r7, #32]
 361 008e DA62     		str	r2, [r3, #44]
 867:../freertos/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 868:../freertos/tasks.c **** 	{
 869:../freertos/tasks.c **** 		pxNewTCB->uxBasePriority = uxPriority;
 362              		.loc 1 869 0
 363 0090 BB6A     		ldr	r3, [r7, #40]
 364 0092 3A6A     		ldr	r2, [r7, #32]
 365 0094 1A65     		str	r2, [r3, #80]
 870:../freertos/tasks.c **** 		pxNewTCB->uxMutexesHeld = 0;
 366              		.loc 1 870 0
 367 0096 BB6A     		ldr	r3, [r7, #40]
 368 0098 0022     		mov	r2, #0
 369 009a 5A65     		str	r2, [r3, #84]
 871:../freertos/tasks.c **** 	}
 872:../freertos/tasks.c **** 	#endif /* configUSE_MUTEXES */
 873:../freertos/tasks.c **** 
 874:../freertos/tasks.c **** 	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 370              		.loc 1 874 0
 371 009c BB6A     		ldr	r3, [r7, #40]
 372 009e 0433     		add	r3, r3, #4
 373 00a0 181C     		mov	r0, r3
 374 00a2 FFF7FEFF 		bl	vListInitialiseItem
 875:../freertos/tasks.c **** 	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 375              		.loc 1 875 0
 376 00a6 BB6A     		ldr	r3, [r7, #40]
 377 00a8 1833     		add	r3, r3, #24
 378 00aa 181C     		mov	r0, r3
 379 00ac FFF7FEFF 		bl	vListInitialiseItem
 876:../freertos/tasks.c **** 
 877:../freertos/tasks.c **** 	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
 878:../freertos/tasks.c **** 	back to	the containing TCB from a generic item in a list. */
 879:../freertos/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 380              		.loc 1 879 0
 381 00b0 BB6A     		ldr	r3, [r7, #40]
 382 00b2 BA6A     		ldr	r2, [r7, #40]
 383 00b4 1A61     		str	r2, [r3, #16]
 880:../freertos/tasks.c **** 
 881:../freertos/tasks.c **** 	/* Event lists are always in priority order. */
 882:../freertos/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( Ti
 384              		.loc 1 882 0
 385 00b6 3B6A     		ldr	r3, [r7, #32]
 386 00b8 0522     		mov	r2, #5
 387 00ba D21A     		sub	r2, r2, r3
 388 00bc BB6A     		ldr	r3, [r7, #40]
 389 00be 9A61     		str	r2, [r3, #24]
 883:../freertos/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 390              		.loc 1 883 0
 391 00c0 BB6A     		ldr	r3, [r7, #40]
 392 00c2 BA6A     		ldr	r2, [r7, #40]
 393 00c4 5A62     		str	r2, [r3, #36]
 884:../freertos/tasks.c **** 
 885:../freertos/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
 886:../freertos/tasks.c **** 	{
 887:../freertos/tasks.c **** 		pxNewTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
 888:../freertos/tasks.c **** 	}
 889:../freertos/tasks.c **** 	#endif /* portCRITICAL_NESTING_IN_TCB */
 890:../freertos/tasks.c **** 
 891:../freertos/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
 892:../freertos/tasks.c **** 	{
 893:../freertos/tasks.c **** 		pxNewTCB->pxTaskTag = NULL;
 894:../freertos/tasks.c **** 	}
 895:../freertos/tasks.c **** 	#endif /* configUSE_APPLICATION_TASK_TAG */
 896:../freertos/tasks.c **** 
 897:../freertos/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
 898:../freertos/tasks.c **** 	{
 899:../freertos/tasks.c **** 		pxNewTCB->ulRunTimeCounter = 0UL;
 900:../freertos/tasks.c **** 	}
 901:../freertos/tasks.c **** 	#endif /* configGENERATE_RUN_TIME_STATS */
 902:../freertos/tasks.c **** 
 903:../freertos/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
 904:../freertos/tasks.c **** 	{
 905:../freertos/tasks.c **** 		vPortStoreTaskMPUSettings( &( pxNewTCB->xMPUSettings ), xRegions, pxNewTCB->pxStack, ulStackDepth
 906:../freertos/tasks.c **** 	}
 907:../freertos/tasks.c **** 	#else
 908:../freertos/tasks.c **** 	{
 909:../freertos/tasks.c **** 		/* Avoid compiler warning about unreferenced parameter. */
 910:../freertos/tasks.c **** 		( void ) xRegions;
 911:../freertos/tasks.c **** 	}
 912:../freertos/tasks.c **** 	#endif
 913:../freertos/tasks.c **** 
 914:../freertos/tasks.c **** 	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
 915:../freertos/tasks.c **** 	{
 916:../freertos/tasks.c **** 		for( x = 0; x < ( UBaseType_t ) configNUM_THREAD_LOCAL_STORAGE_POINTERS; x++ )
 394              		.loc 1 916 0
 395 00c6 0023     		mov	r3, #0
 396 00c8 7B61     		str	r3, [r7, #20]
 397 00ca 08E0     		b	.L17
 398              	.L18:
 917:../freertos/tasks.c **** 		{
 918:../freertos/tasks.c **** 			pxNewTCB->pvThreadLocalStoragePointers[ x ] = NULL;
 399              		.loc 1 918 0 discriminator 2
 400 00cc BB6A     		ldr	r3, [r7, #40]
 401 00ce 7A69     		ldr	r2, [r7, #20]
 402 00d0 1632     		add	r2, r2, #22
 403 00d2 9200     		lsl	r2, r2, #2
 404 00d4 0021     		mov	r1, #0
 405 00d6 D150     		str	r1, [r2, r3]
 916:../freertos/tasks.c **** 		for( x = 0; x < ( UBaseType_t ) configNUM_THREAD_LOCAL_STORAGE_POINTERS; x++ )
 406              		.loc 1 916 0 discriminator 2
 407 00d8 7B69     		ldr	r3, [r7, #20]
 408 00da 0133     		add	r3, r3, #1
 409 00dc 7B61     		str	r3, [r7, #20]
 410              	.L17:
 916:../freertos/tasks.c **** 		for( x = 0; x < ( UBaseType_t ) configNUM_THREAD_LOCAL_STORAGE_POINTERS; x++ )
 411              		.loc 1 916 0 is_stmt 0 discriminator 1
 412 00de 7B69     		ldr	r3, [r7, #20]
 413 00e0 042B     		cmp	r3, #4
 414 00e2 F3D9     		bls	.L18
 919:../freertos/tasks.c **** 		}
 920:../freertos/tasks.c **** 	}
 921:../freertos/tasks.c **** 	#endif
 922:../freertos/tasks.c **** 
 923:../freertos/tasks.c **** 	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
 924:../freertos/tasks.c **** 	{
 925:../freertos/tasks.c **** 		pxNewTCB->ulNotifiedValue = 0;
 415              		.loc 1 925 0 is_stmt 1
 416 00e4 BB6A     		ldr	r3, [r7, #40]
 417 00e6 0022     		mov	r2, #0
 418 00e8 DA66     		str	r2, [r3, #108]
 926:../freertos/tasks.c **** 		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 419              		.loc 1 926 0
 420 00ea BA6A     		ldr	r2, [r7, #40]
 421 00ec 7023     		mov	r3, #112
 422 00ee 0021     		mov	r1, #0
 423 00f0 D154     		strb	r1, [r2, r3]
 927:../freertos/tasks.c **** 	}
 928:../freertos/tasks.c **** 	#endif
 929:../freertos/tasks.c **** 
 930:../freertos/tasks.c **** 	#if ( configUSE_NEWLIB_REENTRANT == 1 )
 931:../freertos/tasks.c **** 	{
 932:../freertos/tasks.c **** 		/* Initialise this task's Newlib reent structure. */
 933:../freertos/tasks.c **** 		_REENT_INIT_PTR( ( &( pxNewTCB->xNewLib_reent ) ) );
 934:../freertos/tasks.c **** 	}
 935:../freertos/tasks.c **** 	#endif
 936:../freertos/tasks.c **** 
 937:../freertos/tasks.c **** 	#if( INCLUDE_xTaskAbortDelay == 1 )
 938:../freertos/tasks.c **** 	{
 939:../freertos/tasks.c **** 		pxNewTCB->ucDelayAborted = pdFALSE;
 940:../freertos/tasks.c **** 	}
 941:../freertos/tasks.c **** 	#endif
 942:../freertos/tasks.c **** 
 943:../freertos/tasks.c **** 	/* Initialize the TCB stack to look as if the task was already running,
 944:../freertos/tasks.c **** 	but had been interrupted by the scheduler.  The return address is set
 945:../freertos/tasks.c **** 	to the start of the task function. Once the stack has been initialised
 946:../freertos/tasks.c **** 	the	top of stack variable is updated. */
 947:../freertos/tasks.c **** 	#if( portUSING_MPU_WRAPPERS == 1 )
 948:../freertos/tasks.c **** 	{
 949:../freertos/tasks.c **** 		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivi
 950:../freertos/tasks.c **** 	}
 951:../freertos/tasks.c **** 	#else /* portUSING_MPU_WRAPPERS */
 952:../freertos/tasks.c **** 	{
 953:../freertos/tasks.c **** 		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 424              		.loc 1 953 0
 425 00f2 3969     		ldr	r1, [r7, #16]
 426 00f4 FA68     		ldr	r2, [r7, #12]
 427 00f6 3B68     		ldr	r3, [r7]
 428 00f8 081C     		mov	r0, r1
 429 00fa 111C     		mov	r1, r2
 430 00fc 1A1C     		mov	r2, r3
 431 00fe FFF7FEFF 		bl	pxPortInitialiseStack
 432 0102 021C     		mov	r2, r0
 433 0104 BB6A     		ldr	r3, [r7, #40]
 434 0106 1A60     		str	r2, [r3]
 954:../freertos/tasks.c **** 	}
 955:../freertos/tasks.c **** 	#endif /* portUSING_MPU_WRAPPERS */
 956:../freertos/tasks.c **** 
 957:../freertos/tasks.c **** 	if( ( void * ) pxCreatedTask != NULL )
 435              		.loc 1 957 0
 436 0108 7B6A     		ldr	r3, [r7, #36]
 437 010a 002B     		cmp	r3, #0
 438 010c 02D0     		beq	.L9
 958:../freertos/tasks.c **** 	{
 959:../freertos/tasks.c **** 		/* Pass the handle out in an anonymous way.  The handle can be used to
 960:../freertos/tasks.c **** 		change the created task's priority, delete the created task, etc.*/
 961:../freertos/tasks.c **** 		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 439              		.loc 1 961 0
 440 010e 7B6A     		ldr	r3, [r7, #36]
 441 0110 BA6A     		ldr	r2, [r7, #40]
 442 0112 1A60     		str	r2, [r3]
 443              	.L9:
 962:../freertos/tasks.c **** 	}
 963:../freertos/tasks.c **** 	else
 964:../freertos/tasks.c **** 	{
 965:../freertos/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
 966:../freertos/tasks.c **** 	}
 967:../freertos/tasks.c **** }
 444              		.loc 1 967 0
 445 0114 BD46     		mov	sp, r7
 446 0116 06B0     		add	sp, sp, #24
 447              		@ sp needed
 448 0118 80BD     		pop	{r7, pc}
 449              	.L21:
 450 011a C046     		.align	2
 451              	.L20:
 452 011c FFFFFF3F 		.word	1073741823
 453              		.cfi_endproc
 454              	.LFE1:
 456              		.section	.text.prvAddNewTaskToReadyList,"ax",%progbits
 457              		.align	2
 458              		.code	16
 459              		.thumb_func
 461              	prvAddNewTaskToReadyList:
 462              	.LFB2:
 968:../freertos/tasks.c **** /*-----------------------------------------------------------*/
 969:../freertos/tasks.c **** 
 970:../freertos/tasks.c **** static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
 971:../freertos/tasks.c **** {
 463              		.loc 1 971 0
 464              		.cfi_startproc
 465 0000 80B5     		push	{r7, lr}
 466              		.cfi_def_cfa_offset 8
 467              		.cfi_offset 7, -8
 468              		.cfi_offset 14, -4
 469 0002 82B0     		sub	sp, sp, #8
 470              		.cfi_def_cfa_offset 16
 471 0004 00AF     		add	r7, sp, #0
 472              		.cfi_def_cfa_register 7
 473 0006 7860     		str	r0, [r7, #4]
 972:../freertos/tasks.c **** 	/* Ensure interrupts don't access the task lists while the lists are being
 973:../freertos/tasks.c **** 	updated. */
 974:../freertos/tasks.c **** 	taskENTER_CRITICAL();
 474              		.loc 1 974 0
 475 0008 FFF7FEFF 		bl	vPortEnterCritical
 975:../freertos/tasks.c **** 	{
 976:../freertos/tasks.c **** 		uxCurrentNumberOfTasks++;
 476              		.loc 1 976 0
 477 000c 294B     		ldr	r3, .L27
 478 000e 1B68     		ldr	r3, [r3]
 479 0010 5A1C     		add	r2, r3, #1
 480 0012 284B     		ldr	r3, .L27
 481 0014 1A60     		str	r2, [r3]
 977:../freertos/tasks.c **** 		if( pxCurrentTCB == NULL )
 482              		.loc 1 977 0
 483 0016 284B     		ldr	r3, .L27+4
 484 0018 1B68     		ldr	r3, [r3]
 485 001a 002B     		cmp	r3, #0
 486 001c 09D1     		bne	.L23
 978:../freertos/tasks.c **** 		{
 979:../freertos/tasks.c **** 			/* There are no other tasks, or all the other tasks are in
 980:../freertos/tasks.c **** 			the suspended state - make this the current task. */
 981:../freertos/tasks.c **** 			pxCurrentTCB = pxNewTCB;
 487              		.loc 1 981 0
 488 001e 264B     		ldr	r3, .L27+4
 489 0020 7A68     		ldr	r2, [r7, #4]
 490 0022 1A60     		str	r2, [r3]
 982:../freertos/tasks.c **** 
 983:../freertos/tasks.c **** 			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 491              		.loc 1 983 0
 492 0024 234B     		ldr	r3, .L27
 493 0026 1B68     		ldr	r3, [r3]
 494 0028 012B     		cmp	r3, #1
 495 002a 10D1     		bne	.L24
 984:../freertos/tasks.c **** 			{
 985:../freertos/tasks.c **** 				/* This is the first task to be created so do the preliminary
 986:../freertos/tasks.c **** 				initialisation required.  We will not recover if this call
 987:../freertos/tasks.c **** 				fails, but we will report the failure. */
 988:../freertos/tasks.c **** 				prvInitialiseTaskLists();
 496              		.loc 1 988 0
 497 002c FFF7FEFF 		bl	prvInitialiseTaskLists
 498 0030 0DE0     		b	.L24
 499              	.L23:
 989:../freertos/tasks.c **** 			}
 990:../freertos/tasks.c **** 			else
 991:../freertos/tasks.c **** 			{
 992:../freertos/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
 993:../freertos/tasks.c **** 			}
 994:../freertos/tasks.c **** 		}
 995:../freertos/tasks.c **** 		else
 996:../freertos/tasks.c **** 		{
 997:../freertos/tasks.c **** 			/* If the scheduler is not already running, make this task the
 998:../freertos/tasks.c **** 			current task if it is the highest priority task to be created
 999:../freertos/tasks.c **** 			so far. */
1000:../freertos/tasks.c **** 			if( xSchedulerRunning == pdFALSE )
 500              		.loc 1 1000 0
 501 0032 224B     		ldr	r3, .L27+8
 502 0034 1B68     		ldr	r3, [r3]
 503 0036 002B     		cmp	r3, #0
 504 0038 09D1     		bne	.L24
1001:../freertos/tasks.c **** 			{
1002:../freertos/tasks.c **** 				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 505              		.loc 1 1002 0
 506 003a 1F4B     		ldr	r3, .L27+4
 507 003c 1B68     		ldr	r3, [r3]
 508 003e DA6A     		ldr	r2, [r3, #44]
 509 0040 7B68     		ldr	r3, [r7, #4]
 510 0042 DB6A     		ldr	r3, [r3, #44]
 511 0044 9A42     		cmp	r2, r3
 512 0046 02D8     		bhi	.L24
1003:../freertos/tasks.c **** 				{
1004:../freertos/tasks.c **** 					pxCurrentTCB = pxNewTCB;
 513              		.loc 1 1004 0
 514 0048 1B4B     		ldr	r3, .L27+4
 515 004a 7A68     		ldr	r2, [r7, #4]
 516 004c 1A60     		str	r2, [r3]
 517              	.L24:
1005:../freertos/tasks.c **** 				}
1006:../freertos/tasks.c **** 				else
1007:../freertos/tasks.c **** 				{
1008:../freertos/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1009:../freertos/tasks.c **** 				}
1010:../freertos/tasks.c **** 			}
1011:../freertos/tasks.c **** 			else
1012:../freertos/tasks.c **** 			{
1013:../freertos/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1014:../freertos/tasks.c **** 			}
1015:../freertos/tasks.c **** 		}
1016:../freertos/tasks.c **** 
1017:../freertos/tasks.c **** 		uxTaskNumber++;
 518              		.loc 1 1017 0
 519 004e 1C4B     		ldr	r3, .L27+12
 520 0050 1B68     		ldr	r3, [r3]
 521 0052 5A1C     		add	r2, r3, #1
 522 0054 1A4B     		ldr	r3, .L27+12
 523 0056 1A60     		str	r2, [r3]
1018:../freertos/tasks.c **** 
1019:../freertos/tasks.c **** 		#if ( configUSE_TRACE_FACILITY == 1 )
1020:../freertos/tasks.c **** 		{
1021:../freertos/tasks.c **** 			/* Add a counter into the TCB for tracing only. */
1022:../freertos/tasks.c **** 			pxNewTCB->uxTCBNumber = uxTaskNumber;
 524              		.loc 1 1022 0
 525 0058 194B     		ldr	r3, .L27+12
 526 005a 1A68     		ldr	r2, [r3]
 527 005c 7B68     		ldr	r3, [r7, #4]
 528 005e 9A64     		str	r2, [r3, #72]
1023:../freertos/tasks.c **** 		}
1024:../freertos/tasks.c **** 		#endif /* configUSE_TRACE_FACILITY */
1025:../freertos/tasks.c **** 		traceTASK_CREATE( pxNewTCB );
1026:../freertos/tasks.c **** 
1027:../freertos/tasks.c **** 		prvAddTaskToReadyList( pxNewTCB );
 529              		.loc 1 1027 0
 530 0060 7B68     		ldr	r3, [r7, #4]
 531 0062 DA6A     		ldr	r2, [r3, #44]
 532 0064 174B     		ldr	r3, .L27+16
 533 0066 1B68     		ldr	r3, [r3]
 534 0068 9A42     		cmp	r2, r3
 535 006a 03D9     		bls	.L25
 536              		.loc 1 1027 0 is_stmt 0 discriminator 1
 537 006c 7B68     		ldr	r3, [r7, #4]
 538 006e DA6A     		ldr	r2, [r3, #44]
 539 0070 144B     		ldr	r3, .L27+16
 540 0072 1A60     		str	r2, [r3]
 541              	.L25:
 542              		.loc 1 1027 0 discriminator 2
 543 0074 7B68     		ldr	r3, [r7, #4]
 544 0076 DA6A     		ldr	r2, [r3, #44]
 545 0078 131C     		mov	r3, r2
 546 007a 9B00     		lsl	r3, r3, #2
 547 007c 9B18     		add	r3, r3, r2
 548 007e 9B00     		lsl	r3, r3, #2
 549 0080 114A     		ldr	r2, .L27+20
 550 0082 9A18     		add	r2, r3, r2
 551 0084 7B68     		ldr	r3, [r7, #4]
 552 0086 0433     		add	r3, r3, #4
 553 0088 101C     		mov	r0, r2
 554 008a 191C     		mov	r1, r3
 555 008c FFF7FEFF 		bl	vListInsertEnd
1028:../freertos/tasks.c **** 
1029:../freertos/tasks.c **** 		portSETUP_TCB( pxNewTCB );
1030:../freertos/tasks.c **** 	}
1031:../freertos/tasks.c **** 	taskEXIT_CRITICAL();
 556              		.loc 1 1031 0 is_stmt 1 discriminator 2
 557 0090 FFF7FEFF 		bl	vPortExitCritical
1032:../freertos/tasks.c **** 
1033:../freertos/tasks.c **** 	if( xSchedulerRunning != pdFALSE )
 558              		.loc 1 1033 0 discriminator 2
 559 0094 094B     		ldr	r3, .L27+8
 560 0096 1B68     		ldr	r3, [r3]
 561 0098 002B     		cmp	r3, #0
 562 009a 08D0     		beq	.L22
1034:../freertos/tasks.c **** 	{
1035:../freertos/tasks.c **** 		/* If the created task is of a higher priority than the current task
1036:../freertos/tasks.c **** 		then it should run now. */
1037:../freertos/tasks.c **** 		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 563              		.loc 1 1037 0
 564 009c 064B     		ldr	r3, .L27+4
 565 009e 1B68     		ldr	r3, [r3]
 566 00a0 DA6A     		ldr	r2, [r3, #44]
 567 00a2 7B68     		ldr	r3, [r7, #4]
 568 00a4 DB6A     		ldr	r3, [r3, #44]
 569 00a6 9A42     		cmp	r2, r3
 570 00a8 01D2     		bcs	.L22
1038:../freertos/tasks.c **** 		{
1039:../freertos/tasks.c **** 			taskYIELD_IF_USING_PREEMPTION();
 571              		.loc 1 1039 0
 572 00aa FFF7FEFF 		bl	vPortYield
 573              	.L22:
1040:../freertos/tasks.c **** 		}
1041:../freertos/tasks.c **** 		else
1042:../freertos/tasks.c **** 		{
1043:../freertos/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1044:../freertos/tasks.c **** 		}
1045:../freertos/tasks.c **** 	}
1046:../freertos/tasks.c **** 	else
1047:../freertos/tasks.c **** 	{
1048:../freertos/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
1049:../freertos/tasks.c **** 	}
1050:../freertos/tasks.c **** }
 574              		.loc 1 1050 0
 575 00ae BD46     		mov	sp, r7
 576 00b0 02B0     		add	sp, sp, #8
 577              		@ sp needed
 578 00b2 80BD     		pop	{r7, pc}
 579              	.L28:
 580              		.align	2
 581              	.L27:
 582 00b4 00000000 		.word	uxCurrentNumberOfTasks
 583 00b8 00000000 		.word	pxCurrentTCB
 584 00bc 00000000 		.word	xSchedulerRunning
 585 00c0 00000000 		.word	uxTaskNumber
 586 00c4 00000000 		.word	uxTopReadyPriority
 587 00c8 00000000 		.word	pxReadyTasksLists
 588              		.cfi_endproc
 589              	.LFE2:
 591              		.section	.text.vTaskDelete,"ax",%progbits
 592              		.align	2
 593              		.global	vTaskDelete
 594              		.code	16
 595              		.thumb_func
 597              	vTaskDelete:
 598              	.LFB3:
1051:../freertos/tasks.c **** /*-----------------------------------------------------------*/
1052:../freertos/tasks.c **** 
1053:../freertos/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
1054:../freertos/tasks.c **** 
1055:../freertos/tasks.c **** 	void vTaskDelete( TaskHandle_t xTaskToDelete )
1056:../freertos/tasks.c **** 	{
 599              		.loc 1 1056 0
 600              		.cfi_startproc
 601 0000 80B5     		push	{r7, lr}
 602              		.cfi_def_cfa_offset 8
 603              		.cfi_offset 7, -8
 604              		.cfi_offset 14, -4
 605 0002 84B0     		sub	sp, sp, #16
 606              		.cfi_def_cfa_offset 24
 607 0004 00AF     		add	r7, sp, #0
 608              		.cfi_def_cfa_register 7
 609 0006 7860     		str	r0, [r7, #4]
1057:../freertos/tasks.c **** 	TCB_t *pxTCB;
1058:../freertos/tasks.c **** 
1059:../freertos/tasks.c **** 		taskENTER_CRITICAL();
 610              		.loc 1 1059 0
 611 0008 FFF7FEFF 		bl	vPortEnterCritical
1060:../freertos/tasks.c **** 		{
1061:../freertos/tasks.c **** 			/* If null is passed in here then it is the calling task that is
1062:../freertos/tasks.c **** 			being deleted. */
1063:../freertos/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 612              		.loc 1 1063 0
 613 000c 7B68     		ldr	r3, [r7, #4]
 614 000e 002B     		cmp	r3, #0
 615 0010 02D1     		bne	.L30
 616              		.loc 1 1063 0 is_stmt 0 discriminator 1
 617 0012 254B     		ldr	r3, .L38
 618 0014 1B68     		ldr	r3, [r3]
 619 0016 00E0     		b	.L31
 620              	.L30:
 621              		.loc 1 1063 0 discriminator 2
 622 0018 7B68     		ldr	r3, [r7, #4]
 623              	.L31:
 624              		.loc 1 1063 0 discriminator 3
 625 001a FB60     		str	r3, [r7, #12]
1064:../freertos/tasks.c **** 
1065:../freertos/tasks.c **** 			/* Remove task from the ready list. */
1066:../freertos/tasks.c **** 			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 626              		.loc 1 1066 0 is_stmt 1 discriminator 3
 627 001c FB68     		ldr	r3, [r7, #12]
 628 001e 0433     		add	r3, r3, #4
 629 0020 181C     		mov	r0, r3
 630 0022 FFF7FEFF 		bl	uxListRemove
1067:../freertos/tasks.c **** 			{
1068:../freertos/tasks.c **** 				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
1069:../freertos/tasks.c **** 			}
1070:../freertos/tasks.c **** 			else
1071:../freertos/tasks.c **** 			{
1072:../freertos/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1073:../freertos/tasks.c **** 			}
1074:../freertos/tasks.c **** 
1075:../freertos/tasks.c **** 			/* Is the task waiting on an event also? */
1076:../freertos/tasks.c **** 			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 631              		.loc 1 1076 0 discriminator 3
 632 0026 FB68     		ldr	r3, [r7, #12]
 633 0028 9B6A     		ldr	r3, [r3, #40]
 634 002a 002B     		cmp	r3, #0
 635 002c 04D0     		beq	.L32
1077:../freertos/tasks.c **** 			{
1078:../freertos/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 636              		.loc 1 1078 0
 637 002e FB68     		ldr	r3, [r7, #12]
 638 0030 1833     		add	r3, r3, #24
 639 0032 181C     		mov	r0, r3
 640 0034 FFF7FEFF 		bl	uxListRemove
 641              	.L32:
1079:../freertos/tasks.c **** 			}
1080:../freertos/tasks.c **** 			else
1081:../freertos/tasks.c **** 			{
1082:../freertos/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1083:../freertos/tasks.c **** 			}
1084:../freertos/tasks.c **** 
1085:../freertos/tasks.c **** 			/* Increment the uxTaskNumber also so kernel aware debuggers can
1086:../freertos/tasks.c **** 			detect that the task lists need re-generating.  This is done before
1087:../freertos/tasks.c **** 			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
1088:../freertos/tasks.c **** 			not return. */
1089:../freertos/tasks.c **** 			uxTaskNumber++;
 642              		.loc 1 1089 0
 643 0038 1C4B     		ldr	r3, .L38+4
 644 003a 1B68     		ldr	r3, [r3]
 645 003c 5A1C     		add	r2, r3, #1
 646 003e 1B4B     		ldr	r3, .L38+4
 647 0040 1A60     		str	r2, [r3]
1090:../freertos/tasks.c **** 
1091:../freertos/tasks.c **** 			if( pxTCB == pxCurrentTCB )
 648              		.loc 1 1091 0
 649 0042 194B     		ldr	r3, .L38
 650 0044 1B68     		ldr	r3, [r3]
 651 0046 FA68     		ldr	r2, [r7, #12]
 652 0048 9A42     		cmp	r2, r3
 653 004a 0CD1     		bne	.L33
1092:../freertos/tasks.c **** 			{
1093:../freertos/tasks.c **** 				/* A task is deleting itself.  This cannot complete within the
1094:../freertos/tasks.c **** 				task itself, as a context switch to another task is required.
1095:../freertos/tasks.c **** 				Place the task in the termination list.  The idle task will
1096:../freertos/tasks.c **** 				check the termination list and free up any memory allocated by
1097:../freertos/tasks.c **** 				the scheduler for the TCB and stack of the deleted task. */
1098:../freertos/tasks.c **** 				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
 654              		.loc 1 1098 0
 655 004c FB68     		ldr	r3, [r7, #12]
 656 004e 0433     		add	r3, r3, #4
 657 0050 174A     		ldr	r2, .L38+8
 658 0052 101C     		mov	r0, r2
 659 0054 191C     		mov	r1, r3
 660 0056 FFF7FEFF 		bl	vListInsertEnd
1099:../freertos/tasks.c **** 
1100:../freertos/tasks.c **** 				/* Increment the ucTasksDeleted variable so the idle task knows
1101:../freertos/tasks.c **** 				there is a task that has been deleted and that it should therefore
1102:../freertos/tasks.c **** 				check the xTasksWaitingTermination list. */
1103:../freertos/tasks.c **** 				++uxDeletedTasksWaitingCleanUp;
 661              		.loc 1 1103 0
 662 005a 164B     		ldr	r3, .L38+12
 663 005c 1B68     		ldr	r3, [r3]
 664 005e 5A1C     		add	r2, r3, #1
 665 0060 144B     		ldr	r3, .L38+12
 666 0062 1A60     		str	r2, [r3]
 667 0064 0AE0     		b	.L34
 668              	.L33:
1104:../freertos/tasks.c **** 
1105:../freertos/tasks.c **** 				/* The pre-delete hook is primarily for the Windows simulator,
1106:../freertos/tasks.c **** 				in which Windows specific clean up operations are performed,
1107:../freertos/tasks.c **** 				after which it is not possible to yield away from this task -
1108:../freertos/tasks.c **** 				hence xYieldPending is used to latch that a context switch is
1109:../freertos/tasks.c **** 				required. */
1110:../freertos/tasks.c **** 				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
1111:../freertos/tasks.c **** 			}
1112:../freertos/tasks.c **** 			else
1113:../freertos/tasks.c **** 			{
1114:../freertos/tasks.c **** 				--uxCurrentNumberOfTasks;
 669              		.loc 1 1114 0
 670 0066 144B     		ldr	r3, .L38+16
 671 0068 1B68     		ldr	r3, [r3]
 672 006a 5A1E     		sub	r2, r3, #1
 673 006c 124B     		ldr	r3, .L38+16
 674 006e 1A60     		str	r2, [r3]
1115:../freertos/tasks.c **** 				prvDeleteTCB( pxTCB );
 675              		.loc 1 1115 0
 676 0070 FB68     		ldr	r3, [r7, #12]
 677 0072 181C     		mov	r0, r3
 678 0074 FFF7FEFF 		bl	prvDeleteTCB
1116:../freertos/tasks.c **** 
1117:../freertos/tasks.c **** 				/* Reset the next expected unblock time in case it referred to
1118:../freertos/tasks.c **** 				the task that has just been deleted. */
1119:../freertos/tasks.c **** 				prvResetNextTaskUnblockTime();
 679              		.loc 1 1119 0
 680 0078 FFF7FEFF 		bl	prvResetNextTaskUnblockTime
 681              	.L34:
1120:../freertos/tasks.c **** 			}
1121:../freertos/tasks.c **** 
1122:../freertos/tasks.c **** 			traceTASK_DELETE( pxTCB );
1123:../freertos/tasks.c **** 		}
1124:../freertos/tasks.c **** 		taskEXIT_CRITICAL();
 682              		.loc 1 1124 0
 683 007c FFF7FEFF 		bl	vPortExitCritical
1125:../freertos/tasks.c **** 
1126:../freertos/tasks.c **** 		/* Force a reschedule if it is the currently running task that has just
1127:../freertos/tasks.c **** 		been deleted. */
1128:../freertos/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 684              		.loc 1 1128 0
 685 0080 0E4B     		ldr	r3, .L38+20
 686 0082 1B68     		ldr	r3, [r3]
 687 0084 002B     		cmp	r3, #0
 688 0086 0CD0     		beq	.L29
1129:../freertos/tasks.c **** 		{
1130:../freertos/tasks.c **** 			if( pxTCB == pxCurrentTCB )
 689              		.loc 1 1130 0
 690 0088 074B     		ldr	r3, .L38
 691 008a 1B68     		ldr	r3, [r3]
 692 008c FA68     		ldr	r2, [r7, #12]
 693 008e 9A42     		cmp	r2, r3
 694 0090 07D1     		bne	.L29
1131:../freertos/tasks.c **** 			{
1132:../freertos/tasks.c **** 				configASSERT( uxSchedulerSuspended == 0 );
 695              		.loc 1 1132 0
 696 0092 0B4B     		ldr	r3, .L38+24
 697 0094 1B68     		ldr	r3, [r3]
 698 0096 002B     		cmp	r3, #0
 699 0098 01D0     		beq	.L36
 700              		.loc 1 1132 0 is_stmt 0 discriminator 1
 701              	@ 1132 "../freertos/tasks.c" 1
 702 009a 72B6     		 cpsid i 
 703              	@ 0 "" 2
 704              		.code	16
 705              	.L37:
 706 009c FEE7     		b	.L37
 707              	.L36:
1133:../freertos/tasks.c **** 				portYIELD_WITHIN_API();
 708              		.loc 1 1133 0 is_stmt 1
 709 009e FFF7FEFF 		bl	vPortYield
 710              	.L29:
1134:../freertos/tasks.c **** 			}
1135:../freertos/tasks.c **** 			else
1136:../freertos/tasks.c **** 			{
1137:../freertos/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1138:../freertos/tasks.c **** 			}
1139:../freertos/tasks.c **** 		}
1140:../freertos/tasks.c **** 	}
 711              		.loc 1 1140 0
 712 00a2 BD46     		mov	sp, r7
 713 00a4 04B0     		add	sp, sp, #16
 714              		@ sp needed
 715 00a6 80BD     		pop	{r7, pc}
 716              	.L39:
 717              		.align	2
 718              	.L38:
 719 00a8 00000000 		.word	pxCurrentTCB
 720 00ac 00000000 		.word	uxTaskNumber
 721 00b0 00000000 		.word	xTasksWaitingTermination
 722 00b4 00000000 		.word	uxDeletedTasksWaitingCleanUp
 723 00b8 00000000 		.word	uxCurrentNumberOfTasks
 724 00bc 00000000 		.word	xSchedulerRunning
 725 00c0 00000000 		.word	uxSchedulerSuspended
 726              		.cfi_endproc
 727              	.LFE3:
 729              		.section	.text.vTaskDelayUntil,"ax",%progbits
 730              		.align	2
 731              		.global	vTaskDelayUntil
 732              		.code	16
 733              		.thumb_func
 735              	vTaskDelayUntil:
 736              	.LFB4:
1141:../freertos/tasks.c **** 
1142:../freertos/tasks.c **** #endif /* INCLUDE_vTaskDelete */
1143:../freertos/tasks.c **** /*-----------------------------------------------------------*/
1144:../freertos/tasks.c **** 
1145:../freertos/tasks.c **** #if ( INCLUDE_vTaskDelayUntil == 1 )
1146:../freertos/tasks.c **** 
1147:../freertos/tasks.c **** 	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
1148:../freertos/tasks.c **** 	{
 737              		.loc 1 1148 0
 738              		.cfi_startproc
 739 0000 80B5     		push	{r7, lr}
 740              		.cfi_def_cfa_offset 8
 741              		.cfi_offset 7, -8
 742              		.cfi_offset 14, -4
 743 0002 86B0     		sub	sp, sp, #24
 744              		.cfi_def_cfa_offset 32
 745 0004 00AF     		add	r7, sp, #0
 746              		.cfi_def_cfa_register 7
 747 0006 7860     		str	r0, [r7, #4]
 748 0008 3960     		str	r1, [r7]
1149:../freertos/tasks.c **** 	TickType_t xTimeToWake;
1150:../freertos/tasks.c **** 	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
 749              		.loc 1 1150 0
 750 000a 0023     		mov	r3, #0
 751 000c 7B61     		str	r3, [r7, #20]
1151:../freertos/tasks.c **** 
1152:../freertos/tasks.c **** 		configASSERT( pxPreviousWakeTime );
 752              		.loc 1 1152 0
 753 000e 7B68     		ldr	r3, [r7, #4]
 754 0010 002B     		cmp	r3, #0
 755 0012 01D1     		bne	.L41
 756              		.loc 1 1152 0 is_stmt 0 discriminator 1
 757              	@ 1152 "../freertos/tasks.c" 1
 758 0014 72B6     		 cpsid i 
 759              	@ 0 "" 2
 760              		.code	16
 761              	.L42:
 762 0016 FEE7     		b	.L42
 763              	.L41:
1153:../freertos/tasks.c **** 		configASSERT( ( xTimeIncrement > 0U ) );
 764              		.loc 1 1153 0 is_stmt 1
 765 0018 3B68     		ldr	r3, [r7]
 766 001a 002B     		cmp	r3, #0
 767 001c 01D1     		bne	.L43
 768              		.loc 1 1153 0 is_stmt 0 discriminator 1
 769              	@ 1153 "../freertos/tasks.c" 1
 770 001e 72B6     		 cpsid i 
 771              	@ 0 "" 2
 772              		.code	16
 773              	.L44:
 774 0020 FEE7     		b	.L44
 775              	.L43:
1154:../freertos/tasks.c **** 		configASSERT( uxSchedulerSuspended == 0 );
 776              		.loc 1 1154 0 is_stmt 1
 777 0022 224B     		ldr	r3, .L52
 778 0024 1B68     		ldr	r3, [r3]
 779 0026 002B     		cmp	r3, #0
 780 0028 01D0     		beq	.L45
 781              		.loc 1 1154 0 is_stmt 0 discriminator 1
 782              	@ 1154 "../freertos/tasks.c" 1
 783 002a 72B6     		 cpsid i 
 784              	@ 0 "" 2
 785              		.code	16
 786              	.L46:
 787 002c FEE7     		b	.L46
 788              	.L45:
1155:../freertos/tasks.c **** 
1156:../freertos/tasks.c **** 		vTaskSuspendAll();
 789              		.loc 1 1156 0 is_stmt 1
 790 002e FFF7FEFF 		bl	vTaskSuspendAll
 791              	.LBB3:
1157:../freertos/tasks.c **** 		{
1158:../freertos/tasks.c **** 			/* Minor optimisation.  The tick count cannot change in this
1159:../freertos/tasks.c **** 			block. */
1160:../freertos/tasks.c **** 			const TickType_t xConstTickCount = xTickCount;
 792              		.loc 1 1160 0
 793 0032 1F4B     		ldr	r3, .L52+4
 794 0034 1B68     		ldr	r3, [r3]
 795 0036 3B61     		str	r3, [r7, #16]
1161:../freertos/tasks.c **** 
1162:../freertos/tasks.c **** 			/* Generate the tick time at which the task wants to wake. */
1163:../freertos/tasks.c **** 			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 796              		.loc 1 1163 0
 797 0038 7B68     		ldr	r3, [r7, #4]
 798 003a 1A68     		ldr	r2, [r3]
 799 003c 3B68     		ldr	r3, [r7]
 800 003e D318     		add	r3, r2, r3
 801 0040 FB60     		str	r3, [r7, #12]
1164:../freertos/tasks.c **** 
1165:../freertos/tasks.c **** 			if( xConstTickCount < *pxPreviousWakeTime )
 802              		.loc 1 1165 0
 803 0042 7B68     		ldr	r3, [r7, #4]
 804 0044 1A68     		ldr	r2, [r3]
 805 0046 3B69     		ldr	r3, [r7, #16]
 806 0048 9A42     		cmp	r2, r3
 807 004a 0BD9     		bls	.L47
1166:../freertos/tasks.c **** 			{
1167:../freertos/tasks.c **** 				/* The tick count has overflowed since this function was
1168:../freertos/tasks.c **** 				lasted called.  In this case the only time we should ever
1169:../freertos/tasks.c **** 				actually delay is if the wake time has also	overflowed,
1170:../freertos/tasks.c **** 				and the wake time is greater than the tick time.  When this
1171:../freertos/tasks.c **** 				is the case it is as if neither time had overflowed. */
1172:../freertos/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
 808              		.loc 1 1172 0
 809 004c 7B68     		ldr	r3, [r7, #4]
 810 004e 1A68     		ldr	r2, [r3]
 811 0050 FB68     		ldr	r3, [r7, #12]
 812 0052 9A42     		cmp	r2, r3
 813 0054 11D9     		bls	.L48
 814              		.loc 1 1172 0 is_stmt 0 discriminator 1
 815 0056 FA68     		ldr	r2, [r7, #12]
 816 0058 3B69     		ldr	r3, [r7, #16]
 817 005a 9A42     		cmp	r2, r3
 818 005c 0DD9     		bls	.L48
1173:../freertos/tasks.c **** 				{
1174:../freertos/tasks.c **** 					xShouldDelay = pdTRUE;
 819              		.loc 1 1174 0 is_stmt 1
 820 005e 0123     		mov	r3, #1
 821 0060 7B61     		str	r3, [r7, #20]
 822 0062 0AE0     		b	.L48
 823              	.L47:
1175:../freertos/tasks.c **** 				}
1176:../freertos/tasks.c **** 				else
1177:../freertos/tasks.c **** 				{
1178:../freertos/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1179:../freertos/tasks.c **** 				}
1180:../freertos/tasks.c **** 			}
1181:../freertos/tasks.c **** 			else
1182:../freertos/tasks.c **** 			{
1183:../freertos/tasks.c **** 				/* The tick time has not overflowed.  In this case we will
1184:../freertos/tasks.c **** 				delay if either the wake time has overflowed, and/or the
1185:../freertos/tasks.c **** 				tick time is less than the wake time. */
1186:../freertos/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
 824              		.loc 1 1186 0
 825 0064 7B68     		ldr	r3, [r7, #4]
 826 0066 1A68     		ldr	r2, [r3]
 827 0068 FB68     		ldr	r3, [r7, #12]
 828 006a 9A42     		cmp	r2, r3
 829 006c 03D8     		bhi	.L49
 830              		.loc 1 1186 0 is_stmt 0 discriminator 1
 831 006e FA68     		ldr	r2, [r7, #12]
 832 0070 3B69     		ldr	r3, [r7, #16]
 833 0072 9A42     		cmp	r2, r3
 834 0074 01D9     		bls	.L48
 835              	.L49:
1187:../freertos/tasks.c **** 				{
1188:../freertos/tasks.c **** 					xShouldDelay = pdTRUE;
 836              		.loc 1 1188 0 is_stmt 1
 837 0076 0123     		mov	r3, #1
 838 0078 7B61     		str	r3, [r7, #20]
 839              	.L48:
1189:../freertos/tasks.c **** 				}
1190:../freertos/tasks.c **** 				else
1191:../freertos/tasks.c **** 				{
1192:../freertos/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1193:../freertos/tasks.c **** 				}
1194:../freertos/tasks.c **** 			}
1195:../freertos/tasks.c **** 
1196:../freertos/tasks.c **** 			/* Update the wake time ready for the next call. */
1197:../freertos/tasks.c **** 			*pxPreviousWakeTime = xTimeToWake;
 840              		.loc 1 1197 0
 841 007a 7B68     		ldr	r3, [r7, #4]
 842 007c FA68     		ldr	r2, [r7, #12]
 843 007e 1A60     		str	r2, [r3]
1198:../freertos/tasks.c **** 
1199:../freertos/tasks.c **** 			if( xShouldDelay != pdFALSE )
 844              		.loc 1 1199 0
 845 0080 7B69     		ldr	r3, [r7, #20]
 846 0082 002B     		cmp	r3, #0
 847 0084 06D0     		beq	.L50
1200:../freertos/tasks.c **** 			{
1201:../freertos/tasks.c **** 				traceTASK_DELAY_UNTIL( xTimeToWake );
1202:../freertos/tasks.c **** 
1203:../freertos/tasks.c **** 				/* prvAddCurrentTaskToDelayedList() needs the block time, not
1204:../freertos/tasks.c **** 				the time to wake, so subtract the current tick count. */
1205:../freertos/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
 848              		.loc 1 1205 0
 849 0086 FA68     		ldr	r2, [r7, #12]
 850 0088 3B69     		ldr	r3, [r7, #16]
 851 008a D31A     		sub	r3, r2, r3
 852 008c 181C     		mov	r0, r3
 853 008e 0021     		mov	r1, #0
 854 0090 FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
 855              	.L50:
 856              	.LBE3:
1206:../freertos/tasks.c **** 			}
1207:../freertos/tasks.c **** 			else
1208:../freertos/tasks.c **** 			{
1209:../freertos/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1210:../freertos/tasks.c **** 			}
1211:../freertos/tasks.c **** 		}
1212:../freertos/tasks.c **** 		xAlreadyYielded = xTaskResumeAll();
 857              		.loc 1 1212 0
 858 0094 FFF7FEFF 		bl	xTaskResumeAll
 859 0098 031C     		mov	r3, r0
 860 009a BB60     		str	r3, [r7, #8]
1213:../freertos/tasks.c **** 
1214:../freertos/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
1215:../freertos/tasks.c **** 		have put ourselves to sleep. */
1216:../freertos/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 861              		.loc 1 1216 0
 862 009c BB68     		ldr	r3, [r7, #8]
 863 009e 002B     		cmp	r3, #0
 864 00a0 01D1     		bne	.L40
1217:../freertos/tasks.c **** 		{
1218:../freertos/tasks.c **** 			portYIELD_WITHIN_API();
 865              		.loc 1 1218 0
 866 00a2 FFF7FEFF 		bl	vPortYield
 867              	.L40:
1219:../freertos/tasks.c **** 		}
1220:../freertos/tasks.c **** 		else
1221:../freertos/tasks.c **** 		{
1222:../freertos/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1223:../freertos/tasks.c **** 		}
1224:../freertos/tasks.c **** 	}
 868              		.loc 1 1224 0
 869 00a6 BD46     		mov	sp, r7
 870 00a8 06B0     		add	sp, sp, #24
 871              		@ sp needed
 872 00aa 80BD     		pop	{r7, pc}
 873              	.L53:
 874              		.align	2
 875              	.L52:
 876 00ac 00000000 		.word	uxSchedulerSuspended
 877 00b0 00000000 		.word	xTickCount
 878              		.cfi_endproc
 879              	.LFE4:
 881              		.section	.text.vTaskDelay,"ax",%progbits
 882              		.align	2
 883              		.global	vTaskDelay
 884              		.code	16
 885              		.thumb_func
 887              	vTaskDelay:
 888              	.LFB5:
1225:../freertos/tasks.c **** 
1226:../freertos/tasks.c **** #endif /* INCLUDE_vTaskDelayUntil */
1227:../freertos/tasks.c **** /*-----------------------------------------------------------*/
1228:../freertos/tasks.c **** 
1229:../freertos/tasks.c **** #if ( INCLUDE_vTaskDelay == 1 )
1230:../freertos/tasks.c **** 
1231:../freertos/tasks.c **** 	void vTaskDelay( const TickType_t xTicksToDelay )
1232:../freertos/tasks.c **** 	{
 889              		.loc 1 1232 0
 890              		.cfi_startproc
 891 0000 80B5     		push	{r7, lr}
 892              		.cfi_def_cfa_offset 8
 893              		.cfi_offset 7, -8
 894              		.cfi_offset 14, -4
 895 0002 84B0     		sub	sp, sp, #16
 896              		.cfi_def_cfa_offset 24
 897 0004 00AF     		add	r7, sp, #0
 898              		.cfi_def_cfa_register 7
 899 0006 7860     		str	r0, [r7, #4]
1233:../freertos/tasks.c **** 	BaseType_t xAlreadyYielded = pdFALSE;
 900              		.loc 1 1233 0
 901 0008 0023     		mov	r3, #0
 902 000a FB60     		str	r3, [r7, #12]
1234:../freertos/tasks.c **** 
1235:../freertos/tasks.c **** 		/* A delay time of zero just forces a reschedule. */
1236:../freertos/tasks.c **** 		if( xTicksToDelay > ( TickType_t ) 0U )
 903              		.loc 1 1236 0
 904 000c 7B68     		ldr	r3, [r7, #4]
 905 000e 002B     		cmp	r3, #0
 906 0010 10D0     		beq	.L55
1237:../freertos/tasks.c **** 		{
1238:../freertos/tasks.c **** 			configASSERT( uxSchedulerSuspended == 0 );
 907              		.loc 1 1238 0
 908 0012 0C4B     		ldr	r3, .L59
 909 0014 1B68     		ldr	r3, [r3]
 910 0016 002B     		cmp	r3, #0
 911 0018 01D0     		beq	.L56
 912              		.loc 1 1238 0 is_stmt 0 discriminator 1
 913              	@ 1238 "../freertos/tasks.c" 1
 914 001a 72B6     		 cpsid i 
 915              	@ 0 "" 2
 916              		.code	16
 917              	.L57:
 918 001c FEE7     		b	.L57
 919              	.L56:
1239:../freertos/tasks.c **** 			vTaskSuspendAll();
 920              		.loc 1 1239 0 is_stmt 1
 921 001e FFF7FEFF 		bl	vTaskSuspendAll
1240:../freertos/tasks.c **** 			{
1241:../freertos/tasks.c **** 				traceTASK_DELAY();
1242:../freertos/tasks.c **** 
1243:../freertos/tasks.c **** 				/* A task that is removed from the event list while the
1244:../freertos/tasks.c **** 				scheduler is suspended will not get placed in the ready
1245:../freertos/tasks.c **** 				list or removed from the blocked list until the scheduler
1246:../freertos/tasks.c **** 				is resumed.
1247:../freertos/tasks.c **** 
1248:../freertos/tasks.c **** 				This task cannot be in an event list as it is the currently
1249:../freertos/tasks.c **** 				executing task. */
1250:../freertos/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 922              		.loc 1 1250 0
 923 0022 7B68     		ldr	r3, [r7, #4]
 924 0024 181C     		mov	r0, r3
 925 0026 0021     		mov	r1, #0
 926 0028 FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
1251:../freertos/tasks.c **** 			}
1252:../freertos/tasks.c **** 			xAlreadyYielded = xTaskResumeAll();
 927              		.loc 1 1252 0
 928 002c FFF7FEFF 		bl	xTaskResumeAll
 929 0030 031C     		mov	r3, r0
 930 0032 FB60     		str	r3, [r7, #12]
 931              	.L55:
1253:../freertos/tasks.c **** 		}
1254:../freertos/tasks.c **** 		else
1255:../freertos/tasks.c **** 		{
1256:../freertos/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1257:../freertos/tasks.c **** 		}
1258:../freertos/tasks.c **** 
1259:../freertos/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
1260:../freertos/tasks.c **** 		have put ourselves to sleep. */
1261:../freertos/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 932              		.loc 1 1261 0
 933 0034 FB68     		ldr	r3, [r7, #12]
 934 0036 002B     		cmp	r3, #0
 935 0038 01D1     		bne	.L54
1262:../freertos/tasks.c **** 		{
1263:../freertos/tasks.c **** 			portYIELD_WITHIN_API();
 936              		.loc 1 1263 0
 937 003a FFF7FEFF 		bl	vPortYield
 938              	.L54:
1264:../freertos/tasks.c **** 		}
1265:../freertos/tasks.c **** 		else
1266:../freertos/tasks.c **** 		{
1267:../freertos/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1268:../freertos/tasks.c **** 		}
1269:../freertos/tasks.c **** 	}
 939              		.loc 1 1269 0
 940 003e BD46     		mov	sp, r7
 941 0040 04B0     		add	sp, sp, #16
 942              		@ sp needed
 943 0042 80BD     		pop	{r7, pc}
 944              	.L60:
 945              		.align	2
 946              	.L59:
 947 0044 00000000 		.word	uxSchedulerSuspended
 948              		.cfi_endproc
 949              	.LFE5:
 951              		.section	.text.eTaskGetState,"ax",%progbits
 952              		.align	2
 953              		.global	eTaskGetState
 954              		.code	16
 955              		.thumb_func
 957              	eTaskGetState:
 958              	.LFB6:
1270:../freertos/tasks.c **** 
1271:../freertos/tasks.c **** #endif /* INCLUDE_vTaskDelay */
1272:../freertos/tasks.c **** /*-----------------------------------------------------------*/
1273:../freertos/tasks.c **** 
1274:../freertos/tasks.c **** #if( ( INCLUDE_eTaskGetState == 1 ) || ( configUSE_TRACE_FACILITY == 1 ) )
1275:../freertos/tasks.c **** 
1276:../freertos/tasks.c **** 	eTaskState eTaskGetState( TaskHandle_t xTask )
1277:../freertos/tasks.c **** 	{
 959              		.loc 1 1277 0
 960              		.cfi_startproc
 961 0000 80B5     		push	{r7, lr}
 962              		.cfi_def_cfa_offset 8
 963              		.cfi_offset 7, -8
 964              		.cfi_offset 14, -4
 965 0002 86B0     		sub	sp, sp, #24
 966              		.cfi_def_cfa_offset 32
 967 0004 00AF     		add	r7, sp, #0
 968              		.cfi_def_cfa_register 7
 969 0006 7860     		str	r0, [r7, #4]
1278:../freertos/tasks.c **** 	eTaskState eReturn;
1279:../freertos/tasks.c **** 	List_t *pxStateList;
1280:../freertos/tasks.c **** 	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
 970              		.loc 1 1280 0
 971 0008 7B68     		ldr	r3, [r7, #4]
 972 000a 3B61     		str	r3, [r7, #16]
1281:../freertos/tasks.c **** 
1282:../freertos/tasks.c **** 		configASSERT( pxTCB );
 973              		.loc 1 1282 0
 974 000c 3B69     		ldr	r3, [r7, #16]
 975 000e 002B     		cmp	r3, #0
 976 0010 01D1     		bne	.L62
 977              		.loc 1 1282 0 is_stmt 0 discriminator 1
 978              	@ 1282 "../freertos/tasks.c" 1
 979 0012 72B6     		 cpsid i 
 980              	@ 0 "" 2
 981              		.code	16
 982              	.L63:
 983 0014 FEE7     		b	.L63
 984              	.L62:
1283:../freertos/tasks.c **** 
1284:../freertos/tasks.c **** 		if( pxTCB == pxCurrentTCB )
 985              		.loc 1 1284 0 is_stmt 1
 986 0016 244B     		ldr	r3, .L74
 987 0018 1B68     		ldr	r3, [r3]
 988 001a 3A69     		ldr	r2, [r7, #16]
 989 001c 9A42     		cmp	r2, r3
 990 001e 04D1     		bne	.L64
1285:../freertos/tasks.c **** 		{
1286:../freertos/tasks.c **** 			/* The task calling this function is querying its own state. */
1287:../freertos/tasks.c **** 			eReturn = eRunning;
 991              		.loc 1 1287 0
 992 0020 3B1C     		mov	r3, r7
 993 0022 1733     		add	r3, r3, #23
 994 0024 0022     		mov	r2, #0
 995 0026 1A70     		strb	r2, [r3]
 996 0028 37E0     		b	.L65
 997              	.L64:
1288:../freertos/tasks.c **** 		}
1289:../freertos/tasks.c **** 		else
1290:../freertos/tasks.c **** 		{
1291:../freertos/tasks.c **** 			taskENTER_CRITICAL();
 998              		.loc 1 1291 0
 999 002a FFF7FEFF 		bl	vPortEnterCritical
1292:../freertos/tasks.c **** 			{
1293:../freertos/tasks.c **** 				pxStateList = ( List_t * ) listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );
 1000              		.loc 1 1293 0
 1001 002e 3B69     		ldr	r3, [r7, #16]
 1002 0030 5B69     		ldr	r3, [r3, #20]
 1003 0032 FB60     		str	r3, [r7, #12]
1294:../freertos/tasks.c **** 			}
1295:../freertos/tasks.c **** 			taskEXIT_CRITICAL();
 1004              		.loc 1 1295 0
 1005 0034 FFF7FEFF 		bl	vPortExitCritical
1296:../freertos/tasks.c **** 
1297:../freertos/tasks.c **** 			if( ( pxStateList == pxDelayedTaskList ) || ( pxStateList == pxOverflowDelayedTaskList ) )
 1006              		.loc 1 1297 0
 1007 0038 1C4B     		ldr	r3, .L74+4
 1008 003a 1B68     		ldr	r3, [r3]
 1009 003c FA68     		ldr	r2, [r7, #12]
 1010 003e 9A42     		cmp	r2, r3
 1011 0040 04D0     		beq	.L66
 1012              		.loc 1 1297 0 is_stmt 0 discriminator 1
 1013 0042 1B4B     		ldr	r3, .L74+8
 1014 0044 1B68     		ldr	r3, [r3]
 1015 0046 FA68     		ldr	r2, [r7, #12]
 1016 0048 9A42     		cmp	r2, r3
 1017 004a 04D1     		bne	.L67
 1018              	.L66:
1298:../freertos/tasks.c **** 			{
1299:../freertos/tasks.c **** 				/* The task being queried is referenced from one of the Blocked
1300:../freertos/tasks.c **** 				lists. */
1301:../freertos/tasks.c **** 				eReturn = eBlocked;
 1019              		.loc 1 1301 0 is_stmt 1
 1020 004c 3B1C     		mov	r3, r7
 1021 004e 1733     		add	r3, r3, #23
 1022 0050 0222     		mov	r2, #2
 1023 0052 1A70     		strb	r2, [r3]
 1024 0054 21E0     		b	.L65
 1025              	.L67:
1302:../freertos/tasks.c **** 			}
1303:../freertos/tasks.c **** 
1304:../freertos/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
1305:../freertos/tasks.c **** 				else if( pxStateList == &xSuspendedTaskList )
 1026              		.loc 1 1305 0
 1027 0056 FA68     		ldr	r2, [r7, #12]
 1028 0058 164B     		ldr	r3, .L74+12
 1029 005a 9A42     		cmp	r2, r3
 1030 005c 0DD1     		bne	.L68
1306:../freertos/tasks.c **** 				{
1307:../freertos/tasks.c **** 					/* The task being queried is referenced from the suspended
1308:../freertos/tasks.c **** 					list.  Is it genuinely suspended or is it block
1309:../freertos/tasks.c **** 					indefinitely? */
1310:../freertos/tasks.c **** 					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
 1031              		.loc 1 1310 0
 1032 005e 3B69     		ldr	r3, [r7, #16]
 1033 0060 9B6A     		ldr	r3, [r3, #40]
 1034 0062 002B     		cmp	r3, #0
 1035 0064 04D1     		bne	.L69
1311:../freertos/tasks.c **** 					{
1312:../freertos/tasks.c **** 						eReturn = eSuspended;
 1036              		.loc 1 1312 0
 1037 0066 3B1C     		mov	r3, r7
 1038 0068 1733     		add	r3, r3, #23
 1039 006a 0322     		mov	r2, #3
 1040 006c 1A70     		strb	r2, [r3]
 1041 006e 14E0     		b	.L65
 1042              	.L69:
1313:../freertos/tasks.c **** 					}
1314:../freertos/tasks.c **** 					else
1315:../freertos/tasks.c **** 					{
1316:../freertos/tasks.c **** 						eReturn = eBlocked;
 1043              		.loc 1 1316 0
 1044 0070 3B1C     		mov	r3, r7
 1045 0072 1733     		add	r3, r3, #23
 1046 0074 0222     		mov	r2, #2
 1047 0076 1A70     		strb	r2, [r3]
 1048 0078 0FE0     		b	.L65
 1049              	.L68:
1317:../freertos/tasks.c **** 					}
1318:../freertos/tasks.c **** 				}
1319:../freertos/tasks.c **** 			#endif
1320:../freertos/tasks.c **** 
1321:../freertos/tasks.c **** 			#if ( INCLUDE_vTaskDelete == 1 )
1322:../freertos/tasks.c **** 				else if( ( pxStateList == &xTasksWaitingTermination ) || ( pxStateList == NULL ) )
 1050              		.loc 1 1322 0
 1051 007a FA68     		ldr	r2, [r7, #12]
 1052 007c 0E4B     		ldr	r3, .L74+16
 1053 007e 9A42     		cmp	r2, r3
 1054 0080 02D0     		beq	.L71
 1055              		.loc 1 1322 0 is_stmt 0 discriminator 1
 1056 0082 FB68     		ldr	r3, [r7, #12]
 1057 0084 002B     		cmp	r3, #0
 1058 0086 04D1     		bne	.L72
 1059              	.L71:
1323:../freertos/tasks.c **** 				{
1324:../freertos/tasks.c **** 					/* The task being queried is referenced from the deleted
1325:../freertos/tasks.c **** 					tasks list, or it is not referenced from any lists at
1326:../freertos/tasks.c **** 					all. */
1327:../freertos/tasks.c **** 					eReturn = eDeleted;
 1060              		.loc 1 1327 0 is_stmt 1
 1061 0088 3B1C     		mov	r3, r7
 1062 008a 1733     		add	r3, r3, #23
 1063 008c 0422     		mov	r2, #4
 1064 008e 1A70     		strb	r2, [r3]
 1065 0090 03E0     		b	.L65
 1066              	.L72:
1328:../freertos/tasks.c **** 				}
1329:../freertos/tasks.c **** 			#endif
1330:../freertos/tasks.c **** 
1331:../freertos/tasks.c **** 			else /*lint !e525 Negative indentation is intended to make use of pre-processor clearer. */
1332:../freertos/tasks.c **** 			{
1333:../freertos/tasks.c **** 				/* If the task is not in any other state, it must be in the
1334:../freertos/tasks.c **** 				Ready (including pending ready) state. */
1335:../freertos/tasks.c **** 				eReturn = eReady;
 1067              		.loc 1 1335 0
 1068 0092 3B1C     		mov	r3, r7
 1069 0094 1733     		add	r3, r3, #23
 1070 0096 0122     		mov	r2, #1
 1071 0098 1A70     		strb	r2, [r3]
 1072              	.L65:
1336:../freertos/tasks.c **** 			}
1337:../freertos/tasks.c **** 		}
1338:../freertos/tasks.c **** 
1339:../freertos/tasks.c **** 		return eReturn;
 1073              		.loc 1 1339 0
 1074 009a 3B1C     		mov	r3, r7
 1075 009c 1733     		add	r3, r3, #23
 1076 009e 1B78     		ldrb	r3, [r3]
1340:../freertos/tasks.c **** 	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
 1077              		.loc 1 1340 0
 1078 00a0 181C     		mov	r0, r3
 1079 00a2 BD46     		mov	sp, r7
 1080 00a4 06B0     		add	sp, sp, #24
 1081              		@ sp needed
 1082 00a6 80BD     		pop	{r7, pc}
 1083              	.L75:
 1084              		.align	2
 1085              	.L74:
 1086 00a8 00000000 		.word	pxCurrentTCB
 1087 00ac 00000000 		.word	pxDelayedTaskList
 1088 00b0 00000000 		.word	pxOverflowDelayedTaskList
 1089 00b4 00000000 		.word	xSuspendedTaskList
 1090 00b8 00000000 		.word	xTasksWaitingTermination
 1091              		.cfi_endproc
 1092              	.LFE6:
 1094              		.section	.text.uxTaskPriorityGet,"ax",%progbits
 1095              		.align	2
 1096              		.global	uxTaskPriorityGet
 1097              		.code	16
 1098              		.thumb_func
 1100              	uxTaskPriorityGet:
 1101              	.LFB7:
1341:../freertos/tasks.c **** 
1342:../freertos/tasks.c **** #endif /* INCLUDE_eTaskGetState */
1343:../freertos/tasks.c **** /*-----------------------------------------------------------*/
1344:../freertos/tasks.c **** 
1345:../freertos/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
1346:../freertos/tasks.c **** 
1347:../freertos/tasks.c **** 	UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )
1348:../freertos/tasks.c **** 	{
 1102              		.loc 1 1348 0
 1103              		.cfi_startproc
 1104 0000 80B5     		push	{r7, lr}
 1105              		.cfi_def_cfa_offset 8
 1106              		.cfi_offset 7, -8
 1107              		.cfi_offset 14, -4
 1108 0002 84B0     		sub	sp, sp, #16
 1109              		.cfi_def_cfa_offset 24
 1110 0004 00AF     		add	r7, sp, #0
 1111              		.cfi_def_cfa_register 7
 1112 0006 7860     		str	r0, [r7, #4]
1349:../freertos/tasks.c **** 	TCB_t *pxTCB;
1350:../freertos/tasks.c **** 	UBaseType_t uxReturn;
1351:../freertos/tasks.c **** 
1352:../freertos/tasks.c **** 		taskENTER_CRITICAL();
 1113              		.loc 1 1352 0
 1114 0008 FFF7FEFF 		bl	vPortEnterCritical
1353:../freertos/tasks.c **** 		{
1354:../freertos/tasks.c **** 			/* If null is passed in here then it is the priority of the that
1355:../freertos/tasks.c **** 			called uxTaskPriorityGet() that is being queried. */
1356:../freertos/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTask );
 1115              		.loc 1 1356 0
 1116 000c 7B68     		ldr	r3, [r7, #4]
 1117 000e 002B     		cmp	r3, #0
 1118 0010 02D1     		bne	.L77
 1119              		.loc 1 1356 0 is_stmt 0 discriminator 1
 1120 0012 074B     		ldr	r3, .L80
 1121 0014 1B68     		ldr	r3, [r3]
 1122 0016 00E0     		b	.L78
 1123              	.L77:
 1124              		.loc 1 1356 0 discriminator 2
 1125 0018 7B68     		ldr	r3, [r7, #4]
 1126              	.L78:
 1127              		.loc 1 1356 0 discriminator 3
 1128 001a FB60     		str	r3, [r7, #12]
1357:../freertos/tasks.c **** 			uxReturn = pxTCB->uxPriority;
 1129              		.loc 1 1357 0 is_stmt 1 discriminator 3
 1130 001c FB68     		ldr	r3, [r7, #12]
 1131 001e DB6A     		ldr	r3, [r3, #44]
 1132 0020 BB60     		str	r3, [r7, #8]
1358:../freertos/tasks.c **** 		}
1359:../freertos/tasks.c **** 		taskEXIT_CRITICAL();
 1133              		.loc 1 1359 0 discriminator 3
 1134 0022 FFF7FEFF 		bl	vPortExitCritical
1360:../freertos/tasks.c **** 
1361:../freertos/tasks.c **** 		return uxReturn;
 1135              		.loc 1 1361 0 discriminator 3
 1136 0026 BB68     		ldr	r3, [r7, #8]
1362:../freertos/tasks.c **** 	}
 1137              		.loc 1 1362 0 discriminator 3
 1138 0028 181C     		mov	r0, r3
 1139 002a BD46     		mov	sp, r7
 1140 002c 04B0     		add	sp, sp, #16
 1141              		@ sp needed
 1142 002e 80BD     		pop	{r7, pc}
 1143              	.L81:
 1144              		.align	2
 1145              	.L80:
 1146 0030 00000000 		.word	pxCurrentTCB
 1147              		.cfi_endproc
 1148              	.LFE7:
 1150              		.section	.text.uxTaskPriorityGetFromISR,"ax",%progbits
 1151              		.align	2
 1152              		.global	uxTaskPriorityGetFromISR
 1153              		.code	16
 1154              		.thumb_func
 1156              	uxTaskPriorityGetFromISR:
 1157              	.LFB8:
1363:../freertos/tasks.c **** 
1364:../freertos/tasks.c **** #endif /* INCLUDE_uxTaskPriorityGet */
1365:../freertos/tasks.c **** /*-----------------------------------------------------------*/
1366:../freertos/tasks.c **** 
1367:../freertos/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
1368:../freertos/tasks.c **** 
1369:../freertos/tasks.c **** 	UBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask )
1370:../freertos/tasks.c **** 	{
 1158              		.loc 1 1370 0
 1159              		.cfi_startproc
 1160 0000 80B5     		push	{r7, lr}
 1161              		.cfi_def_cfa_offset 8
 1162              		.cfi_offset 7, -8
 1163              		.cfi_offset 14, -4
 1164 0002 86B0     		sub	sp, sp, #24
 1165              		.cfi_def_cfa_offset 32
 1166 0004 00AF     		add	r7, sp, #0
 1167              		.cfi_def_cfa_register 7
 1168 0006 7860     		str	r0, [r7, #4]
1371:../freertos/tasks.c **** 	TCB_t *pxTCB;
1372:../freertos/tasks.c **** 	UBaseType_t uxReturn, uxSavedInterruptState;
1373:../freertos/tasks.c **** 
1374:../freertos/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
1375:../freertos/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
1376:../freertos/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
1377:../freertos/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
1378:../freertos/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
1379:../freertos/tasks.c **** 		is defined in FreeRTOSConfig.h then
1380:../freertos/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1381:../freertos/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
1382:../freertos/tasks.c **** 		been assigned a priority above the configured maximum system call
1383:../freertos/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
1384:../freertos/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
1385:../freertos/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
1386:../freertos/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
1387:../freertos/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
1388:../freertos/tasks.c **** 		provided on the following link:
1389:../freertos/tasks.c **** 		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1390:../freertos/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1391:../freertos/tasks.c **** 
1392:../freertos/tasks.c **** 		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
 1169              		.loc 1 1392 0
 1170 0008 FFF7FEFF 		bl	ulSetInterruptMaskFromISR
 1171 000c 031C     		mov	r3, r0
 1172 000e 7B61     		str	r3, [r7, #20]
1393:../freertos/tasks.c **** 		{
1394:../freertos/tasks.c **** 			/* If null is passed in here then it is the priority of the calling
1395:../freertos/tasks.c **** 			task that is being queried. */
1396:../freertos/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTask );
 1173              		.loc 1 1396 0
 1174 0010 7B68     		ldr	r3, [r7, #4]
 1175 0012 002B     		cmp	r3, #0
 1176 0014 02D1     		bne	.L83
 1177              		.loc 1 1396 0 is_stmt 0 discriminator 1
 1178 0016 084B     		ldr	r3, .L86
 1179 0018 1B68     		ldr	r3, [r3]
 1180 001a 00E0     		b	.L84
 1181              	.L83:
 1182              		.loc 1 1396 0 discriminator 2
 1183 001c 7B68     		ldr	r3, [r7, #4]
 1184              	.L84:
 1185              		.loc 1 1396 0 discriminator 3
 1186 001e 3B61     		str	r3, [r7, #16]
1397:../freertos/tasks.c **** 			uxReturn = pxTCB->uxPriority;
 1187              		.loc 1 1397 0 is_stmt 1 discriminator 3
 1188 0020 3B69     		ldr	r3, [r7, #16]
 1189 0022 DB6A     		ldr	r3, [r3, #44]
 1190 0024 FB60     		str	r3, [r7, #12]
1398:../freertos/tasks.c **** 		}
1399:../freertos/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );
 1191              		.loc 1 1399 0 discriminator 3
 1192 0026 7B69     		ldr	r3, [r7, #20]
 1193 0028 181C     		mov	r0, r3
 1194 002a FFF7FEFF 		bl	vClearInterruptMaskFromISR
1400:../freertos/tasks.c **** 
1401:../freertos/tasks.c **** 		return uxReturn;
 1195              		.loc 1 1401 0 discriminator 3
 1196 002e FB68     		ldr	r3, [r7, #12]
1402:../freertos/tasks.c **** 	}
 1197              		.loc 1 1402 0 discriminator 3
 1198 0030 181C     		mov	r0, r3
 1199 0032 BD46     		mov	sp, r7
 1200 0034 06B0     		add	sp, sp, #24
 1201              		@ sp needed
 1202 0036 80BD     		pop	{r7, pc}
 1203              	.L87:
 1204              		.align	2
 1205              	.L86:
 1206 0038 00000000 		.word	pxCurrentTCB
 1207              		.cfi_endproc
 1208              	.LFE8:
 1210              		.section	.text.vTaskPrioritySet,"ax",%progbits
 1211              		.align	2
 1212              		.global	vTaskPrioritySet
 1213              		.code	16
 1214              		.thumb_func
 1216              	vTaskPrioritySet:
 1217              	.LFB9:
1403:../freertos/tasks.c **** 
1404:../freertos/tasks.c **** #endif /* INCLUDE_uxTaskPriorityGet */
1405:../freertos/tasks.c **** /*-----------------------------------------------------------*/
1406:../freertos/tasks.c **** 
1407:../freertos/tasks.c **** #if ( INCLUDE_vTaskPrioritySet == 1 )
1408:../freertos/tasks.c **** 
1409:../freertos/tasks.c **** 	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
1410:../freertos/tasks.c **** 	{
 1218              		.loc 1 1410 0
 1219              		.cfi_startproc
 1220 0000 80B5     		push	{r7, lr}
 1221              		.cfi_def_cfa_offset 8
 1222              		.cfi_offset 7, -8
 1223              		.cfi_offset 14, -4
 1224 0002 86B0     		sub	sp, sp, #24
 1225              		.cfi_def_cfa_offset 32
 1226 0004 00AF     		add	r7, sp, #0
 1227              		.cfi_def_cfa_register 7
 1228 0006 7860     		str	r0, [r7, #4]
 1229 0008 3960     		str	r1, [r7]
1411:../freertos/tasks.c **** 	TCB_t *pxTCB;
1412:../freertos/tasks.c **** 	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
1413:../freertos/tasks.c **** 	BaseType_t xYieldRequired = pdFALSE;
 1230              		.loc 1 1413 0
 1231 000a 0023     		mov	r3, #0
 1232 000c 7B61     		str	r3, [r7, #20]
1414:../freertos/tasks.c **** 
1415:../freertos/tasks.c **** 		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
 1233              		.loc 1 1415 0
 1234 000e 3B68     		ldr	r3, [r7]
 1235 0010 042B     		cmp	r3, #4
 1236 0012 01D9     		bls	.L89
 1237              		.loc 1 1415 0 is_stmt 0 discriminator 1
 1238              	@ 1415 "../freertos/tasks.c" 1
 1239 0014 72B6     		 cpsid i 
 1240              	@ 0 "" 2
 1241              		.code	16
 1242              	.L90:
 1243 0016 FEE7     		b	.L90
 1244              	.L89:
1416:../freertos/tasks.c **** 
1417:../freertos/tasks.c **** 		/* Ensure the new priority is valid. */
1418:../freertos/tasks.c **** 		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 1245              		.loc 1 1418 0 is_stmt 1
 1246 0018 3B68     		ldr	r3, [r7]
 1247 001a 042B     		cmp	r3, #4
 1248 001c 01D9     		bls	.L91
1419:../freertos/tasks.c **** 		{
1420:../freertos/tasks.c **** 			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 1249              		.loc 1 1420 0
 1250 001e 0423     		mov	r3, #4
 1251 0020 3B60     		str	r3, [r7]
 1252              	.L91:
1421:../freertos/tasks.c **** 		}
1422:../freertos/tasks.c **** 		else
1423:../freertos/tasks.c **** 		{
1424:../freertos/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1425:../freertos/tasks.c **** 		}
1426:../freertos/tasks.c **** 
1427:../freertos/tasks.c **** 		taskENTER_CRITICAL();
 1253              		.loc 1 1427 0
 1254 0022 FFF7FEFF 		bl	vPortEnterCritical
1428:../freertos/tasks.c **** 		{
1429:../freertos/tasks.c **** 			/* If null is passed in here then it is the priority of the calling
1430:../freertos/tasks.c **** 			task that is being changed. */
1431:../freertos/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTask );
 1255              		.loc 1 1431 0
 1256 0026 7B68     		ldr	r3, [r7, #4]
 1257 0028 002B     		cmp	r3, #0
 1258 002a 02D1     		bne	.L92
 1259              		.loc 1 1431 0 is_stmt 0 discriminator 1
 1260 002c 394B     		ldr	r3, .L103
 1261 002e 1B68     		ldr	r3, [r3]
 1262 0030 00E0     		b	.L93
 1263              	.L92:
 1264              		.loc 1 1431 0 discriminator 2
 1265 0032 7B68     		ldr	r3, [r7, #4]
 1266              	.L93:
 1267              		.loc 1 1431 0 discriminator 3
 1268 0034 3B61     		str	r3, [r7, #16]
1432:../freertos/tasks.c **** 
1433:../freertos/tasks.c **** 			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
1434:../freertos/tasks.c **** 
1435:../freertos/tasks.c **** 			#if ( configUSE_MUTEXES == 1 )
1436:../freertos/tasks.c **** 			{
1437:../freertos/tasks.c **** 				uxCurrentBasePriority = pxTCB->uxBasePriority;
 1269              		.loc 1 1437 0 is_stmt 1 discriminator 3
 1270 0036 3B69     		ldr	r3, [r7, #16]
 1271 0038 1B6D     		ldr	r3, [r3, #80]
 1272 003a FB60     		str	r3, [r7, #12]
1438:../freertos/tasks.c **** 			}
1439:../freertos/tasks.c **** 			#else
1440:../freertos/tasks.c **** 			{
1441:../freertos/tasks.c **** 				uxCurrentBasePriority = pxTCB->uxPriority;
1442:../freertos/tasks.c **** 			}
1443:../freertos/tasks.c **** 			#endif
1444:../freertos/tasks.c **** 
1445:../freertos/tasks.c **** 			if( uxCurrentBasePriority != uxNewPriority )
 1273              		.loc 1 1445 0 discriminator 3
 1274 003c FA68     		ldr	r2, [r7, #12]
 1275 003e 3B68     		ldr	r3, [r7]
 1276 0040 9A42     		cmp	r2, r3
 1277 0042 62D0     		beq	.L94
1446:../freertos/tasks.c **** 			{
1447:../freertos/tasks.c **** 				/* The priority change may have readied a task of higher
1448:../freertos/tasks.c **** 				priority than the calling task. */
1449:../freertos/tasks.c **** 				if( uxNewPriority > uxCurrentBasePriority )
 1278              		.loc 1 1449 0
 1279 0044 3A68     		ldr	r2, [r7]
 1280 0046 FB68     		ldr	r3, [r7, #12]
 1281 0048 9A42     		cmp	r2, r3
 1282 004a 0DD9     		bls	.L95
1450:../freertos/tasks.c **** 				{
1451:../freertos/tasks.c **** 					if( pxTCB != pxCurrentTCB )
 1283              		.loc 1 1451 0
 1284 004c 314B     		ldr	r3, .L103
 1285 004e 1B68     		ldr	r3, [r3]
 1286 0050 3A69     		ldr	r2, [r7, #16]
 1287 0052 9A42     		cmp	r2, r3
 1288 0054 0FD0     		beq	.L96
1452:../freertos/tasks.c **** 					{
1453:../freertos/tasks.c **** 						/* The priority of a task other than the currently
1454:../freertos/tasks.c **** 						running task is being raised.  Is the priority being
1455:../freertos/tasks.c **** 						raised above that of the running task? */
1456:../freertos/tasks.c **** 						if( uxNewPriority >= pxCurrentTCB->uxPriority )
 1289              		.loc 1 1456 0
 1290 0056 2F4B     		ldr	r3, .L103
 1291 0058 1B68     		ldr	r3, [r3]
 1292 005a DA6A     		ldr	r2, [r3, #44]
 1293 005c 3B68     		ldr	r3, [r7]
 1294 005e 9A42     		cmp	r2, r3
 1295 0060 09D8     		bhi	.L96
1457:../freertos/tasks.c **** 						{
1458:../freertos/tasks.c **** 							xYieldRequired = pdTRUE;
 1296              		.loc 1 1458 0
 1297 0062 0123     		mov	r3, #1
 1298 0064 7B61     		str	r3, [r7, #20]
 1299 0066 06E0     		b	.L96
 1300              	.L95:
1459:../freertos/tasks.c **** 						}
1460:../freertos/tasks.c **** 						else
1461:../freertos/tasks.c **** 						{
1462:../freertos/tasks.c **** 							mtCOVERAGE_TEST_MARKER();
1463:../freertos/tasks.c **** 						}
1464:../freertos/tasks.c **** 					}
1465:../freertos/tasks.c **** 					else
1466:../freertos/tasks.c **** 					{
1467:../freertos/tasks.c **** 						/* The priority of the running task is being raised,
1468:../freertos/tasks.c **** 						but the running task must already be the highest
1469:../freertos/tasks.c **** 						priority task able to run so no yield is required. */
1470:../freertos/tasks.c **** 					}
1471:../freertos/tasks.c **** 				}
1472:../freertos/tasks.c **** 				else if( pxTCB == pxCurrentTCB )
 1301              		.loc 1 1472 0
 1302 0068 2A4B     		ldr	r3, .L103
 1303 006a 1B68     		ldr	r3, [r3]
 1304 006c 3A69     		ldr	r2, [r7, #16]
 1305 006e 9A42     		cmp	r2, r3
 1306 0070 01D1     		bne	.L96
1473:../freertos/tasks.c **** 				{
1474:../freertos/tasks.c **** 					/* Setting the priority of the running task down means
1475:../freertos/tasks.c **** 					there may now be another task of higher priority that
1476:../freertos/tasks.c **** 					is ready to execute. */
1477:../freertos/tasks.c **** 					xYieldRequired = pdTRUE;
 1307              		.loc 1 1477 0
 1308 0072 0123     		mov	r3, #1
 1309 0074 7B61     		str	r3, [r7, #20]
 1310              	.L96:
1478:../freertos/tasks.c **** 				}
1479:../freertos/tasks.c **** 				else
1480:../freertos/tasks.c **** 				{
1481:../freertos/tasks.c **** 					/* Setting the priority of any other task down does not
1482:../freertos/tasks.c **** 					require a yield as the running task must be above the
1483:../freertos/tasks.c **** 					new priority of the task being modified. */
1484:../freertos/tasks.c **** 				}
1485:../freertos/tasks.c **** 
1486:../freertos/tasks.c **** 				/* Remember the ready list the task might be referenced from
1487:../freertos/tasks.c **** 				before its uxPriority member is changed so the
1488:../freertos/tasks.c **** 				taskRESET_READY_PRIORITY() macro can function correctly. */
1489:../freertos/tasks.c **** 				uxPriorityUsedOnEntry = pxTCB->uxPriority;
 1311              		.loc 1 1489 0
 1312 0076 3B69     		ldr	r3, [r7, #16]
 1313 0078 DB6A     		ldr	r3, [r3, #44]
 1314 007a BB60     		str	r3, [r7, #8]
1490:../freertos/tasks.c **** 
1491:../freertos/tasks.c **** 				#if ( configUSE_MUTEXES == 1 )
1492:../freertos/tasks.c **** 				{
1493:../freertos/tasks.c **** 					/* Only change the priority being used if the task is not
1494:../freertos/tasks.c **** 					currently using an inherited priority. */
1495:../freertos/tasks.c **** 					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
 1315              		.loc 1 1495 0
 1316 007c 3B69     		ldr	r3, [r7, #16]
 1317 007e 1A6D     		ldr	r2, [r3, #80]
 1318 0080 3B69     		ldr	r3, [r7, #16]
 1319 0082 DB6A     		ldr	r3, [r3, #44]
 1320 0084 9A42     		cmp	r2, r3
 1321 0086 02D1     		bne	.L97
1496:../freertos/tasks.c **** 					{
1497:../freertos/tasks.c **** 						pxTCB->uxPriority = uxNewPriority;
 1322              		.loc 1 1497 0
 1323 0088 3B69     		ldr	r3, [r7, #16]
 1324 008a 3A68     		ldr	r2, [r7]
 1325 008c DA62     		str	r2, [r3, #44]
 1326              	.L97:
1498:../freertos/tasks.c **** 					}
1499:../freertos/tasks.c **** 					else
1500:../freertos/tasks.c **** 					{
1501:../freertos/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1502:../freertos/tasks.c **** 					}
1503:../freertos/tasks.c **** 
1504:../freertos/tasks.c **** 					/* The base priority gets set whatever. */
1505:../freertos/tasks.c **** 					pxTCB->uxBasePriority = uxNewPriority;
 1327              		.loc 1 1505 0
 1328 008e 3B69     		ldr	r3, [r7, #16]
 1329 0090 3A68     		ldr	r2, [r7]
 1330 0092 1A65     		str	r2, [r3, #80]
1506:../freertos/tasks.c **** 				}
1507:../freertos/tasks.c **** 				#else
1508:../freertos/tasks.c **** 				{
1509:../freertos/tasks.c **** 					pxTCB->uxPriority = uxNewPriority;
1510:../freertos/tasks.c **** 				}
1511:../freertos/tasks.c **** 				#endif
1512:../freertos/tasks.c **** 
1513:../freertos/tasks.c **** 				/* Only reset the event list item value if the value is not
1514:../freertos/tasks.c **** 				being used for anything else. */
1515:../freertos/tasks.c **** 				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE 
 1331              		.loc 1 1515 0
 1332 0094 3B69     		ldr	r3, [r7, #16]
 1333 0096 9B69     		ldr	r3, [r3, #24]
 1334 0098 002B     		cmp	r3, #0
 1335 009a 04DB     		blt	.L98
1516:../freertos/tasks.c **** 				{
1517:../freertos/tasks.c **** 					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - (
 1336              		.loc 1 1517 0
 1337 009c 3B68     		ldr	r3, [r7]
 1338 009e 0522     		mov	r2, #5
 1339 00a0 D21A     		sub	r2, r2, r3
 1340 00a2 3B69     		ldr	r3, [r7, #16]
 1341 00a4 9A61     		str	r2, [r3, #24]
 1342              	.L98:
1518:../freertos/tasks.c **** 				}
1519:../freertos/tasks.c **** 				else
1520:../freertos/tasks.c **** 				{
1521:../freertos/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1522:../freertos/tasks.c **** 				}
1523:../freertos/tasks.c **** 
1524:../freertos/tasks.c **** 				/* If the task is in the blocked or suspended list we need do
1525:../freertos/tasks.c **** 				nothing more than change it's priority variable. However, if
1526:../freertos/tasks.c **** 				the task is in a ready list it needs to be removed and placed
1527:../freertos/tasks.c **** 				in the list appropriate to its new priority. */
1528:../freertos/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateL
 1343              		.loc 1 1528 0
 1344 00a6 3B69     		ldr	r3, [r7, #16]
 1345 00a8 5969     		ldr	r1, [r3, #20]
 1346 00aa BA68     		ldr	r2, [r7, #8]
 1347 00ac 131C     		mov	r3, r2
 1348 00ae 9B00     		lsl	r3, r3, #2
 1349 00b0 9B18     		add	r3, r3, r2
 1350 00b2 9B00     		lsl	r3, r3, #2
 1351 00b4 184A     		ldr	r2, .L103+4
 1352 00b6 9B18     		add	r3, r3, r2
 1353 00b8 9942     		cmp	r1, r3
 1354 00ba 01D1     		bne	.L99
 1355              		.loc 1 1528 0 is_stmt 0 discriminator 1
 1356 00bc 0123     		mov	r3, #1
 1357 00be 00E0     		b	.L100
 1358              	.L99:
 1359              		.loc 1 1528 0 discriminator 2
 1360 00c0 0023     		mov	r3, #0
 1361              	.L100:
 1362              		.loc 1 1528 0 discriminator 3
 1363 00c2 002B     		cmp	r3, #0
 1364 00c4 1CD0     		beq	.L101
1529:../freertos/tasks.c **** 				{
1530:../freertos/tasks.c **** 					/* The task is currently in its ready list - remove before adding
1531:../freertos/tasks.c **** 					it to it's new ready list.  As we are in a critical section we
1532:../freertos/tasks.c **** 					can do this even if the scheduler is suspended. */
1533:../freertos/tasks.c **** 					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 1365              		.loc 1 1533 0 is_stmt 1
 1366 00c6 3B69     		ldr	r3, [r7, #16]
 1367 00c8 0433     		add	r3, r3, #4
 1368 00ca 181C     		mov	r0, r3
 1369 00cc FFF7FEFF 		bl	uxListRemove
1534:../freertos/tasks.c **** 					{
1535:../freertos/tasks.c **** 						/* It is known that the task is in its ready list so
1536:../freertos/tasks.c **** 						there is no need to check again and the port level
1537:../freertos/tasks.c **** 						reset macro can be called directly. */
1538:../freertos/tasks.c **** 						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
1539:../freertos/tasks.c **** 					}
1540:../freertos/tasks.c **** 					else
1541:../freertos/tasks.c **** 					{
1542:../freertos/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1543:../freertos/tasks.c **** 					}
1544:../freertos/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1370              		.loc 1 1544 0
 1371 00d0 3B69     		ldr	r3, [r7, #16]
 1372 00d2 DA6A     		ldr	r2, [r3, #44]
 1373 00d4 114B     		ldr	r3, .L103+8
 1374 00d6 1B68     		ldr	r3, [r3]
 1375 00d8 9A42     		cmp	r2, r3
 1376 00da 03D9     		bls	.L102
 1377              		.loc 1 1544 0 is_stmt 0 discriminator 1
 1378 00dc 3B69     		ldr	r3, [r7, #16]
 1379 00de DA6A     		ldr	r2, [r3, #44]
 1380 00e0 0E4B     		ldr	r3, .L103+8
 1381 00e2 1A60     		str	r2, [r3]
 1382              	.L102:
 1383              		.loc 1 1544 0 discriminator 2
 1384 00e4 3B69     		ldr	r3, [r7, #16]
 1385 00e6 DA6A     		ldr	r2, [r3, #44]
 1386 00e8 131C     		mov	r3, r2
 1387 00ea 9B00     		lsl	r3, r3, #2
 1388 00ec 9B18     		add	r3, r3, r2
 1389 00ee 9B00     		lsl	r3, r3, #2
 1390 00f0 094A     		ldr	r2, .L103+4
 1391 00f2 9A18     		add	r2, r3, r2
 1392 00f4 3B69     		ldr	r3, [r7, #16]
 1393 00f6 0433     		add	r3, r3, #4
 1394 00f8 101C     		mov	r0, r2
 1395 00fa 191C     		mov	r1, r3
 1396 00fc FFF7FEFF 		bl	vListInsertEnd
 1397              	.L101:
1545:../freertos/tasks.c **** 				}
1546:../freertos/tasks.c **** 				else
1547:../freertos/tasks.c **** 				{
1548:../freertos/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1549:../freertos/tasks.c **** 				}
1550:../freertos/tasks.c **** 
1551:../freertos/tasks.c **** 				if( xYieldRequired != pdFALSE )
 1398              		.loc 1 1551 0 is_stmt 1
 1399 0100 7B69     		ldr	r3, [r7, #20]
 1400 0102 002B     		cmp	r3, #0
 1401 0104 01D0     		beq	.L94
1552:../freertos/tasks.c **** 				{
1553:../freertos/tasks.c **** 					taskYIELD_IF_USING_PREEMPTION();
 1402              		.loc 1 1553 0
 1403 0106 FFF7FEFF 		bl	vPortYield
 1404              	.L94:
1554:../freertos/tasks.c **** 				}
1555:../freertos/tasks.c **** 				else
1556:../freertos/tasks.c **** 				{
1557:../freertos/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1558:../freertos/tasks.c **** 				}
1559:../freertos/tasks.c **** 
1560:../freertos/tasks.c **** 				/* Remove compiler warning about unused variables when the port
1561:../freertos/tasks.c **** 				optimised task selection is not being used. */
1562:../freertos/tasks.c **** 				( void ) uxPriorityUsedOnEntry;
1563:../freertos/tasks.c **** 			}
1564:../freertos/tasks.c **** 		}
1565:../freertos/tasks.c **** 		taskEXIT_CRITICAL();
 1405              		.loc 1 1565 0
 1406 010a FFF7FEFF 		bl	vPortExitCritical
1566:../freertos/tasks.c **** 	}
 1407              		.loc 1 1566 0
 1408 010e BD46     		mov	sp, r7
 1409 0110 06B0     		add	sp, sp, #24
 1410              		@ sp needed
 1411 0112 80BD     		pop	{r7, pc}
 1412              	.L104:
 1413              		.align	2
 1414              	.L103:
 1415 0114 00000000 		.word	pxCurrentTCB
 1416 0118 00000000 		.word	pxReadyTasksLists
 1417 011c 00000000 		.word	uxTopReadyPriority
 1418              		.cfi_endproc
 1419              	.LFE9:
 1421              		.section	.text.vTaskSuspend,"ax",%progbits
 1422              		.align	2
 1423              		.global	vTaskSuspend
 1424              		.code	16
 1425              		.thumb_func
 1427              	vTaskSuspend:
 1428              	.LFB10:
1567:../freertos/tasks.c **** 
1568:../freertos/tasks.c **** #endif /* INCLUDE_vTaskPrioritySet */
1569:../freertos/tasks.c **** /*-----------------------------------------------------------*/
1570:../freertos/tasks.c **** 
1571:../freertos/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1572:../freertos/tasks.c **** 
1573:../freertos/tasks.c **** 	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
1574:../freertos/tasks.c **** 	{
 1429              		.loc 1 1574 0
 1430              		.cfi_startproc
 1431 0000 80B5     		push	{r7, lr}
 1432              		.cfi_def_cfa_offset 8
 1433              		.cfi_offset 7, -8
 1434              		.cfi_offset 14, -4
 1435 0002 84B0     		sub	sp, sp, #16
 1436              		.cfi_def_cfa_offset 24
 1437 0004 00AF     		add	r7, sp, #0
 1438              		.cfi_def_cfa_register 7
 1439 0006 7860     		str	r0, [r7, #4]
1575:../freertos/tasks.c **** 	TCB_t *pxTCB;
1576:../freertos/tasks.c **** 
1577:../freertos/tasks.c **** 		taskENTER_CRITICAL();
 1440              		.loc 1 1577 0
 1441 0008 FFF7FEFF 		bl	vPortEnterCritical
1578:../freertos/tasks.c **** 		{
1579:../freertos/tasks.c **** 			/* If null is passed in here then it is the running task that is
1580:../freertos/tasks.c **** 			being suspended. */
1581:../freertos/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
 1442              		.loc 1 1581 0
 1443 000c 7B68     		ldr	r3, [r7, #4]
 1444 000e 002B     		cmp	r3, #0
 1445 0010 02D1     		bne	.L106
 1446              		.loc 1 1581 0 is_stmt 0 discriminator 1
 1447 0012 234B     		ldr	r3, .L116
 1448 0014 1B68     		ldr	r3, [r3]
 1449 0016 00E0     		b	.L107
 1450              	.L106:
 1451              		.loc 1 1581 0 discriminator 2
 1452 0018 7B68     		ldr	r3, [r7, #4]
 1453              	.L107:
 1454              		.loc 1 1581 0 discriminator 3
 1455 001a FB60     		str	r3, [r7, #12]
1582:../freertos/tasks.c **** 
1583:../freertos/tasks.c **** 			traceTASK_SUSPEND( pxTCB );
1584:../freertos/tasks.c **** 
1585:../freertos/tasks.c **** 			/* Remove task from the ready/delayed list and place in the
1586:../freertos/tasks.c **** 			suspended list. */
1587:../freertos/tasks.c **** 			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 1456              		.loc 1 1587 0 is_stmt 1 discriminator 3
 1457 001c FB68     		ldr	r3, [r7, #12]
 1458 001e 0433     		add	r3, r3, #4
 1459 0020 181C     		mov	r0, r3
 1460 0022 FFF7FEFF 		bl	uxListRemove
1588:../freertos/tasks.c **** 			{
1589:../freertos/tasks.c **** 				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
1590:../freertos/tasks.c **** 			}
1591:../freertos/tasks.c **** 			else
1592:../freertos/tasks.c **** 			{
1593:../freertos/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1594:../freertos/tasks.c **** 			}
1595:../freertos/tasks.c **** 
1596:../freertos/tasks.c **** 			/* Is the task waiting on an event also? */
1597:../freertos/tasks.c **** 			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 1461              		.loc 1 1597 0 discriminator 3
 1462 0026 FB68     		ldr	r3, [r7, #12]
 1463 0028 9B6A     		ldr	r3, [r3, #40]
 1464 002a 002B     		cmp	r3, #0
 1465 002c 04D0     		beq	.L108
1598:../freertos/tasks.c **** 			{
1599:../freertos/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 1466              		.loc 1 1599 0
 1467 002e FB68     		ldr	r3, [r7, #12]
 1468 0030 1833     		add	r3, r3, #24
 1469 0032 181C     		mov	r0, r3
 1470 0034 FFF7FEFF 		bl	uxListRemove
 1471              	.L108:
1600:../freertos/tasks.c **** 			}
1601:../freertos/tasks.c **** 			else
1602:../freertos/tasks.c **** 			{
1603:../freertos/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1604:../freertos/tasks.c **** 			}
1605:../freertos/tasks.c **** 
1606:../freertos/tasks.c **** 			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
 1472              		.loc 1 1606 0
 1473 0038 FB68     		ldr	r3, [r7, #12]
 1474 003a 0433     		add	r3, r3, #4
 1475 003c 194A     		ldr	r2, .L116+4
 1476 003e 101C     		mov	r0, r2
 1477 0040 191C     		mov	r1, r3
 1478 0042 FFF7FEFF 		bl	vListInsertEnd
1607:../freertos/tasks.c **** 		}
1608:../freertos/tasks.c **** 		taskEXIT_CRITICAL();
 1479              		.loc 1 1608 0
 1480 0046 FFF7FEFF 		bl	vPortExitCritical
1609:../freertos/tasks.c **** 
1610:../freertos/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 1481              		.loc 1 1610 0
 1482 004a 174B     		ldr	r3, .L116+8
 1483 004c 1B68     		ldr	r3, [r3]
 1484 004e 002B     		cmp	r3, #0
 1485 0050 05D0     		beq	.L109
1611:../freertos/tasks.c **** 		{
1612:../freertos/tasks.c **** 			/* Reset the next expected unblock time in case it referred to the
1613:../freertos/tasks.c **** 			task that is now in the Suspended state. */
1614:../freertos/tasks.c **** 			taskENTER_CRITICAL();
 1486              		.loc 1 1614 0
 1487 0052 FFF7FEFF 		bl	vPortEnterCritical
1615:../freertos/tasks.c **** 			{
1616:../freertos/tasks.c **** 				prvResetNextTaskUnblockTime();
 1488              		.loc 1 1616 0
 1489 0056 FFF7FEFF 		bl	prvResetNextTaskUnblockTime
1617:../freertos/tasks.c **** 			}
1618:../freertos/tasks.c **** 			taskEXIT_CRITICAL();
 1490              		.loc 1 1618 0
 1491 005a FFF7FEFF 		bl	vPortExitCritical
 1492              	.L109:
1619:../freertos/tasks.c **** 		}
1620:../freertos/tasks.c **** 		else
1621:../freertos/tasks.c **** 		{
1622:../freertos/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1623:../freertos/tasks.c **** 		}
1624:../freertos/tasks.c **** 
1625:../freertos/tasks.c **** 		if( pxTCB == pxCurrentTCB )
 1493              		.loc 1 1625 0
 1494 005e 104B     		ldr	r3, .L116
 1495 0060 1B68     		ldr	r3, [r3]
 1496 0062 FA68     		ldr	r2, [r7, #12]
 1497 0064 9A42     		cmp	r2, r3
 1498 0066 18D1     		bne	.L105
1626:../freertos/tasks.c **** 		{
1627:../freertos/tasks.c **** 			if( xSchedulerRunning != pdFALSE )
 1499              		.loc 1 1627 0
 1500 0068 0F4B     		ldr	r3, .L116+8
 1501 006a 1B68     		ldr	r3, [r3]
 1502 006c 002B     		cmp	r3, #0
 1503 006e 08D0     		beq	.L111
1628:../freertos/tasks.c **** 			{
1629:../freertos/tasks.c **** 				/* The current task has just been suspended. */
1630:../freertos/tasks.c **** 				configASSERT( uxSchedulerSuspended == 0 );
 1504              		.loc 1 1630 0
 1505 0070 0E4B     		ldr	r3, .L116+12
 1506 0072 1B68     		ldr	r3, [r3]
 1507 0074 002B     		cmp	r3, #0
 1508 0076 01D0     		beq	.L112
 1509              		.loc 1 1630 0 is_stmt 0 discriminator 1
 1510              	@ 1630 "../freertos/tasks.c" 1
 1511 0078 72B6     		 cpsid i 
 1512              	@ 0 "" 2
 1513              		.code	16
 1514              	.L113:
 1515 007a FEE7     		b	.L113
 1516              	.L112:
1631:../freertos/tasks.c **** 				portYIELD_WITHIN_API();
 1517              		.loc 1 1631 0 is_stmt 1
 1518 007c FFF7FEFF 		bl	vPortYield
 1519 0080 0BE0     		b	.L105
 1520              	.L111:
1632:../freertos/tasks.c **** 			}
1633:../freertos/tasks.c **** 			else
1634:../freertos/tasks.c **** 			{
1635:../freertos/tasks.c **** 				/* The scheduler is not running, but the task that was pointed
1636:../freertos/tasks.c **** 				to by pxCurrentTCB has just been suspended and pxCurrentTCB
1637:../freertos/tasks.c **** 				must be adjusted to point to a different task. */
1638:../freertos/tasks.c **** 				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
 1521              		.loc 1 1638 0
 1522 0082 084B     		ldr	r3, .L116+4
 1523 0084 1A68     		ldr	r2, [r3]
 1524 0086 0A4B     		ldr	r3, .L116+16
 1525 0088 1B68     		ldr	r3, [r3]
 1526 008a 9A42     		cmp	r2, r3
 1527 008c 03D1     		bne	.L115
1639:../freertos/tasks.c **** 				{
1640:../freertos/tasks.c **** 					/* No other tasks are ready, so set pxCurrentTCB back to
1641:../freertos/tasks.c **** 					NULL so when the next task is created pxCurrentTCB will
1642:../freertos/tasks.c **** 					be set to point to it no matter what its relative priority
1643:../freertos/tasks.c **** 					is. */
1644:../freertos/tasks.c **** 					pxCurrentTCB = NULL;
 1528              		.loc 1 1644 0
 1529 008e 044B     		ldr	r3, .L116
 1530 0090 0022     		mov	r2, #0
 1531 0092 1A60     		str	r2, [r3]
 1532 0094 01E0     		b	.L105
 1533              	.L115:
1645:../freertos/tasks.c **** 				}
1646:../freertos/tasks.c **** 				else
1647:../freertos/tasks.c **** 				{
1648:../freertos/tasks.c **** 					vTaskSwitchContext();
 1534              		.loc 1 1648 0
 1535 0096 FFF7FEFF 		bl	vTaskSwitchContext
 1536              	.L105:
1649:../freertos/tasks.c **** 				}
1650:../freertos/tasks.c **** 			}
1651:../freertos/tasks.c **** 		}
1652:../freertos/tasks.c **** 		else
1653:../freertos/tasks.c **** 		{
1654:../freertos/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1655:../freertos/tasks.c **** 		}
1656:../freertos/tasks.c **** 	}
 1537              		.loc 1 1656 0
 1538 009a BD46     		mov	sp, r7
 1539 009c 04B0     		add	sp, sp, #16
 1540              		@ sp needed
 1541 009e 80BD     		pop	{r7, pc}
 1542              	.L117:
 1543              		.align	2
 1544              	.L116:
 1545 00a0 00000000 		.word	pxCurrentTCB
 1546 00a4 00000000 		.word	xSuspendedTaskList
 1547 00a8 00000000 		.word	xSchedulerRunning
 1548 00ac 00000000 		.word	uxSchedulerSuspended
 1549 00b0 00000000 		.word	uxCurrentNumberOfTasks
 1550              		.cfi_endproc
 1551              	.LFE10:
 1553              		.section	.text.prvTaskIsTaskSuspended,"ax",%progbits
 1554              		.align	2
 1555              		.code	16
 1556              		.thumb_func
 1558              	prvTaskIsTaskSuspended:
 1559              	.LFB11:
1657:../freertos/tasks.c **** 
1658:../freertos/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1659:../freertos/tasks.c **** /*-----------------------------------------------------------*/
1660:../freertos/tasks.c **** 
1661:../freertos/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1662:../freertos/tasks.c **** 
1663:../freertos/tasks.c **** 	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
1664:../freertos/tasks.c **** 	{
 1560              		.loc 1 1664 0
 1561              		.cfi_startproc
 1562 0000 80B5     		push	{r7, lr}
 1563              		.cfi_def_cfa_offset 8
 1564              		.cfi_offset 7, -8
 1565              		.cfi_offset 14, -4
 1566 0002 84B0     		sub	sp, sp, #16
 1567              		.cfi_def_cfa_offset 24
 1568 0004 00AF     		add	r7, sp, #0
 1569              		.cfi_def_cfa_register 7
 1570 0006 7860     		str	r0, [r7, #4]
1665:../freertos/tasks.c **** 	BaseType_t xReturn = pdFALSE;
 1571              		.loc 1 1665 0
 1572 0008 0023     		mov	r3, #0
 1573 000a FB60     		str	r3, [r7, #12]
1666:../freertos/tasks.c **** 	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
 1574              		.loc 1 1666 0
 1575 000c 7B68     		ldr	r3, [r7, #4]
 1576 000e BB60     		str	r3, [r7, #8]
1667:../freertos/tasks.c **** 
1668:../freertos/tasks.c **** 		/* Accesses xPendingReadyList so must be called from a critical
1669:../freertos/tasks.c **** 		section. */
1670:../freertos/tasks.c **** 
1671:../freertos/tasks.c **** 		/* It does not make sense to check if the calling task is suspended. */
1672:../freertos/tasks.c **** 		configASSERT( xTask );
 1577              		.loc 1 1672 0
 1578 0010 7B68     		ldr	r3, [r7, #4]
 1579 0012 002B     		cmp	r3, #0
 1580 0014 01D1     		bne	.L119
 1581              		.loc 1 1672 0 is_stmt 0 discriminator 1
 1582              	@ 1672 "../freertos/tasks.c" 1
 1583 0016 72B6     		 cpsid i 
 1584              	@ 0 "" 2
 1585              		.code	16
 1586              	.L120:
 1587 0018 FEE7     		b	.L120
 1588              	.L119:
1673:../freertos/tasks.c **** 
1674:../freertos/tasks.c **** 		/* Is the task being resumed actually in the suspended list? */
1675:../freertos/tasks.c **** 		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
 1589              		.loc 1 1675 0 is_stmt 1
 1590 001a BB68     		ldr	r3, [r7, #8]
 1591 001c 5A69     		ldr	r2, [r3, #20]
 1592 001e 0E4B     		ldr	r3, .L127
 1593 0020 9A42     		cmp	r2, r3
 1594 0022 01D1     		bne	.L121
 1595              		.loc 1 1675 0 is_stmt 0 discriminator 1
 1596 0024 0123     		mov	r3, #1
 1597 0026 00E0     		b	.L122
 1598              	.L121:
 1599              		.loc 1 1675 0 discriminator 2
 1600 0028 0023     		mov	r3, #0
 1601              	.L122:
 1602              		.loc 1 1675 0 discriminator 3
 1603 002a 002B     		cmp	r3, #0
 1604 002c 0FD0     		beq	.L123
1676:../freertos/tasks.c **** 		{
1677:../freertos/tasks.c **** 			/* Has the task already been resumed from within an ISR? */
1678:../freertos/tasks.c **** 			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
 1605              		.loc 1 1678 0 is_stmt 1
 1606 002e BB68     		ldr	r3, [r7, #8]
 1607 0030 9A6A     		ldr	r2, [r3, #40]
 1608 0032 0A4B     		ldr	r3, .L127+4
 1609 0034 9A42     		cmp	r2, r3
 1610 0036 0AD0     		beq	.L123
1679:../freertos/tasks.c **** 			{
1680:../freertos/tasks.c **** 				/* Is it in the suspended list because it is in the	Suspended
1681:../freertos/tasks.c **** 				state, or because is is blocked with no timeout? */
1682:../freertos/tasks.c **** 				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE )
 1611              		.loc 1 1682 0
 1612 0038 BB68     		ldr	r3, [r7, #8]
 1613 003a 9B6A     		ldr	r3, [r3, #40]
 1614 003c 002B     		cmp	r3, #0
 1615 003e 01D1     		bne	.L124
 1616              		.loc 1 1682 0 is_stmt 0 discriminator 1
 1617 0040 0123     		mov	r3, #1
 1618 0042 00E0     		b	.L125
 1619              	.L124:
 1620              		.loc 1 1682 0 discriminator 2
 1621 0044 0023     		mov	r3, #0
 1622              	.L125:
 1623              		.loc 1 1682 0 discriminator 3
 1624 0046 002B     		cmp	r3, #0
 1625 0048 01D0     		beq	.L123
1683:../freertos/tasks.c **** 				{
1684:../freertos/tasks.c **** 					xReturn = pdTRUE;
 1626              		.loc 1 1684 0 is_stmt 1
 1627 004a 0123     		mov	r3, #1
 1628 004c FB60     		str	r3, [r7, #12]
 1629              	.L123:
1685:../freertos/tasks.c **** 				}
1686:../freertos/tasks.c **** 				else
1687:../freertos/tasks.c **** 				{
1688:../freertos/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1689:../freertos/tasks.c **** 				}
1690:../freertos/tasks.c **** 			}
1691:../freertos/tasks.c **** 			else
1692:../freertos/tasks.c **** 			{
1693:../freertos/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1694:../freertos/tasks.c **** 			}
1695:../freertos/tasks.c **** 		}
1696:../freertos/tasks.c **** 		else
1697:../freertos/tasks.c **** 		{
1698:../freertos/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1699:../freertos/tasks.c **** 		}
1700:../freertos/tasks.c **** 
1701:../freertos/tasks.c **** 		return xReturn;
 1630              		.loc 1 1701 0
 1631 004e FB68     		ldr	r3, [r7, #12]
1702:../freertos/tasks.c **** 	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
 1632              		.loc 1 1702 0
 1633 0050 181C     		mov	r0, r3
 1634 0052 BD46     		mov	sp, r7
 1635 0054 04B0     		add	sp, sp, #16
 1636              		@ sp needed
 1637 0056 80BD     		pop	{r7, pc}
 1638              	.L128:
 1639              		.align	2
 1640              	.L127:
 1641 0058 00000000 		.word	xSuspendedTaskList
 1642 005c 00000000 		.word	xPendingReadyList
 1643              		.cfi_endproc
 1644              	.LFE11:
 1646              		.section	.text.vTaskResume,"ax",%progbits
 1647              		.align	2
 1648              		.global	vTaskResume
 1649              		.code	16
 1650              		.thumb_func
 1652              	vTaskResume:
 1653              	.LFB12:
1703:../freertos/tasks.c **** 
1704:../freertos/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1705:../freertos/tasks.c **** /*-----------------------------------------------------------*/
1706:../freertos/tasks.c **** 
1707:../freertos/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1708:../freertos/tasks.c **** 
1709:../freertos/tasks.c **** 	void vTaskResume( TaskHandle_t xTaskToResume )
1710:../freertos/tasks.c **** 	{
 1654              		.loc 1 1710 0
 1655              		.cfi_startproc
 1656 0000 80B5     		push	{r7, lr}
 1657              		.cfi_def_cfa_offset 8
 1658              		.cfi_offset 7, -8
 1659              		.cfi_offset 14, -4
 1660 0002 84B0     		sub	sp, sp, #16
 1661              		.cfi_def_cfa_offset 24
 1662 0004 00AF     		add	r7, sp, #0
 1663              		.cfi_def_cfa_register 7
 1664 0006 7860     		str	r0, [r7, #4]
1711:../freertos/tasks.c **** 	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
 1665              		.loc 1 1711 0
 1666 0008 7B68     		ldr	r3, [r7, #4]
 1667 000a FB60     		str	r3, [r7, #12]
1712:../freertos/tasks.c **** 
1713:../freertos/tasks.c **** 		/* It does not make sense to resume the calling task. */
1714:../freertos/tasks.c **** 		configASSERT( xTaskToResume );
 1668              		.loc 1 1714 0
 1669 000c 7B68     		ldr	r3, [r7, #4]
 1670 000e 002B     		cmp	r3, #0
 1671 0010 01D1     		bne	.L130
 1672              		.loc 1 1714 0 is_stmt 0 discriminator 1
 1673              	@ 1714 "../freertos/tasks.c" 1
 1674 0012 72B6     		 cpsid i 
 1675              	@ 0 "" 2
 1676              		.code	16
 1677              	.L131:
 1678 0014 FEE7     		b	.L131
 1679              	.L130:
1715:../freertos/tasks.c **** 
1716:../freertos/tasks.c **** 		/* The parameter cannot be NULL as it is impossible to resume the
1717:../freertos/tasks.c **** 		currently executing task. */
1718:../freertos/tasks.c **** 		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
 1680              		.loc 1 1718 0 is_stmt 1
 1681 0016 FB68     		ldr	r3, [r7, #12]
 1682 0018 002B     		cmp	r3, #0
 1683 001a 35D0     		beq	.L129
 1684              		.loc 1 1718 0 is_stmt 0 discriminator 1
 1685 001c 1C4B     		ldr	r3, .L135
 1686 001e 1B68     		ldr	r3, [r3]
 1687 0020 FA68     		ldr	r2, [r7, #12]
 1688 0022 9A42     		cmp	r2, r3
 1689 0024 30D0     		beq	.L129
1719:../freertos/tasks.c **** 		{
1720:../freertos/tasks.c **** 			taskENTER_CRITICAL();
 1690              		.loc 1 1720 0 is_stmt 1
 1691 0026 FFF7FEFF 		bl	vPortEnterCritical
1721:../freertos/tasks.c **** 			{
1722:../freertos/tasks.c **** 				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
 1692              		.loc 1 1722 0
 1693 002a FB68     		ldr	r3, [r7, #12]
 1694 002c 181C     		mov	r0, r3
 1695 002e FFF7FEFF 		bl	prvTaskIsTaskSuspended
 1696 0032 031C     		mov	r3, r0
 1697 0034 002B     		cmp	r3, #0
 1698 0036 25D0     		beq	.L133
1723:../freertos/tasks.c **** 				{
1724:../freertos/tasks.c **** 					traceTASK_RESUME( pxTCB );
1725:../freertos/tasks.c **** 
1726:../freertos/tasks.c **** 					/* As we are in a critical section we can access the ready
1727:../freertos/tasks.c **** 					lists even if the scheduler is suspended. */
1728:../freertos/tasks.c **** 					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
 1699              		.loc 1 1728 0
 1700 0038 FB68     		ldr	r3, [r7, #12]
 1701 003a 0433     		add	r3, r3, #4
 1702 003c 181C     		mov	r0, r3
 1703 003e FFF7FEFF 		bl	uxListRemove
1729:../freertos/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1704              		.loc 1 1729 0
 1705 0042 FB68     		ldr	r3, [r7, #12]
 1706 0044 DA6A     		ldr	r2, [r3, #44]
 1707 0046 134B     		ldr	r3, .L135+4
 1708 0048 1B68     		ldr	r3, [r3]
 1709 004a 9A42     		cmp	r2, r3
 1710 004c 03D9     		bls	.L134
 1711              		.loc 1 1729 0 is_stmt 0 discriminator 1
 1712 004e FB68     		ldr	r3, [r7, #12]
 1713 0050 DA6A     		ldr	r2, [r3, #44]
 1714 0052 104B     		ldr	r3, .L135+4
 1715 0054 1A60     		str	r2, [r3]
 1716              	.L134:
 1717              		.loc 1 1729 0 discriminator 2
 1718 0056 FB68     		ldr	r3, [r7, #12]
 1719 0058 DA6A     		ldr	r2, [r3, #44]
 1720 005a 131C     		mov	r3, r2
 1721 005c 9B00     		lsl	r3, r3, #2
 1722 005e 9B18     		add	r3, r3, r2
 1723 0060 9B00     		lsl	r3, r3, #2
 1724 0062 0D4A     		ldr	r2, .L135+8
 1725 0064 9A18     		add	r2, r3, r2
 1726 0066 FB68     		ldr	r3, [r7, #12]
 1727 0068 0433     		add	r3, r3, #4
 1728 006a 101C     		mov	r0, r2
 1729 006c 191C     		mov	r1, r3
 1730 006e FFF7FEFF 		bl	vListInsertEnd
1730:../freertos/tasks.c **** 
1731:../freertos/tasks.c **** 					/* We may have just resumed a higher priority task. */
1732:../freertos/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1731              		.loc 1 1732 0 is_stmt 1 discriminator 2
 1732 0072 FB68     		ldr	r3, [r7, #12]
 1733 0074 DA6A     		ldr	r2, [r3, #44]
 1734 0076 064B     		ldr	r3, .L135
 1735 0078 1B68     		ldr	r3, [r3]
 1736 007a DB6A     		ldr	r3, [r3, #44]
 1737 007c 9A42     		cmp	r2, r3
 1738 007e 01D3     		bcc	.L133
1733:../freertos/tasks.c **** 					{
1734:../freertos/tasks.c **** 						/* This yield may not cause the task just resumed to run,
1735:../freertos/tasks.c **** 						but will leave the lists in the correct state for the
1736:../freertos/tasks.c **** 						next yield. */
1737:../freertos/tasks.c **** 						taskYIELD_IF_USING_PREEMPTION();
 1739              		.loc 1 1737 0
 1740 0080 FFF7FEFF 		bl	vPortYield
 1741              	.L133:
1738:../freertos/tasks.c **** 					}
1739:../freertos/tasks.c **** 					else
1740:../freertos/tasks.c **** 					{
1741:../freertos/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1742:../freertos/tasks.c **** 					}
1743:../freertos/tasks.c **** 				}
1744:../freertos/tasks.c **** 				else
1745:../freertos/tasks.c **** 				{
1746:../freertos/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1747:../freertos/tasks.c **** 				}
1748:../freertos/tasks.c **** 			}
1749:../freertos/tasks.c **** 			taskEXIT_CRITICAL();
 1742              		.loc 1 1749 0 discriminator 2
 1743 0084 FFF7FEFF 		bl	vPortExitCritical
 1744              	.L129:
1750:../freertos/tasks.c **** 		}
1751:../freertos/tasks.c **** 		else
1752:../freertos/tasks.c **** 		{
1753:../freertos/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1754:../freertos/tasks.c **** 		}
1755:../freertos/tasks.c **** 	}
 1745              		.loc 1 1755 0
 1746 0088 BD46     		mov	sp, r7
 1747 008a 04B0     		add	sp, sp, #16
 1748              		@ sp needed
 1749 008c 80BD     		pop	{r7, pc}
 1750              	.L136:
 1751 008e C046     		.align	2
 1752              	.L135:
 1753 0090 00000000 		.word	pxCurrentTCB
 1754 0094 00000000 		.word	uxTopReadyPriority
 1755 0098 00000000 		.word	pxReadyTasksLists
 1756              		.cfi_endproc
 1757              	.LFE12:
 1759              		.section	.text.xTaskResumeFromISR,"ax",%progbits
 1760              		.align	2
 1761              		.global	xTaskResumeFromISR
 1762              		.code	16
 1763              		.thumb_func
 1765              	xTaskResumeFromISR:
 1766              	.LFB13:
1756:../freertos/tasks.c **** 
1757:../freertos/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1758:../freertos/tasks.c **** 
1759:../freertos/tasks.c **** /*-----------------------------------------------------------*/
1760:../freertos/tasks.c **** 
1761:../freertos/tasks.c **** #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
1762:../freertos/tasks.c **** 
1763:../freertos/tasks.c **** 	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
1764:../freertos/tasks.c **** 	{
 1767              		.loc 1 1764 0
 1768              		.cfi_startproc
 1769 0000 80B5     		push	{r7, lr}
 1770              		.cfi_def_cfa_offset 8
 1771              		.cfi_offset 7, -8
 1772              		.cfi_offset 14, -4
 1773 0002 86B0     		sub	sp, sp, #24
 1774              		.cfi_def_cfa_offset 32
 1775 0004 00AF     		add	r7, sp, #0
 1776              		.cfi_def_cfa_register 7
 1777 0006 7860     		str	r0, [r7, #4]
1765:../freertos/tasks.c **** 	BaseType_t xYieldRequired = pdFALSE;
 1778              		.loc 1 1765 0
 1779 0008 0023     		mov	r3, #0
 1780 000a 7B61     		str	r3, [r7, #20]
1766:../freertos/tasks.c **** 	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
 1781              		.loc 1 1766 0
 1782 000c 7B68     		ldr	r3, [r7, #4]
 1783 000e 3B61     		str	r3, [r7, #16]
1767:../freertos/tasks.c **** 	UBaseType_t uxSavedInterruptStatus;
1768:../freertos/tasks.c **** 
1769:../freertos/tasks.c **** 		configASSERT( xTaskToResume );
 1784              		.loc 1 1769 0
 1785 0010 7B68     		ldr	r3, [r7, #4]
 1786 0012 002B     		cmp	r3, #0
 1787 0014 01D1     		bne	.L138
 1788              		.loc 1 1769 0 is_stmt 0 discriminator 1
 1789              	@ 1769 "../freertos/tasks.c" 1
 1790 0016 72B6     		 cpsid i 
 1791              	@ 0 "" 2
 1792              		.code	16
 1793              	.L139:
 1794 0018 FEE7     		b	.L139
 1795              	.L138:
1770:../freertos/tasks.c **** 
1771:../freertos/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
1772:../freertos/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
1773:../freertos/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
1774:../freertos/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
1775:../freertos/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
1776:../freertos/tasks.c **** 		is defined in FreeRTOSConfig.h then
1777:../freertos/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1778:../freertos/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
1779:../freertos/tasks.c **** 		been assigned a priority above the configured maximum system call
1780:../freertos/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
1781:../freertos/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
1782:../freertos/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
1783:../freertos/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
1784:../freertos/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
1785:../freertos/tasks.c **** 		provided on the following link:
1786:../freertos/tasks.c **** 		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1787:../freertos/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1788:../freertos/tasks.c **** 
1789:../freertos/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1796              		.loc 1 1789 0 is_stmt 1
 1797 001a FFF7FEFF 		bl	ulSetInterruptMaskFromISR
 1798 001e 031C     		mov	r3, r0
 1799 0020 FB60     		str	r3, [r7, #12]
1790:../freertos/tasks.c **** 		{
1791:../freertos/tasks.c **** 			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
 1800              		.loc 1 1791 0
 1801 0022 3B69     		ldr	r3, [r7, #16]
 1802 0024 181C     		mov	r0, r3
 1803 0026 FFF7FEFF 		bl	prvTaskIsTaskSuspended
 1804 002a 031C     		mov	r3, r0
 1805 002c 002B     		cmp	r3, #0
 1806 002e 31D0     		beq	.L140
1792:../freertos/tasks.c **** 			{
1793:../freertos/tasks.c **** 				traceTASK_RESUME_FROM_ISR( pxTCB );
1794:../freertos/tasks.c **** 
1795:../freertos/tasks.c **** 				/* Check the ready lists can be accessed. */
1796:../freertos/tasks.c **** 				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 1807              		.loc 1 1796 0
 1808 0030 1D4B     		ldr	r3, .L146
 1809 0032 1B68     		ldr	r3, [r3]
 1810 0034 002B     		cmp	r3, #0
 1811 0036 26D1     		bne	.L141
1797:../freertos/tasks.c **** 				{
1798:../freertos/tasks.c **** 					/* Ready lists can be accessed so move the task from the
1799:../freertos/tasks.c **** 					suspended list to the ready list directly. */
1800:../freertos/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1812              		.loc 1 1800 0
 1813 0038 3B69     		ldr	r3, [r7, #16]
 1814 003a DA6A     		ldr	r2, [r3, #44]
 1815 003c 1B4B     		ldr	r3, .L146+4
 1816 003e 1B68     		ldr	r3, [r3]
 1817 0040 DB6A     		ldr	r3, [r3, #44]
 1818 0042 9A42     		cmp	r2, r3
 1819 0044 01D3     		bcc	.L142
1801:../freertos/tasks.c **** 					{
1802:../freertos/tasks.c **** 						xYieldRequired = pdTRUE;
 1820              		.loc 1 1802 0
 1821 0046 0123     		mov	r3, #1
 1822 0048 7B61     		str	r3, [r7, #20]
 1823              	.L142:
1803:../freertos/tasks.c **** 					}
1804:../freertos/tasks.c **** 					else
1805:../freertos/tasks.c **** 					{
1806:../freertos/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1807:../freertos/tasks.c **** 					}
1808:../freertos/tasks.c **** 
1809:../freertos/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 1824              		.loc 1 1809 0
 1825 004a 3B69     		ldr	r3, [r7, #16]
 1826 004c 0433     		add	r3, r3, #4
 1827 004e 181C     		mov	r0, r3
 1828 0050 FFF7FEFF 		bl	uxListRemove
1810:../freertos/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1829              		.loc 1 1810 0
 1830 0054 3B69     		ldr	r3, [r7, #16]
 1831 0056 DA6A     		ldr	r2, [r3, #44]
 1832 0058 154B     		ldr	r3, .L146+8
 1833 005a 1B68     		ldr	r3, [r3]
 1834 005c 9A42     		cmp	r2, r3
 1835 005e 03D9     		bls	.L143
 1836              		.loc 1 1810 0 is_stmt 0 discriminator 1
 1837 0060 3B69     		ldr	r3, [r7, #16]
 1838 0062 DA6A     		ldr	r2, [r3, #44]
 1839 0064 124B     		ldr	r3, .L146+8
 1840 0066 1A60     		str	r2, [r3]
 1841              	.L143:
 1842              		.loc 1 1810 0 discriminator 2
 1843 0068 3B69     		ldr	r3, [r7, #16]
 1844 006a DA6A     		ldr	r2, [r3, #44]
 1845 006c 131C     		mov	r3, r2
 1846 006e 9B00     		lsl	r3, r3, #2
 1847 0070 9B18     		add	r3, r3, r2
 1848 0072 9B00     		lsl	r3, r3, #2
 1849 0074 0F4A     		ldr	r2, .L146+12
 1850 0076 9A18     		add	r2, r3, r2
 1851 0078 3B69     		ldr	r3, [r7, #16]
 1852 007a 0433     		add	r3, r3, #4
 1853 007c 101C     		mov	r0, r2
 1854 007e 191C     		mov	r1, r3
 1855 0080 FFF7FEFF 		bl	vListInsertEnd
 1856 0084 06E0     		b	.L140
 1857              	.L141:
1811:../freertos/tasks.c **** 				}
1812:../freertos/tasks.c **** 				else
1813:../freertos/tasks.c **** 				{
1814:../freertos/tasks.c **** 					/* The delayed or ready lists cannot be accessed so the task
1815:../freertos/tasks.c **** 					is held in the pending ready list until the scheduler is
1816:../freertos/tasks.c **** 					unsuspended. */
1817:../freertos/tasks.c **** 					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 1858              		.loc 1 1817 0 is_stmt 1
 1859 0086 3B69     		ldr	r3, [r7, #16]
 1860 0088 1833     		add	r3, r3, #24
 1861 008a 0B4A     		ldr	r2, .L146+16
 1862 008c 101C     		mov	r0, r2
 1863 008e 191C     		mov	r1, r3
 1864 0090 FFF7FEFF 		bl	vListInsertEnd
 1865              	.L140:
1818:../freertos/tasks.c **** 				}
1819:../freertos/tasks.c **** 			}
1820:../freertos/tasks.c **** 			else
1821:../freertos/tasks.c **** 			{
1822:../freertos/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1823:../freertos/tasks.c **** 			}
1824:../freertos/tasks.c **** 		}
1825:../freertos/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 1866              		.loc 1 1825 0
 1867 0094 FB68     		ldr	r3, [r7, #12]
 1868 0096 181C     		mov	r0, r3
 1869 0098 FFF7FEFF 		bl	vClearInterruptMaskFromISR
1826:../freertos/tasks.c **** 
1827:../freertos/tasks.c **** 		return xYieldRequired;
 1870              		.loc 1 1827 0
 1871 009c 7B69     		ldr	r3, [r7, #20]
1828:../freertos/tasks.c **** 	}
 1872              		.loc 1 1828 0
 1873 009e 181C     		mov	r0, r3
 1874 00a0 BD46     		mov	sp, r7
 1875 00a2 06B0     		add	sp, sp, #24
 1876              		@ sp needed
 1877 00a4 80BD     		pop	{r7, pc}
 1878              	.L147:
 1879 00a6 C046     		.align	2
 1880              	.L146:
 1881 00a8 00000000 		.word	uxSchedulerSuspended
 1882 00ac 00000000 		.word	pxCurrentTCB
 1883 00b0 00000000 		.word	uxTopReadyPriority
 1884 00b4 00000000 		.word	pxReadyTasksLists
 1885 00b8 00000000 		.word	xPendingReadyList
 1886              		.cfi_endproc
 1887              	.LFE13:
 1889              		.section	.rodata
 1890              		.align	2
 1891              	.LC42:
 1892 0000 49444C45 		.ascii	"IDLE\000"
 1892      00
 1893 0005 000000   		.section	.text.vTaskStartScheduler,"ax",%progbits
 1894              		.align	2
 1895              		.global	vTaskStartScheduler
 1896              		.code	16
 1897              		.thumb_func
 1899              	vTaskStartScheduler:
 1900              	.LFB14:
1829:../freertos/tasks.c **** 
1830:../freertos/tasks.c **** #endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
1831:../freertos/tasks.c **** /*-----------------------------------------------------------*/
1832:../freertos/tasks.c **** 
1833:../freertos/tasks.c **** void vTaskStartScheduler( void )
1834:../freertos/tasks.c **** {
 1901              		.loc 1 1834 0
 1902              		.cfi_startproc
 1903 0000 80B5     		push	{r7, lr}
 1904              		.cfi_def_cfa_offset 8
 1905              		.cfi_offset 7, -8
 1906              		.cfi_offset 14, -4
 1907 0002 84B0     		sub	sp, sp, #16
 1908              		.cfi_def_cfa_offset 24
 1909 0004 02AF     		add	r7, sp, #8
 1910              		.cfi_def_cfa 7, 16
1835:../freertos/tasks.c **** BaseType_t xReturn;
1836:../freertos/tasks.c **** 
1837:../freertos/tasks.c **** 	/* Add the idle task at the lowest priority. */
1838:../freertos/tasks.c **** 	#if( configSUPPORT_STATIC_ALLOCATION == 1 )
1839:../freertos/tasks.c **** 	{
1840:../freertos/tasks.c **** 		StaticTask_t *pxIdleTaskTCBBuffer = NULL;
1841:../freertos/tasks.c **** 		StackType_t *pxIdleTaskStackBuffer = NULL;
1842:../freertos/tasks.c **** 		uint32_t ulIdleTaskStackSize;
1843:../freertos/tasks.c **** 
1844:../freertos/tasks.c **** 		/* The Idle task is created using user provided RAM - obtain the
1845:../freertos/tasks.c **** 		address of the RAM then create the idle task. */
1846:../freertos/tasks.c **** 		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize
1847:../freertos/tasks.c **** 		xIdleTaskHandle = xTaskCreateStatic(	prvIdleTask,
1848:../freertos/tasks.c **** 												"IDLE",
1849:../freertos/tasks.c **** 												ulIdleTaskStackSize,
1850:../freertos/tasks.c **** 												( void * ) NULL,
1851:../freertos/tasks.c **** 												( tskIDLE_PRIORITY | portPRIVILEGE_BIT ),
1852:../freertos/tasks.c **** 												pxIdleTaskStackBuffer,
1853:../freertos/tasks.c **** 												pxIdleTaskTCBBuffer ); /*lint !e961 MISRA exception, justified as it is not a redundant
1854:../freertos/tasks.c **** 
1855:../freertos/tasks.c **** 		if( xIdleTaskHandle != NULL )
1856:../freertos/tasks.c **** 		{
1857:../freertos/tasks.c **** 			xReturn = pdPASS;
1858:../freertos/tasks.c **** 		}
1859:../freertos/tasks.c **** 		else
1860:../freertos/tasks.c **** 		{
1861:../freertos/tasks.c **** 			xReturn = pdFAIL;
1862:../freertos/tasks.c **** 		}
1863:../freertos/tasks.c **** 	}
1864:../freertos/tasks.c **** 	#else
1865:../freertos/tasks.c **** 	{
1866:../freertos/tasks.c **** 		/* The Idle task is being created using dynamically allocated RAM. */
1867:../freertos/tasks.c **** 		xReturn = xTaskCreate(	prvIdleTask,
 1911              		.loc 1 1867 0
 1912 0006 174A     		ldr	r2, .L153
 1913 0008 174B     		ldr	r3, .L153+4
 1914 000a 0021     		mov	r1, #0
 1915 000c 0091     		str	r1, [sp]
 1916 000e 1749     		ldr	r1, .L153+8
 1917 0010 0191     		str	r1, [sp, #4]
 1918 0012 101C     		mov	r0, r2
 1919 0014 191C     		mov	r1, r3
 1920 0016 5A22     		mov	r2, #90
 1921 0018 0023     		mov	r3, #0
 1922 001a FFF7FEFF 		bl	xTaskCreate
 1923 001e 031C     		mov	r3, r0
 1924 0020 7B60     		str	r3, [r7, #4]
1868:../freertos/tasks.c **** 								"IDLE", configMINIMAL_STACK_SIZE,
1869:../freertos/tasks.c **** 								( void * ) NULL,
1870:../freertos/tasks.c **** 								( tskIDLE_PRIORITY | portPRIVILEGE_BIT ),
1871:../freertos/tasks.c **** 								&xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explic
1872:../freertos/tasks.c **** 	}
1873:../freertos/tasks.c **** 	#endif /* configSUPPORT_STATIC_ALLOCATION */
1874:../freertos/tasks.c **** 
1875:../freertos/tasks.c **** 	#if ( configUSE_TIMERS == 1 )
1876:../freertos/tasks.c **** 	{
1877:../freertos/tasks.c **** 		if( xReturn == pdPASS )
 1925              		.loc 1 1877 0
 1926 0022 7B68     		ldr	r3, [r7, #4]
 1927 0024 012B     		cmp	r3, #1
 1928 0026 03D1     		bne	.L149
1878:../freertos/tasks.c **** 		{
1879:../freertos/tasks.c **** 			xReturn = xTimerCreateTimerTask();
 1929              		.loc 1 1879 0
 1930 0028 FFF7FEFF 		bl	xTimerCreateTimerTask
 1931 002c 031C     		mov	r3, r0
 1932 002e 7B60     		str	r3, [r7, #4]
 1933              	.L149:
1880:../freertos/tasks.c **** 		}
1881:../freertos/tasks.c **** 		else
1882:../freertos/tasks.c **** 		{
1883:../freertos/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1884:../freertos/tasks.c **** 		}
1885:../freertos/tasks.c **** 	}
1886:../freertos/tasks.c **** 	#endif /* configUSE_TIMERS */
1887:../freertos/tasks.c **** 
1888:../freertos/tasks.c **** 	if( xReturn == pdPASS )
 1934              		.loc 1 1888 0
 1935 0030 7B68     		ldr	r3, [r7, #4]
 1936 0032 012B     		cmp	r3, #1
 1937 0034 0DD1     		bne	.L150
1889:../freertos/tasks.c **** 	{
1890:../freertos/tasks.c **** 		/* Interrupts are turned off here, to ensure a tick does not occur
1891:../freertos/tasks.c **** 		before or during the call to xPortStartScheduler().  The stacks of
1892:../freertos/tasks.c **** 		the created tasks contain a status word with interrupts switched on
1893:../freertos/tasks.c **** 		so interrupts will automatically get re-enabled when the first task
1894:../freertos/tasks.c **** 		starts to run. */
1895:../freertos/tasks.c **** 		portDISABLE_INTERRUPTS();
 1938              		.loc 1 1895 0
 1939              	@ 1895 "../freertos/tasks.c" 1
 1940 0036 72B6     		 cpsid i 
 1941              	@ 0 "" 2
1896:../freertos/tasks.c **** 
1897:../freertos/tasks.c **** 		#if ( configUSE_NEWLIB_REENTRANT == 1 )
1898:../freertos/tasks.c **** 		{
1899:../freertos/tasks.c **** 			/* Switch Newlib's _impure_ptr variable to point to the _reent
1900:../freertos/tasks.c **** 			structure specific to the task that will run first. */
1901:../freertos/tasks.c **** 			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
1902:../freertos/tasks.c **** 		}
1903:../freertos/tasks.c **** 		#endif /* configUSE_NEWLIB_REENTRANT */
1904:../freertos/tasks.c **** 
1905:../freertos/tasks.c **** 		xNextTaskUnblockTime = portMAX_DELAY;
 1942              		.loc 1 1905 0
 1943              		.code	16
 1944 0038 0D4B     		ldr	r3, .L153+12
 1945 003a 0122     		mov	r2, #1
 1946 003c 5242     		neg	r2, r2
 1947 003e 1A60     		str	r2, [r3]
1906:../freertos/tasks.c **** 		xSchedulerRunning = pdTRUE;
 1948              		.loc 1 1906 0
 1949 0040 0C4B     		ldr	r3, .L153+16
 1950 0042 0122     		mov	r2, #1
 1951 0044 1A60     		str	r2, [r3]
1907:../freertos/tasks.c **** 		xTickCount = ( TickType_t ) 0U;
 1952              		.loc 1 1907 0
 1953 0046 0C4B     		ldr	r3, .L153+20
 1954 0048 0022     		mov	r2, #0
 1955 004a 1A60     		str	r2, [r3]
1908:../freertos/tasks.c **** 
1909:../freertos/tasks.c **** 		/* If configGENERATE_RUN_TIME_STATS is defined then the following
1910:../freertos/tasks.c **** 		macro must be defined to configure the timer/counter used to generate
1911:../freertos/tasks.c **** 		the run time counter time base. */
1912:../freertos/tasks.c **** 		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
1913:../freertos/tasks.c **** 
1914:../freertos/tasks.c **** 		/* Setting up the timer tick is hardware specific and thus in the
1915:../freertos/tasks.c **** 		portable interface. */
1916:../freertos/tasks.c **** 		if( xPortStartScheduler() != pdFALSE )
 1956              		.loc 1 1916 0
 1957 004c FFF7FEFF 		bl	xPortStartScheduler
 1958 0050 04E0     		b	.L148
 1959              	.L150:
1917:../freertos/tasks.c **** 		{
1918:../freertos/tasks.c **** 			/* Should not reach here as if the scheduler is running the
1919:../freertos/tasks.c **** 			function will not return. */
1920:../freertos/tasks.c **** 		}
1921:../freertos/tasks.c **** 		else
1922:../freertos/tasks.c **** 		{
1923:../freertos/tasks.c **** 			/* Should only reach here if a task calls xTaskEndScheduler(). */
1924:../freertos/tasks.c **** 		}
1925:../freertos/tasks.c **** 	}
1926:../freertos/tasks.c **** 	else
1927:../freertos/tasks.c **** 	{
1928:../freertos/tasks.c **** 		/* This line will only be reached if the kernel could not be started,
1929:../freertos/tasks.c **** 		because there was not enough FreeRTOS heap to create the idle task
1930:../freertos/tasks.c **** 		or the timer task. */
1931:../freertos/tasks.c **** 		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
 1960              		.loc 1 1931 0
 1961 0052 7B68     		ldr	r3, [r7, #4]
 1962 0054 0133     		add	r3, r3, #1
 1963 0056 01D1     		bne	.L148
 1964              		.loc 1 1931 0 is_stmt 0 discriminator 1
 1965              	@ 1931 "../freertos/tasks.c" 1
 1966 0058 72B6     		 cpsid i 
 1967              	@ 0 "" 2
 1968              		.code	16
 1969              	.L152:
 1970 005a FEE7     		b	.L152
 1971              	.L148:
1932:../freertos/tasks.c **** 	}
1933:../freertos/tasks.c **** 
1934:../freertos/tasks.c **** 	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
1935:../freertos/tasks.c **** 	meaning xIdleTaskHandle is not used anywhere else. */
1936:../freertos/tasks.c **** 	( void ) xIdleTaskHandle;
1937:../freertos/tasks.c **** }
 1972              		.loc 1 1937 0 is_stmt 1
 1973 005c BD46     		mov	sp, r7
 1974 005e 02B0     		add	sp, sp, #8
 1975              		@ sp needed
 1976 0060 80BD     		pop	{r7, pc}
 1977              	.L154:
 1978 0062 C046     		.align	2
 1979              	.L153:
 1980 0064 00000000 		.word	prvIdleTask
 1981 0068 00000000 		.word	.LC42
 1982 006c 00000000 		.word	xIdleTaskHandle
 1983 0070 00000000 		.word	xNextTaskUnblockTime
 1984 0074 00000000 		.word	xSchedulerRunning
 1985 0078 00000000 		.word	xTickCount
 1986              		.cfi_endproc
 1987              	.LFE14:
 1989              		.section	.text.vTaskEndScheduler,"ax",%progbits
 1990              		.align	2
 1991              		.global	vTaskEndScheduler
 1992              		.code	16
 1993              		.thumb_func
 1995              	vTaskEndScheduler:
 1996              	.LFB15:
1938:../freertos/tasks.c **** /*-----------------------------------------------------------*/
1939:../freertos/tasks.c **** 
1940:../freertos/tasks.c **** void vTaskEndScheduler( void )
1941:../freertos/tasks.c **** {
 1997              		.loc 1 1941 0
 1998              		.cfi_startproc
 1999 0000 80B5     		push	{r7, lr}
 2000              		.cfi_def_cfa_offset 8
 2001              		.cfi_offset 7, -8
 2002              		.cfi_offset 14, -4
 2003 0002 00AF     		add	r7, sp, #0
 2004              		.cfi_def_cfa_register 7
1942:../freertos/tasks.c **** 	/* Stop the scheduler interrupts and call the portable scheduler end
1943:../freertos/tasks.c **** 	routine so the original ISRs can be restored if necessary.  The port
1944:../freertos/tasks.c **** 	layer must ensure interrupts enable	bit is left in the correct state. */
1945:../freertos/tasks.c **** 	portDISABLE_INTERRUPTS();
 2005              		.loc 1 1945 0
 2006              	@ 1945 "../freertos/tasks.c" 1
 2007 0004 72B6     		 cpsid i 
 2008              	@ 0 "" 2
1946:../freertos/tasks.c **** 	xSchedulerRunning = pdFALSE;
 2009              		.loc 1 1946 0
 2010              		.code	16
 2011 0006 034B     		ldr	r3, .L156
 2012 0008 0022     		mov	r2, #0
 2013 000a 1A60     		str	r2, [r3]
1947:../freertos/tasks.c **** 	vPortEndScheduler();
 2014              		.loc 1 1947 0
 2015 000c FFF7FEFF 		bl	vPortEndScheduler
1948:../freertos/tasks.c **** }
 2016              		.loc 1 1948 0
 2017 0010 BD46     		mov	sp, r7
 2018              		@ sp needed
 2019 0012 80BD     		pop	{r7, pc}
 2020              	.L157:
 2021              		.align	2
 2022              	.L156:
 2023 0014 00000000 		.word	xSchedulerRunning
 2024              		.cfi_endproc
 2025              	.LFE15:
 2027              		.section	.text.vTaskSuspendAll,"ax",%progbits
 2028              		.align	2
 2029              		.global	vTaskSuspendAll
 2030              		.code	16
 2031              		.thumb_func
 2033              	vTaskSuspendAll:
 2034              	.LFB16:
1949:../freertos/tasks.c **** /*----------------------------------------------------------*/
1950:../freertos/tasks.c **** 
1951:../freertos/tasks.c **** void vTaskSuspendAll( void )
1952:../freertos/tasks.c **** {
 2035              		.loc 1 1952 0
 2036              		.cfi_startproc
 2037 0000 80B5     		push	{r7, lr}
 2038              		.cfi_def_cfa_offset 8
 2039              		.cfi_offset 7, -8
 2040              		.cfi_offset 14, -4
 2041 0002 00AF     		add	r7, sp, #0
 2042              		.cfi_def_cfa_register 7
1953:../freertos/tasks.c **** 	/* A critical section is not required as the variable is of type
1954:../freertos/tasks.c **** 	BaseType_t.  Please read Richard Barry's reply in the following link to a
1955:../freertos/tasks.c **** 	post in the FreeRTOS support forum before reporting this as a bug! -
1956:../freertos/tasks.c **** 	http://goo.gl/wu4acr */
1957:../freertos/tasks.c **** 	++uxSchedulerSuspended;
 2043              		.loc 1 1957 0
 2044 0004 034B     		ldr	r3, .L159
 2045 0006 1B68     		ldr	r3, [r3]
 2046 0008 5A1C     		add	r2, r3, #1
 2047 000a 024B     		ldr	r3, .L159
 2048 000c 1A60     		str	r2, [r3]
1958:../freertos/tasks.c **** }
 2049              		.loc 1 1958 0
 2050 000e BD46     		mov	sp, r7
 2051              		@ sp needed
 2052 0010 80BD     		pop	{r7, pc}
 2053              	.L160:
 2054 0012 C046     		.align	2
 2055              	.L159:
 2056 0014 00000000 		.word	uxSchedulerSuspended
 2057              		.cfi_endproc
 2058              	.LFE16:
 2060              		.section	.text.xTaskResumeAll,"ax",%progbits
 2061              		.align	2
 2062              		.global	xTaskResumeAll
 2063              		.code	16
 2064              		.thumb_func
 2066              	xTaskResumeAll:
 2067              	.LFB17:
1959:../freertos/tasks.c **** /*----------------------------------------------------------*/
1960:../freertos/tasks.c **** 
1961:../freertos/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
1962:../freertos/tasks.c **** 
1963:../freertos/tasks.c **** 	static TickType_t prvGetExpectedIdleTime( void )
1964:../freertos/tasks.c **** 	{
1965:../freertos/tasks.c **** 	TickType_t xReturn;
1966:../freertos/tasks.c **** 	UBaseType_t uxHigherPriorityReadyTasks = pdFALSE;
1967:../freertos/tasks.c **** 
1968:../freertos/tasks.c **** 		/* uxHigherPriorityReadyTasks takes care of the case where
1969:../freertos/tasks.c **** 		configUSE_PREEMPTION is 0, so there may be tasks above the idle priority
1970:../freertos/tasks.c **** 		task that are in the Ready state, even though the idle task is
1971:../freertos/tasks.c **** 		running. */
1972:../freertos/tasks.c **** 		#if( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
1973:../freertos/tasks.c **** 		{
1974:../freertos/tasks.c **** 			if( uxTopReadyPriority > tskIDLE_PRIORITY )
1975:../freertos/tasks.c **** 			{
1976:../freertos/tasks.c **** 				uxHigherPriorityReadyTasks = pdTRUE;
1977:../freertos/tasks.c **** 			}
1978:../freertos/tasks.c **** 		}
1979:../freertos/tasks.c **** 		#else
1980:../freertos/tasks.c **** 		{
1981:../freertos/tasks.c **** 			const UBaseType_t uxLeastSignificantBit = ( UBaseType_t ) 0x01;
1982:../freertos/tasks.c **** 
1983:../freertos/tasks.c **** 			/* When port optimised task selection is used the uxTopReadyPriority
1984:../freertos/tasks.c **** 			variable is used as a bit map.  If bits other than the least
1985:../freertos/tasks.c **** 			significant bit are set then there are tasks that have a priority
1986:../freertos/tasks.c **** 			above the idle priority that are in the Ready state.  This takes
1987:../freertos/tasks.c **** 			care of the case where the co-operative scheduler is in use. */
1988:../freertos/tasks.c **** 			if( uxTopReadyPriority > uxLeastSignificantBit )
1989:../freertos/tasks.c **** 			{
1990:../freertos/tasks.c **** 				uxHigherPriorityReadyTasks = pdTRUE;
1991:../freertos/tasks.c **** 			}
1992:../freertos/tasks.c **** 		}
1993:../freertos/tasks.c **** 		#endif
1994:../freertos/tasks.c **** 
1995:../freertos/tasks.c **** 		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
1996:../freertos/tasks.c **** 		{
1997:../freertos/tasks.c **** 			xReturn = 0;
1998:../freertos/tasks.c **** 		}
1999:../freertos/tasks.c **** 		else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
2000:../freertos/tasks.c **** 		{
2001:../freertos/tasks.c **** 			/* There are other idle priority tasks in the ready state.  If
2002:../freertos/tasks.c **** 			time slicing is used then the very next tick interrupt must be
2003:../freertos/tasks.c **** 			processed. */
2004:../freertos/tasks.c **** 			xReturn = 0;
2005:../freertos/tasks.c **** 		}
2006:../freertos/tasks.c **** 		else if( uxHigherPriorityReadyTasks != pdFALSE )
2007:../freertos/tasks.c **** 		{
2008:../freertos/tasks.c **** 			/* There are tasks in the Ready state that have a priority above the
2009:../freertos/tasks.c **** 			idle priority.  This path can only be reached if
2010:../freertos/tasks.c **** 			configUSE_PREEMPTION is 0. */
2011:../freertos/tasks.c **** 			xReturn = 0;
2012:../freertos/tasks.c **** 		}
2013:../freertos/tasks.c **** 		else
2014:../freertos/tasks.c **** 		{
2015:../freertos/tasks.c **** 			xReturn = xNextTaskUnblockTime - xTickCount;
2016:../freertos/tasks.c **** 		}
2017:../freertos/tasks.c **** 
2018:../freertos/tasks.c **** 		return xReturn;
2019:../freertos/tasks.c **** 	}
2020:../freertos/tasks.c **** 
2021:../freertos/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
2022:../freertos/tasks.c **** /*----------------------------------------------------------*/
2023:../freertos/tasks.c **** 
2024:../freertos/tasks.c **** BaseType_t xTaskResumeAll( void )
2025:../freertos/tasks.c **** {
 2068              		.loc 1 2025 0
 2069              		.cfi_startproc
 2070 0000 80B5     		push	{r7, lr}
 2071              		.cfi_def_cfa_offset 8
 2072              		.cfi_offset 7, -8
 2073              		.cfi_offset 14, -4
 2074 0002 84B0     		sub	sp, sp, #16
 2075              		.cfi_def_cfa_offset 24
 2076 0004 00AF     		add	r7, sp, #0
 2077              		.cfi_def_cfa_register 7
2026:../freertos/tasks.c **** TCB_t *pxTCB = NULL;
 2078              		.loc 1 2026 0
 2079 0006 0023     		mov	r3, #0
 2080 0008 FB60     		str	r3, [r7, #12]
2027:../freertos/tasks.c **** BaseType_t xAlreadyYielded = pdFALSE;
 2081              		.loc 1 2027 0
 2082 000a 0023     		mov	r3, #0
 2083 000c BB60     		str	r3, [r7, #8]
2028:../freertos/tasks.c **** 
2029:../freertos/tasks.c **** 	/* If uxSchedulerSuspended is zero then this function does not match a
2030:../freertos/tasks.c **** 	previous call to vTaskSuspendAll(). */
2031:../freertos/tasks.c **** 	configASSERT( uxSchedulerSuspended );
 2084              		.loc 1 2031 0
 2085 000e 3A4B     		ldr	r3, .L173
 2086 0010 1B68     		ldr	r3, [r3]
 2087 0012 002B     		cmp	r3, #0
 2088 0014 01D1     		bne	.L162
 2089              		.loc 1 2031 0 is_stmt 0 discriminator 1
 2090              	@ 2031 "../freertos/tasks.c" 1
 2091 0016 72B6     		 cpsid i 
 2092              	@ 0 "" 2
 2093              		.code	16
 2094              	.L163:
 2095 0018 FEE7     		b	.L163
 2096              	.L162:
2032:../freertos/tasks.c **** 
2033:../freertos/tasks.c **** 	/* It is possible that an ISR caused a task to be removed from an event
2034:../freertos/tasks.c **** 	list while the scheduler was suspended.  If this was the case then the
2035:../freertos/tasks.c **** 	removed task will have been added to the xPendingReadyList.  Once the
2036:../freertos/tasks.c **** 	scheduler has been resumed it is safe to move all the pending ready
2037:../freertos/tasks.c **** 	tasks from this list into their appropriate ready list. */
2038:../freertos/tasks.c **** 	taskENTER_CRITICAL();
 2097              		.loc 1 2038 0 is_stmt 1
 2098 001a FFF7FEFF 		bl	vPortEnterCritical
2039:../freertos/tasks.c **** 	{
2040:../freertos/tasks.c **** 		--uxSchedulerSuspended;
 2099              		.loc 1 2040 0
 2100 001e 364B     		ldr	r3, .L173
 2101 0020 1B68     		ldr	r3, [r3]
 2102 0022 5A1E     		sub	r2, r3, #1
 2103 0024 344B     		ldr	r3, .L173
 2104 0026 1A60     		str	r2, [r3]
2041:../freertos/tasks.c **** 
2042:../freertos/tasks.c **** 		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 2105              		.loc 1 2042 0
 2106 0028 334B     		ldr	r3, .L173
 2107 002a 1B68     		ldr	r3, [r3]
 2108 002c 002B     		cmp	r3, #0
 2109 002e 5CD1     		bne	.L164
2043:../freertos/tasks.c **** 		{
2044:../freertos/tasks.c **** 			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 2110              		.loc 1 2044 0
 2111 0030 324B     		ldr	r3, .L173+4
 2112 0032 1B68     		ldr	r3, [r3]
 2113 0034 002B     		cmp	r3, #0
 2114 0036 58D0     		beq	.L164
2045:../freertos/tasks.c **** 			{
2046:../freertos/tasks.c **** 				/* Move any readied tasks from the pending list into the
2047:../freertos/tasks.c **** 				appropriate ready list. */
2048:../freertos/tasks.c **** 				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 2115              		.loc 1 2048 0
 2116 0038 2FE0     		b	.L165
 2117              	.L167:
2049:../freertos/tasks.c **** 				{
2050:../freertos/tasks.c **** 					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 2118              		.loc 1 2050 0
 2119 003a 314B     		ldr	r3, .L173+8
 2120 003c DB68     		ldr	r3, [r3, #12]
 2121 003e DB68     		ldr	r3, [r3, #12]
 2122 0040 FB60     		str	r3, [r7, #12]
2051:../freertos/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 2123              		.loc 1 2051 0
 2124 0042 FB68     		ldr	r3, [r7, #12]
 2125 0044 1833     		add	r3, r3, #24
 2126 0046 181C     		mov	r0, r3
 2127 0048 FFF7FEFF 		bl	uxListRemove
2052:../freertos/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 2128              		.loc 1 2052 0
 2129 004c FB68     		ldr	r3, [r7, #12]
 2130 004e 0433     		add	r3, r3, #4
 2131 0050 181C     		mov	r0, r3
 2132 0052 FFF7FEFF 		bl	uxListRemove
2053:../freertos/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 2133              		.loc 1 2053 0
 2134 0056 FB68     		ldr	r3, [r7, #12]
 2135 0058 DA6A     		ldr	r2, [r3, #44]
 2136 005a 2A4B     		ldr	r3, .L173+12
 2137 005c 1B68     		ldr	r3, [r3]
 2138 005e 9A42     		cmp	r2, r3
 2139 0060 03D9     		bls	.L166
 2140              		.loc 1 2053 0 is_stmt 0 discriminator 1
 2141 0062 FB68     		ldr	r3, [r7, #12]
 2142 0064 DA6A     		ldr	r2, [r3, #44]
 2143 0066 274B     		ldr	r3, .L173+12
 2144 0068 1A60     		str	r2, [r3]
 2145              	.L166:
 2146              		.loc 1 2053 0 discriminator 2
 2147 006a FB68     		ldr	r3, [r7, #12]
 2148 006c DA6A     		ldr	r2, [r3, #44]
 2149 006e 131C     		mov	r3, r2
 2150 0070 9B00     		lsl	r3, r3, #2
 2151 0072 9B18     		add	r3, r3, r2
 2152 0074 9B00     		lsl	r3, r3, #2
 2153 0076 244A     		ldr	r2, .L173+16
 2154 0078 9A18     		add	r2, r3, r2
 2155 007a FB68     		ldr	r3, [r7, #12]
 2156 007c 0433     		add	r3, r3, #4
 2157 007e 101C     		mov	r0, r2
 2158 0080 191C     		mov	r1, r3
 2159 0082 FFF7FEFF 		bl	vListInsertEnd
2054:../freertos/tasks.c **** 
2055:../freertos/tasks.c **** 					/* If the moved task has a priority higher than the current
2056:../freertos/tasks.c **** 					task then a yield must be performed. */
2057:../freertos/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 2160              		.loc 1 2057 0 is_stmt 1 discriminator 2
 2161 0086 FB68     		ldr	r3, [r7, #12]
 2162 0088 DA6A     		ldr	r2, [r3, #44]
 2163 008a 204B     		ldr	r3, .L173+20
 2164 008c 1B68     		ldr	r3, [r3]
 2165 008e DB6A     		ldr	r3, [r3, #44]
 2166 0090 9A42     		cmp	r2, r3
 2167 0092 02D3     		bcc	.L165
2058:../freertos/tasks.c **** 					{
2059:../freertos/tasks.c **** 						xYieldPending = pdTRUE;
 2168              		.loc 1 2059 0
 2169 0094 1E4B     		ldr	r3, .L173+24
 2170 0096 0122     		mov	r2, #1
 2171 0098 1A60     		str	r2, [r3]
 2172              	.L165:
2048:../freertos/tasks.c **** 				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 2173              		.loc 1 2048 0 discriminator 1
 2174 009a 194B     		ldr	r3, .L173+8
 2175 009c 1B68     		ldr	r3, [r3]
 2176 009e 002B     		cmp	r3, #0
 2177 00a0 CBD1     		bne	.L167
2060:../freertos/tasks.c **** 					}
2061:../freertos/tasks.c **** 					else
2062:../freertos/tasks.c **** 					{
2063:../freertos/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2064:../freertos/tasks.c **** 					}
2065:../freertos/tasks.c **** 				}
2066:../freertos/tasks.c **** 
2067:../freertos/tasks.c **** 				if( pxTCB != NULL )
 2178              		.loc 1 2067 0
 2179 00a2 FB68     		ldr	r3, [r7, #12]
 2180 00a4 002B     		cmp	r3, #0
 2181 00a6 01D0     		beq	.L168
2068:../freertos/tasks.c **** 				{
2069:../freertos/tasks.c **** 					/* A task was unblocked while the scheduler was suspended,
2070:../freertos/tasks.c **** 					which may have prevented the next unblock time from being
2071:../freertos/tasks.c **** 					re-calculated, in which case re-calculate it now.  Mainly
2072:../freertos/tasks.c **** 					important for low power tickless implementations, where
2073:../freertos/tasks.c **** 					this can prevent an unnecessary exit from low power
2074:../freertos/tasks.c **** 					state. */
2075:../freertos/tasks.c **** 					prvResetNextTaskUnblockTime();
 2182              		.loc 1 2075 0
 2183 00a8 FFF7FEFF 		bl	prvResetNextTaskUnblockTime
 2184              	.L168:
 2185              	.LBB4:
2076:../freertos/tasks.c **** 				}
2077:../freertos/tasks.c **** 
2078:../freertos/tasks.c **** 				/* If any ticks occurred while the scheduler was suspended then
2079:../freertos/tasks.c **** 				they should be processed now.  This ensures the tick count does
2080:../freertos/tasks.c **** 				not	slip, and that any delayed tasks are resumed at the correct
2081:../freertos/tasks.c **** 				time. */
2082:../freertos/tasks.c **** 				{
2083:../freertos/tasks.c **** 					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
 2186              		.loc 1 2083 0
 2187 00ac 194B     		ldr	r3, .L173+28
 2188 00ae 1B68     		ldr	r3, [r3]
 2189 00b0 7B60     		str	r3, [r7, #4]
2084:../freertos/tasks.c **** 
2085:../freertos/tasks.c **** 					if( uxPendedCounts > ( UBaseType_t ) 0U )
 2190              		.loc 1 2085 0
 2191 00b2 7B68     		ldr	r3, [r7, #4]
 2192 00b4 002B     		cmp	r3, #0
 2193 00b6 10D0     		beq	.L169
 2194              	.L171:
2086:../freertos/tasks.c **** 					{
2087:../freertos/tasks.c **** 						do
2088:../freertos/tasks.c **** 						{
2089:../freertos/tasks.c **** 							if( xTaskIncrementTick() != pdFALSE )
 2195              		.loc 1 2089 0
 2196 00b8 FFF7FEFF 		bl	xTaskIncrementTick
 2197 00bc 031C     		mov	r3, r0
 2198 00be 002B     		cmp	r3, #0
 2199 00c0 02D0     		beq	.L170
2090:../freertos/tasks.c **** 							{
2091:../freertos/tasks.c **** 								xYieldPending = pdTRUE;
 2200              		.loc 1 2091 0
 2201 00c2 134B     		ldr	r3, .L173+24
 2202 00c4 0122     		mov	r2, #1
 2203 00c6 1A60     		str	r2, [r3]
 2204              	.L170:
2092:../freertos/tasks.c **** 							}
2093:../freertos/tasks.c **** 							else
2094:../freertos/tasks.c **** 							{
2095:../freertos/tasks.c **** 								mtCOVERAGE_TEST_MARKER();
2096:../freertos/tasks.c **** 							}
2097:../freertos/tasks.c **** 							--uxPendedCounts;
 2205              		.loc 1 2097 0
 2206 00c8 7B68     		ldr	r3, [r7, #4]
 2207 00ca 013B     		sub	r3, r3, #1
 2208 00cc 7B60     		str	r3, [r7, #4]
2098:../freertos/tasks.c **** 						} while( uxPendedCounts > ( UBaseType_t ) 0U );
 2209              		.loc 1 2098 0
 2210 00ce 7B68     		ldr	r3, [r7, #4]
 2211 00d0 002B     		cmp	r3, #0
 2212 00d2 F1D1     		bne	.L171
2099:../freertos/tasks.c **** 
2100:../freertos/tasks.c **** 						uxPendedTicks = 0;
 2213              		.loc 1 2100 0
 2214 00d4 0F4B     		ldr	r3, .L173+28
 2215 00d6 0022     		mov	r2, #0
 2216 00d8 1A60     		str	r2, [r3]
 2217              	.L169:
 2218              	.LBE4:
2101:../freertos/tasks.c **** 					}
2102:../freertos/tasks.c **** 					else
2103:../freertos/tasks.c **** 					{
2104:../freertos/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2105:../freertos/tasks.c **** 					}
2106:../freertos/tasks.c **** 				}
2107:../freertos/tasks.c **** 
2108:../freertos/tasks.c **** 				if( xYieldPending != pdFALSE )
 2219              		.loc 1 2108 0
 2220 00da 0D4B     		ldr	r3, .L173+24
 2221 00dc 1B68     		ldr	r3, [r3]
 2222 00de 002B     		cmp	r3, #0
 2223 00e0 03D0     		beq	.L164
2109:../freertos/tasks.c **** 				{
2110:../freertos/tasks.c **** 					#if( configUSE_PREEMPTION != 0 )
2111:../freertos/tasks.c **** 					{
2112:../freertos/tasks.c **** 						xAlreadyYielded = pdTRUE;
 2224              		.loc 1 2112 0
 2225 00e2 0123     		mov	r3, #1
 2226 00e4 BB60     		str	r3, [r7, #8]
2113:../freertos/tasks.c **** 					}
2114:../freertos/tasks.c **** 					#endif
2115:../freertos/tasks.c **** 					taskYIELD_IF_USING_PREEMPTION();
 2227              		.loc 1 2115 0
 2228 00e6 FFF7FEFF 		bl	vPortYield
 2229              	.L164:
2116:../freertos/tasks.c **** 				}
2117:../freertos/tasks.c **** 				else
2118:../freertos/tasks.c **** 				{
2119:../freertos/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
2120:../freertos/tasks.c **** 				}
2121:../freertos/tasks.c **** 			}
2122:../freertos/tasks.c **** 		}
2123:../freertos/tasks.c **** 		else
2124:../freertos/tasks.c **** 		{
2125:../freertos/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2126:../freertos/tasks.c **** 		}
2127:../freertos/tasks.c **** 	}
2128:../freertos/tasks.c **** 	taskEXIT_CRITICAL();
 2230              		.loc 1 2128 0
 2231 00ea FFF7FEFF 		bl	vPortExitCritical
2129:../freertos/tasks.c **** 
2130:../freertos/tasks.c **** 	return xAlreadyYielded;
 2232              		.loc 1 2130 0
 2233 00ee BB68     		ldr	r3, [r7, #8]
2131:../freertos/tasks.c **** }
 2234              		.loc 1 2131 0
 2235 00f0 181C     		mov	r0, r3
 2236 00f2 BD46     		mov	sp, r7
 2237 00f4 04B0     		add	sp, sp, #16
 2238              		@ sp needed
 2239 00f6 80BD     		pop	{r7, pc}
 2240              	.L174:
 2241              		.align	2
 2242              	.L173:
 2243 00f8 00000000 		.word	uxSchedulerSuspended
 2244 00fc 00000000 		.word	uxCurrentNumberOfTasks
 2245 0100 00000000 		.word	xPendingReadyList
 2246 0104 00000000 		.word	uxTopReadyPriority
 2247 0108 00000000 		.word	pxReadyTasksLists
 2248 010c 00000000 		.word	pxCurrentTCB
 2249 0110 00000000 		.word	xYieldPending
 2250 0114 00000000 		.word	uxPendedTicks
 2251              		.cfi_endproc
 2252              	.LFE17:
 2254              		.section	.text.xTaskGetTickCount,"ax",%progbits
 2255              		.align	2
 2256              		.global	xTaskGetTickCount
 2257              		.code	16
 2258              		.thumb_func
 2260              	xTaskGetTickCount:
 2261              	.LFB18:
2132:../freertos/tasks.c **** /*-----------------------------------------------------------*/
2133:../freertos/tasks.c **** 
2134:../freertos/tasks.c **** TickType_t xTaskGetTickCount( void )
2135:../freertos/tasks.c **** {
 2262              		.loc 1 2135 0
 2263              		.cfi_startproc
 2264 0000 80B5     		push	{r7, lr}
 2265              		.cfi_def_cfa_offset 8
 2266              		.cfi_offset 7, -8
 2267              		.cfi_offset 14, -4
 2268 0002 82B0     		sub	sp, sp, #8
 2269              		.cfi_def_cfa_offset 16
 2270 0004 00AF     		add	r7, sp, #0
 2271              		.cfi_def_cfa_register 7
2136:../freertos/tasks.c **** TickType_t xTicks;
2137:../freertos/tasks.c **** 
2138:../freertos/tasks.c **** 	/* Critical section required if running on a 16 bit processor. */
2139:../freertos/tasks.c **** 	portTICK_TYPE_ENTER_CRITICAL();
2140:../freertos/tasks.c **** 	{
2141:../freertos/tasks.c **** 		xTicks = xTickCount;
 2272              		.loc 1 2141 0
 2273 0006 044B     		ldr	r3, .L177
 2274 0008 1B68     		ldr	r3, [r3]
 2275 000a 7B60     		str	r3, [r7, #4]
2142:../freertos/tasks.c **** 	}
2143:../freertos/tasks.c **** 	portTICK_TYPE_EXIT_CRITICAL();
2144:../freertos/tasks.c **** 
2145:../freertos/tasks.c **** 	return xTicks;
 2276              		.loc 1 2145 0
 2277 000c 7B68     		ldr	r3, [r7, #4]
2146:../freertos/tasks.c **** }
 2278              		.loc 1 2146 0
 2279 000e 181C     		mov	r0, r3
 2280 0010 BD46     		mov	sp, r7
 2281 0012 02B0     		add	sp, sp, #8
 2282              		@ sp needed
 2283 0014 80BD     		pop	{r7, pc}
 2284              	.L178:
 2285 0016 C046     		.align	2
 2286              	.L177:
 2287 0018 00000000 		.word	xTickCount
 2288              		.cfi_endproc
 2289              	.LFE18:
 2291              		.section	.text.xTaskGetTickCountFromISR,"ax",%progbits
 2292              		.align	2
 2293              		.global	xTaskGetTickCountFromISR
 2294              		.code	16
 2295              		.thumb_func
 2297              	xTaskGetTickCountFromISR:
 2298              	.LFB19:
2147:../freertos/tasks.c **** /*-----------------------------------------------------------*/
2148:../freertos/tasks.c **** 
2149:../freertos/tasks.c **** TickType_t xTaskGetTickCountFromISR( void )
2150:../freertos/tasks.c **** {
 2299              		.loc 1 2150 0
 2300              		.cfi_startproc
 2301 0000 80B5     		push	{r7, lr}
 2302              		.cfi_def_cfa_offset 8
 2303              		.cfi_offset 7, -8
 2304              		.cfi_offset 14, -4
 2305 0002 82B0     		sub	sp, sp, #8
 2306              		.cfi_def_cfa_offset 16
 2307 0004 00AF     		add	r7, sp, #0
 2308              		.cfi_def_cfa_register 7
2151:../freertos/tasks.c **** TickType_t xReturn;
2152:../freertos/tasks.c **** UBaseType_t uxSavedInterruptStatus;
2153:../freertos/tasks.c **** 
2154:../freertos/tasks.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
2155:../freertos/tasks.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
2156:../freertos/tasks.c **** 	above the maximum system call priority are kept permanently enabled, even
2157:../freertos/tasks.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
2158:../freertos/tasks.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
2159:../freertos/tasks.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
2160:../freertos/tasks.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
2161:../freertos/tasks.c **** 	assigned a priority above the configured maximum system call priority.
2162:../freertos/tasks.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
2163:../freertos/tasks.c **** 	that have been assigned a priority at or (logically) below the maximum
2164:../freertos/tasks.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
2165:../freertos/tasks.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
2166:../freertos/tasks.c **** 	More information (albeit Cortex-M specific) is provided on the following
2167:../freertos/tasks.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
2168:../freertos/tasks.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
2169:../freertos/tasks.c **** 
2170:../freertos/tasks.c **** 	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
 2309              		.loc 1 2170 0
 2310 0006 0023     		mov	r3, #0
 2311 0008 7B60     		str	r3, [r7, #4]
2171:../freertos/tasks.c **** 	{
2172:../freertos/tasks.c **** 		xReturn = xTickCount;
 2312              		.loc 1 2172 0
 2313 000a 044B     		ldr	r3, .L181
 2314 000c 1B68     		ldr	r3, [r3]
 2315 000e 3B60     		str	r3, [r7]
2173:../freertos/tasks.c **** 	}
2174:../freertos/tasks.c **** 	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
2175:../freertos/tasks.c **** 
2176:../freertos/tasks.c **** 	return xReturn;
 2316              		.loc 1 2176 0
 2317 0010 3B68     		ldr	r3, [r7]
2177:../freertos/tasks.c **** }
 2318              		.loc 1 2177 0
 2319 0012 181C     		mov	r0, r3
 2320 0014 BD46     		mov	sp, r7
 2321 0016 02B0     		add	sp, sp, #8
 2322              		@ sp needed
 2323 0018 80BD     		pop	{r7, pc}
 2324              	.L182:
 2325 001a C046     		.align	2
 2326              	.L181:
 2327 001c 00000000 		.word	xTickCount
 2328              		.cfi_endproc
 2329              	.LFE19:
 2331              		.section	.text.uxTaskGetNumberOfTasks,"ax",%progbits
 2332              		.align	2
 2333              		.global	uxTaskGetNumberOfTasks
 2334              		.code	16
 2335              		.thumb_func
 2337              	uxTaskGetNumberOfTasks:
 2338              	.LFB20:
2178:../freertos/tasks.c **** /*-----------------------------------------------------------*/
2179:../freertos/tasks.c **** 
2180:../freertos/tasks.c **** UBaseType_t uxTaskGetNumberOfTasks( void )
2181:../freertos/tasks.c **** {
 2339              		.loc 1 2181 0
 2340              		.cfi_startproc
 2341 0000 80B5     		push	{r7, lr}
 2342              		.cfi_def_cfa_offset 8
 2343              		.cfi_offset 7, -8
 2344              		.cfi_offset 14, -4
 2345 0002 00AF     		add	r7, sp, #0
 2346              		.cfi_def_cfa_register 7
2182:../freertos/tasks.c **** 	/* A critical section is not required because the variables are of type
2183:../freertos/tasks.c **** 	BaseType_t. */
2184:../freertos/tasks.c **** 	return uxCurrentNumberOfTasks;
 2347              		.loc 1 2184 0
 2348 0004 024B     		ldr	r3, .L185
 2349 0006 1B68     		ldr	r3, [r3]
2185:../freertos/tasks.c **** }
 2350              		.loc 1 2185 0
 2351 0008 181C     		mov	r0, r3
 2352 000a BD46     		mov	sp, r7
 2353              		@ sp needed
 2354 000c 80BD     		pop	{r7, pc}
 2355              	.L186:
 2356 000e C046     		.align	2
 2357              	.L185:
 2358 0010 00000000 		.word	uxCurrentNumberOfTasks
 2359              		.cfi_endproc
 2360              	.LFE20:
 2362              		.section	.text.pcTaskGetName,"ax",%progbits
 2363              		.align	2
 2364              		.global	pcTaskGetName
 2365              		.code	16
 2366              		.thumb_func
 2368              	pcTaskGetName:
 2369              	.LFB21:
2186:../freertos/tasks.c **** /*-----------------------------------------------------------*/
2187:../freertos/tasks.c **** 
2188:../freertos/tasks.c **** char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed fo
2189:../freertos/tasks.c **** {
 2370              		.loc 1 2189 0
 2371              		.cfi_startproc
 2372 0000 80B5     		push	{r7, lr}
 2373              		.cfi_def_cfa_offset 8
 2374              		.cfi_offset 7, -8
 2375              		.cfi_offset 14, -4
 2376 0002 84B0     		sub	sp, sp, #16
 2377              		.cfi_def_cfa_offset 24
 2378 0004 00AF     		add	r7, sp, #0
 2379              		.cfi_def_cfa_register 7
 2380 0006 7860     		str	r0, [r7, #4]
2190:../freertos/tasks.c **** TCB_t *pxTCB;
2191:../freertos/tasks.c **** 
2192:../freertos/tasks.c **** 	/* If null is passed in here then the name of the calling task is being
2193:../freertos/tasks.c **** 	queried. */
2194:../freertos/tasks.c **** 	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
 2381              		.loc 1 2194 0
 2382 0008 7B68     		ldr	r3, [r7, #4]
 2383 000a 002B     		cmp	r3, #0
 2384 000c 02D1     		bne	.L188
 2385              		.loc 1 2194 0 is_stmt 0 discriminator 1
 2386 000e 084B     		ldr	r3, .L193
 2387 0010 1B68     		ldr	r3, [r3]
 2388 0012 00E0     		b	.L189
 2389              	.L188:
 2390              		.loc 1 2194 0 discriminator 2
 2391 0014 7B68     		ldr	r3, [r7, #4]
 2392              	.L189:
 2393              		.loc 1 2194 0 discriminator 3
 2394 0016 FB60     		str	r3, [r7, #12]
2195:../freertos/tasks.c **** 	configASSERT( pxTCB );
 2395              		.loc 1 2195 0 is_stmt 1 discriminator 3
 2396 0018 FB68     		ldr	r3, [r7, #12]
 2397 001a 002B     		cmp	r3, #0
 2398 001c 01D1     		bne	.L190
 2399              		.loc 1 2195 0 is_stmt 0 discriminator 1
 2400              	@ 2195 "../freertos/tasks.c" 1
 2401 001e 72B6     		 cpsid i 
 2402              	@ 0 "" 2
 2403              		.code	16
 2404              	.L191:
 2405 0020 FEE7     		b	.L191
 2406              	.L190:
2196:../freertos/tasks.c **** 	return &( pxTCB->pcTaskName[ 0 ] );
 2407              		.loc 1 2196 0 is_stmt 1
 2408 0022 FB68     		ldr	r3, [r7, #12]
 2409 0024 3433     		add	r3, r3, #52
2197:../freertos/tasks.c **** }
 2410              		.loc 1 2197 0
 2411 0026 181C     		mov	r0, r3
 2412 0028 BD46     		mov	sp, r7
 2413 002a 04B0     		add	sp, sp, #16
 2414              		@ sp needed
 2415 002c 80BD     		pop	{r7, pc}
 2416              	.L194:
 2417 002e C046     		.align	2
 2418              	.L193:
 2419 0030 00000000 		.word	pxCurrentTCB
 2420              		.cfi_endproc
 2421              	.LFE21:
 2423              		.section	.text.uxTaskGetSystemState,"ax",%progbits
 2424              		.align	2
 2425              		.global	uxTaskGetSystemState
 2426              		.code	16
 2427              		.thumb_func
 2429              	uxTaskGetSystemState:
 2430              	.LFB22:
2198:../freertos/tasks.c **** /*-----------------------------------------------------------*/
2199:../freertos/tasks.c **** 
2200:../freertos/tasks.c **** #if ( INCLUDE_xTaskGetHandle == 1 )
2201:../freertos/tasks.c **** 
2202:../freertos/tasks.c **** 	static TCB_t *prvSearchForNameWithinSingleList( List_t *pxList, const char pcNameToQuery[] )
2203:../freertos/tasks.c **** 	{
2204:../freertos/tasks.c **** 	TCB_t *pxNextTCB, *pxFirstTCB, *pxReturn = NULL;
2205:../freertos/tasks.c **** 	UBaseType_t x;
2206:../freertos/tasks.c **** 	char cNextChar;
2207:../freertos/tasks.c **** 
2208:../freertos/tasks.c **** 		/* This function is called with the scheduler suspended. */
2209:../freertos/tasks.c **** 
2210:../freertos/tasks.c **** 		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
2211:../freertos/tasks.c **** 		{
2212:../freertos/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
2213:../freertos/tasks.c **** 
2214:../freertos/tasks.c **** 			do
2215:../freertos/tasks.c **** 			{
2216:../freertos/tasks.c **** 				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
2217:../freertos/tasks.c **** 
2218:../freertos/tasks.c **** 				/* Check each character in the name looking for a match or
2219:../freertos/tasks.c **** 				mismatch. */
2220:../freertos/tasks.c **** 				for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
2221:../freertos/tasks.c **** 				{
2222:../freertos/tasks.c **** 					cNextChar = pxNextTCB->pcTaskName[ x ];
2223:../freertos/tasks.c **** 
2224:../freertos/tasks.c **** 					if( cNextChar != pcNameToQuery[ x ] )
2225:../freertos/tasks.c **** 					{
2226:../freertos/tasks.c **** 						/* Characters didn't match. */
2227:../freertos/tasks.c **** 						break;
2228:../freertos/tasks.c **** 					}
2229:../freertos/tasks.c **** 					else if( cNextChar == 0x00 )
2230:../freertos/tasks.c **** 					{
2231:../freertos/tasks.c **** 						/* Both strings terminated, a match must have been
2232:../freertos/tasks.c **** 						found. */
2233:../freertos/tasks.c **** 						pxReturn = pxNextTCB;
2234:../freertos/tasks.c **** 						break;
2235:../freertos/tasks.c **** 					}
2236:../freertos/tasks.c **** 					else
2237:../freertos/tasks.c **** 					{
2238:../freertos/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2239:../freertos/tasks.c **** 					}
2240:../freertos/tasks.c **** 				}
2241:../freertos/tasks.c **** 
2242:../freertos/tasks.c **** 				if( pxReturn != NULL )
2243:../freertos/tasks.c **** 				{
2244:../freertos/tasks.c **** 					/* The handle has been found. */
2245:../freertos/tasks.c **** 					break;
2246:../freertos/tasks.c **** 				}
2247:../freertos/tasks.c **** 
2248:../freertos/tasks.c **** 			} while( pxNextTCB != pxFirstTCB );
2249:../freertos/tasks.c **** 		}
2250:../freertos/tasks.c **** 		else
2251:../freertos/tasks.c **** 		{
2252:../freertos/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2253:../freertos/tasks.c **** 		}
2254:../freertos/tasks.c **** 
2255:../freertos/tasks.c **** 		return pxReturn;
2256:../freertos/tasks.c **** 	}
2257:../freertos/tasks.c **** 
2258:../freertos/tasks.c **** #endif /* INCLUDE_xTaskGetHandle */
2259:../freertos/tasks.c **** /*-----------------------------------------------------------*/
2260:../freertos/tasks.c **** 
2261:../freertos/tasks.c **** #if ( INCLUDE_xTaskGetHandle == 1 )
2262:../freertos/tasks.c **** 
2263:../freertos/tasks.c **** 	TaskHandle_t xTaskGetHandle( const char *pcNameToQuery ) /*lint !e971 Unqualified char types are a
2264:../freertos/tasks.c **** 	{
2265:../freertos/tasks.c **** 	UBaseType_t uxQueue = configMAX_PRIORITIES;
2266:../freertos/tasks.c **** 	TCB_t* pxTCB;
2267:../freertos/tasks.c **** 
2268:../freertos/tasks.c **** 		/* Task names will be truncated to configMAX_TASK_NAME_LEN - 1 bytes. */
2269:../freertos/tasks.c **** 		configASSERT( strlen( pcNameToQuery ) < configMAX_TASK_NAME_LEN );
2270:../freertos/tasks.c **** 
2271:../freertos/tasks.c **** 		vTaskSuspendAll();
2272:../freertos/tasks.c **** 		{
2273:../freertos/tasks.c **** 			/* Search the ready lists. */
2274:../freertos/tasks.c **** 			do
2275:../freertos/tasks.c **** 			{
2276:../freertos/tasks.c **** 				uxQueue--;
2277:../freertos/tasks.c **** 				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) &( pxReadyTasksLists[ uxQueue ] ), pcNam
2278:../freertos/tasks.c **** 
2279:../freertos/tasks.c **** 				if( pxTCB != NULL )
2280:../freertos/tasks.c **** 				{
2281:../freertos/tasks.c **** 					/* Found the handle. */
2282:../freertos/tasks.c **** 					break;
2283:../freertos/tasks.c **** 				}
2284:../freertos/tasks.c **** 
2285:../freertos/tasks.c **** 			} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts
2286:../freertos/tasks.c **** 
2287:../freertos/tasks.c **** 			/* Search the delayed lists. */
2288:../freertos/tasks.c **** 			if( pxTCB == NULL )
2289:../freertos/tasks.c **** 			{
2290:../freertos/tasks.c **** 				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxDelayedTaskList, pcNameToQuery );
2291:../freertos/tasks.c **** 			}
2292:../freertos/tasks.c **** 
2293:../freertos/tasks.c **** 			if( pxTCB == NULL )
2294:../freertos/tasks.c **** 			{
2295:../freertos/tasks.c **** 				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxOverflowDelayedTaskList, pcNameToQuery
2296:../freertos/tasks.c **** 			}
2297:../freertos/tasks.c **** 
2298:../freertos/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
2299:../freertos/tasks.c **** 			{
2300:../freertos/tasks.c **** 				if( pxTCB == NULL )
2301:../freertos/tasks.c **** 				{
2302:../freertos/tasks.c **** 					/* Search the suspended list. */
2303:../freertos/tasks.c **** 					pxTCB = prvSearchForNameWithinSingleList( &xSuspendedTaskList, pcNameToQuery );
2304:../freertos/tasks.c **** 				}
2305:../freertos/tasks.c **** 			}
2306:../freertos/tasks.c **** 			#endif
2307:../freertos/tasks.c **** 
2308:../freertos/tasks.c **** 			#if( INCLUDE_vTaskDelete == 1 )
2309:../freertos/tasks.c **** 			{
2310:../freertos/tasks.c **** 				if( pxTCB == NULL )
2311:../freertos/tasks.c **** 				{
2312:../freertos/tasks.c **** 					/* Search the deleted list. */
2313:../freertos/tasks.c **** 					pxTCB = prvSearchForNameWithinSingleList( &xTasksWaitingTermination, pcNameToQuery );
2314:../freertos/tasks.c **** 				}
2315:../freertos/tasks.c **** 			}
2316:../freertos/tasks.c **** 			#endif
2317:../freertos/tasks.c **** 		}
2318:../freertos/tasks.c **** 		( void ) xTaskResumeAll();
2319:../freertos/tasks.c **** 
2320:../freertos/tasks.c **** 		return ( TaskHandle_t ) pxTCB;
2321:../freertos/tasks.c **** 	}
2322:../freertos/tasks.c **** 
2323:../freertos/tasks.c **** #endif /* INCLUDE_xTaskGetHandle */
2324:../freertos/tasks.c **** /*-----------------------------------------------------------*/
2325:../freertos/tasks.c **** 
2326:../freertos/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2327:../freertos/tasks.c **** 
2328:../freertos/tasks.c **** 	UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArra
2329:../freertos/tasks.c **** 	{
 2431              		.loc 1 2329 0
 2432              		.cfi_startproc
 2433 0000 80B5     		push	{r7, lr}
 2434              		.cfi_def_cfa_offset 8
 2435              		.cfi_offset 7, -8
 2436              		.cfi_offset 14, -4
 2437 0002 86B0     		sub	sp, sp, #24
 2438              		.cfi_def_cfa_offset 32
 2439 0004 00AF     		add	r7, sp, #0
 2440              		.cfi_def_cfa_register 7
 2441 0006 F860     		str	r0, [r7, #12]
 2442 0008 B960     		str	r1, [r7, #8]
 2443 000a 7A60     		str	r2, [r7, #4]
2330:../freertos/tasks.c **** 	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
 2444              		.loc 1 2330 0
 2445 000c 0023     		mov	r3, #0
 2446 000e 7B61     		str	r3, [r7, #20]
 2447 0010 0523     		mov	r3, #5
 2448 0012 3B61     		str	r3, [r7, #16]
2331:../freertos/tasks.c **** 
2332:../freertos/tasks.c **** 		vTaskSuspendAll();
 2449              		.loc 1 2332 0
 2450 0014 FFF7FEFF 		bl	vTaskSuspendAll
2333:../freertos/tasks.c **** 		{
2334:../freertos/tasks.c **** 			/* Is there a space in the array for each task in the system? */
2335:../freertos/tasks.c **** 			if( uxArraySize >= uxCurrentNumberOfTasks )
 2451              		.loc 1 2335 0
 2452 0018 3A4B     		ldr	r3, .L200
 2453 001a 1B68     		ldr	r3, [r3]
 2454 001c BA68     		ldr	r2, [r7, #8]
 2455 001e 9A42     		cmp	r2, r3
 2456 0020 68D3     		bcc	.L196
 2457              	.L197:
2336:../freertos/tasks.c **** 			{
2337:../freertos/tasks.c **** 				/* Fill in an TaskStatus_t structure with information on each
2338:../freertos/tasks.c **** 				task in the Ready state. */
2339:../freertos/tasks.c **** 				do
2340:../freertos/tasks.c **** 				{
2341:../freertos/tasks.c **** 					uxQueue--;
 2458              		.loc 1 2341 0 discriminator 1
 2459 0022 3B69     		ldr	r3, [r7, #16]
 2460 0024 013B     		sub	r3, r3, #1
 2461 0026 3B61     		str	r3, [r7, #16]
2342:../freertos/tasks.c **** 					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists
 2462              		.loc 1 2342 0 discriminator 1
 2463 0028 7A69     		ldr	r2, [r7, #20]
 2464 002a 131C     		mov	r3, r2
 2465 002c DB00     		lsl	r3, r3, #3
 2466 002e 9B18     		add	r3, r3, r2
 2467 0030 9B00     		lsl	r3, r3, #2
 2468 0032 FA68     		ldr	r2, [r7, #12]
 2469 0034 D118     		add	r1, r2, r3
 2470 0036 3A69     		ldr	r2, [r7, #16]
 2471 0038 131C     		mov	r3, r2
 2472 003a 9B00     		lsl	r3, r3, #2
 2473 003c 9B18     		add	r3, r3, r2
 2474 003e 9B00     		lsl	r3, r3, #2
 2475 0040 314A     		ldr	r2, .L200+4
 2476 0042 9B18     		add	r3, r3, r2
 2477 0044 081C     		mov	r0, r1
 2478 0046 191C     		mov	r1, r3
 2479 0048 0122     		mov	r2, #1
 2480 004a FFF7FEFF 		bl	prvListTasksWithinSingleList
 2481 004e 031C     		mov	r3, r0
 2482 0050 7A69     		ldr	r2, [r7, #20]
 2483 0052 D318     		add	r3, r2, r3
 2484 0054 7B61     		str	r3, [r7, #20]
2343:../freertos/tasks.c **** 
2344:../freertos/tasks.c **** 				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the cast
 2485              		.loc 1 2344 0 discriminator 1
 2486 0056 3B69     		ldr	r3, [r7, #16]
 2487 0058 002B     		cmp	r3, #0
 2488 005a E2D1     		bne	.L197
2345:../freertos/tasks.c **** 
2346:../freertos/tasks.c **** 				/* Fill in an TaskStatus_t structure with information on each
2347:../freertos/tasks.c **** 				task in the Blocked state. */
2348:../freertos/tasks.c **** 				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelaye
 2489              		.loc 1 2348 0
 2490 005c 7A69     		ldr	r2, [r7, #20]
 2491 005e 131C     		mov	r3, r2
 2492 0060 DB00     		lsl	r3, r3, #3
 2493 0062 9B18     		add	r3, r3, r2
 2494 0064 9B00     		lsl	r3, r3, #2
 2495 0066 FA68     		ldr	r2, [r7, #12]
 2496 0068 D218     		add	r2, r2, r3
 2497 006a 284B     		ldr	r3, .L200+8
 2498 006c 1B68     		ldr	r3, [r3]
 2499 006e 101C     		mov	r0, r2
 2500 0070 191C     		mov	r1, r3
 2501 0072 0222     		mov	r2, #2
 2502 0074 FFF7FEFF 		bl	prvListTasksWithinSingleList
 2503 0078 031C     		mov	r3, r0
 2504 007a 7A69     		ldr	r2, [r7, #20]
 2505 007c D318     		add	r3, r2, r3
 2506 007e 7B61     		str	r3, [r7, #20]
2349:../freertos/tasks.c **** 				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverfl
 2507              		.loc 1 2349 0
 2508 0080 7A69     		ldr	r2, [r7, #20]
 2509 0082 131C     		mov	r3, r2
 2510 0084 DB00     		lsl	r3, r3, #3
 2511 0086 9B18     		add	r3, r3, r2
 2512 0088 9B00     		lsl	r3, r3, #2
 2513 008a FA68     		ldr	r2, [r7, #12]
 2514 008c D218     		add	r2, r2, r3
 2515 008e 204B     		ldr	r3, .L200+12
 2516 0090 1B68     		ldr	r3, [r3]
 2517 0092 101C     		mov	r0, r2
 2518 0094 191C     		mov	r1, r3
 2519 0096 0222     		mov	r2, #2
 2520 0098 FFF7FEFF 		bl	prvListTasksWithinSingleList
 2521 009c 031C     		mov	r3, r0
 2522 009e 7A69     		ldr	r2, [r7, #20]
 2523 00a0 D318     		add	r3, r2, r3
 2524 00a2 7B61     		str	r3, [r7, #20]
2350:../freertos/tasks.c **** 
2351:../freertos/tasks.c **** 				#if( INCLUDE_vTaskDelete == 1 )
2352:../freertos/tasks.c **** 				{
2353:../freertos/tasks.c **** 					/* Fill in an TaskStatus_t structure with information on
2354:../freertos/tasks.c **** 					each task that has been deleted but not yet cleaned up. */
2355:../freertos/tasks.c **** 					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermin
 2525              		.loc 1 2355 0
 2526 00a4 7A69     		ldr	r2, [r7, #20]
 2527 00a6 131C     		mov	r3, r2
 2528 00a8 DB00     		lsl	r3, r3, #3
 2529 00aa 9B18     		add	r3, r3, r2
 2530 00ac 9B00     		lsl	r3, r3, #2
 2531 00ae FA68     		ldr	r2, [r7, #12]
 2532 00b0 D218     		add	r2, r2, r3
 2533 00b2 184B     		ldr	r3, .L200+16
 2534 00b4 101C     		mov	r0, r2
 2535 00b6 191C     		mov	r1, r3
 2536 00b8 0422     		mov	r2, #4
 2537 00ba FFF7FEFF 		bl	prvListTasksWithinSingleList
 2538 00be 031C     		mov	r3, r0
 2539 00c0 7A69     		ldr	r2, [r7, #20]
 2540 00c2 D318     		add	r3, r2, r3
 2541 00c4 7B61     		str	r3, [r7, #20]
2356:../freertos/tasks.c **** 				}
2357:../freertos/tasks.c **** 				#endif
2358:../freertos/tasks.c **** 
2359:../freertos/tasks.c **** 				#if ( INCLUDE_vTaskSuspend == 1 )
2360:../freertos/tasks.c **** 				{
2361:../freertos/tasks.c **** 					/* Fill in an TaskStatus_t structure with information on
2362:../freertos/tasks.c **** 					each task in the Suspended state. */
2363:../freertos/tasks.c **** 					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList,
 2542              		.loc 1 2363 0
 2543 00c6 7A69     		ldr	r2, [r7, #20]
 2544 00c8 131C     		mov	r3, r2
 2545 00ca DB00     		lsl	r3, r3, #3
 2546 00cc 9B18     		add	r3, r3, r2
 2547 00ce 9B00     		lsl	r3, r3, #2
 2548 00d0 FA68     		ldr	r2, [r7, #12]
 2549 00d2 D218     		add	r2, r2, r3
 2550 00d4 104B     		ldr	r3, .L200+20
 2551 00d6 101C     		mov	r0, r2
 2552 00d8 191C     		mov	r1, r3
 2553 00da 0322     		mov	r2, #3
 2554 00dc FFF7FEFF 		bl	prvListTasksWithinSingleList
 2555 00e0 031C     		mov	r3, r0
 2556 00e2 7A69     		ldr	r2, [r7, #20]
 2557 00e4 D318     		add	r3, r2, r3
 2558 00e6 7B61     		str	r3, [r7, #20]
2364:../freertos/tasks.c **** 				}
2365:../freertos/tasks.c **** 				#endif
2366:../freertos/tasks.c **** 
2367:../freertos/tasks.c **** 				#if ( configGENERATE_RUN_TIME_STATS == 1)
2368:../freertos/tasks.c **** 				{
2369:../freertos/tasks.c **** 					if( pulTotalRunTime != NULL )
2370:../freertos/tasks.c **** 					{
2371:../freertos/tasks.c **** 						#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
2372:../freertos/tasks.c **** 							portALT_GET_RUN_TIME_COUNTER_VALUE( ( *pulTotalRunTime ) );
2373:../freertos/tasks.c **** 						#else
2374:../freertos/tasks.c **** 							*pulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
2375:../freertos/tasks.c **** 						#endif
2376:../freertos/tasks.c **** 					}
2377:../freertos/tasks.c **** 				}
2378:../freertos/tasks.c **** 				#else
2379:../freertos/tasks.c **** 				{
2380:../freertos/tasks.c **** 					if( pulTotalRunTime != NULL )
 2559              		.loc 1 2380 0
 2560 00e8 7B68     		ldr	r3, [r7, #4]
 2561 00ea 002B     		cmp	r3, #0
 2562 00ec 02D0     		beq	.L196
2381:../freertos/tasks.c **** 					{
2382:../freertos/tasks.c **** 						*pulTotalRunTime = 0;
 2563              		.loc 1 2382 0
 2564 00ee 7B68     		ldr	r3, [r7, #4]
 2565 00f0 0022     		mov	r2, #0
 2566 00f2 1A60     		str	r2, [r3]
 2567              	.L196:
2383:../freertos/tasks.c **** 					}
2384:../freertos/tasks.c **** 				}
2385:../freertos/tasks.c **** 				#endif
2386:../freertos/tasks.c **** 			}
2387:../freertos/tasks.c **** 			else
2388:../freertos/tasks.c **** 			{
2389:../freertos/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2390:../freertos/tasks.c **** 			}
2391:../freertos/tasks.c **** 		}
2392:../freertos/tasks.c **** 		( void ) xTaskResumeAll();
 2568              		.loc 1 2392 0
 2569 00f4 FFF7FEFF 		bl	xTaskResumeAll
2393:../freertos/tasks.c **** 
2394:../freertos/tasks.c **** 		return uxTask;
 2570              		.loc 1 2394 0
 2571 00f8 7B69     		ldr	r3, [r7, #20]
2395:../freertos/tasks.c **** 	}
 2572              		.loc 1 2395 0
 2573 00fa 181C     		mov	r0, r3
 2574 00fc BD46     		mov	sp, r7
 2575 00fe 06B0     		add	sp, sp, #24
 2576              		@ sp needed
 2577 0100 80BD     		pop	{r7, pc}
 2578              	.L201:
 2579 0102 C046     		.align	2
 2580              	.L200:
 2581 0104 00000000 		.word	uxCurrentNumberOfTasks
 2582 0108 00000000 		.word	pxReadyTasksLists
 2583 010c 00000000 		.word	pxDelayedTaskList
 2584 0110 00000000 		.word	pxOverflowDelayedTaskList
 2585 0114 00000000 		.word	xTasksWaitingTermination
 2586 0118 00000000 		.word	xSuspendedTaskList
 2587              		.cfi_endproc
 2588              	.LFE22:
 2590              		.section	.text.xTaskIncrementTick,"ax",%progbits
 2591              		.align	2
 2592              		.global	xTaskIncrementTick
 2593              		.code	16
 2594              		.thumb_func
 2596              	xTaskIncrementTick:
 2597              	.LFB23:
2396:../freertos/tasks.c **** 
2397:../freertos/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
2398:../freertos/tasks.c **** /*----------------------------------------------------------*/
2399:../freertos/tasks.c **** 
2400:../freertos/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
2401:../freertos/tasks.c **** 
2402:../freertos/tasks.c **** 	TaskHandle_t xTaskGetIdleTaskHandle( void )
2403:../freertos/tasks.c **** 	{
2404:../freertos/tasks.c **** 		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
2405:../freertos/tasks.c **** 		started, then xIdleTaskHandle will be NULL. */
2406:../freertos/tasks.c **** 		configASSERT( ( xIdleTaskHandle != NULL ) );
2407:../freertos/tasks.c **** 		return xIdleTaskHandle;
2408:../freertos/tasks.c **** 	}
2409:../freertos/tasks.c **** 
2410:../freertos/tasks.c **** #endif /* INCLUDE_xTaskGetIdleTaskHandle */
2411:../freertos/tasks.c **** /*----------------------------------------------------------*/
2412:../freertos/tasks.c **** 
2413:../freertos/tasks.c **** /* This conditional compilation should use inequality to 0, not equality to 1.
2414:../freertos/tasks.c **** This is to ensure vTaskStepTick() is available when user defined low power mode
2415:../freertos/tasks.c **** implementations require configUSE_TICKLESS_IDLE to be set to a value other than
2416:../freertos/tasks.c **** 1. */
2417:../freertos/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
2418:../freertos/tasks.c **** 
2419:../freertos/tasks.c **** 	void vTaskStepTick( const TickType_t xTicksToJump )
2420:../freertos/tasks.c **** 	{
2421:../freertos/tasks.c **** 		/* Correct the tick count value after a period during which the tick
2422:../freertos/tasks.c **** 		was suppressed.  Note this does *not* call the tick hook function for
2423:../freertos/tasks.c **** 		each stepped tick. */
2424:../freertos/tasks.c **** 		configASSERT( ( xTickCount + xTicksToJump ) <= xNextTaskUnblockTime );
2425:../freertos/tasks.c **** 		xTickCount += xTicksToJump;
2426:../freertos/tasks.c **** 		traceINCREASE_TICK_COUNT( xTicksToJump );
2427:../freertos/tasks.c **** 	}
2428:../freertos/tasks.c **** 
2429:../freertos/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
2430:../freertos/tasks.c **** /*----------------------------------------------------------*/
2431:../freertos/tasks.c **** 
2432:../freertos/tasks.c **** #if ( INCLUDE_xTaskAbortDelay == 1 )
2433:../freertos/tasks.c **** 
2434:../freertos/tasks.c **** 	BaseType_t xTaskAbortDelay( TaskHandle_t xTask )
2435:../freertos/tasks.c **** 	{
2436:../freertos/tasks.c **** 	TCB_t *pxTCB = ( TCB_t * ) xTask;
2437:../freertos/tasks.c **** 	BaseType_t xReturn = pdFALSE;
2438:../freertos/tasks.c **** 
2439:../freertos/tasks.c **** 		configASSERT( pxTCB );
2440:../freertos/tasks.c **** 
2441:../freertos/tasks.c **** 		vTaskSuspendAll();
2442:../freertos/tasks.c **** 		{
2443:../freertos/tasks.c **** 			/* A task can only be prematurely removed from the Blocked state if
2444:../freertos/tasks.c **** 			it is actually in the Blocked state. */
2445:../freertos/tasks.c **** 			if( eTaskGetState( xTask ) == eBlocked )
2446:../freertos/tasks.c **** 			{
2447:../freertos/tasks.c **** 				/* Remove the reference to the task from the blocked list.  An
2448:../freertos/tasks.c **** 				interrupt won't touch the xStateListItem because the
2449:../freertos/tasks.c **** 				scheduler is suspended. */
2450:../freertos/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
2451:../freertos/tasks.c **** 
2452:../freertos/tasks.c **** 				/* Is the task waiting on an event also?  If so remove it from
2453:../freertos/tasks.c **** 				the event list too.  Interrupts can touch the event list item,
2454:../freertos/tasks.c **** 				even though the scheduler is suspended, so a critical section
2455:../freertos/tasks.c **** 				is used. */
2456:../freertos/tasks.c **** 				taskENTER_CRITICAL();
2457:../freertos/tasks.c **** 				{
2458:../freertos/tasks.c **** 					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
2459:../freertos/tasks.c **** 					{
2460:../freertos/tasks.c **** 						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
2461:../freertos/tasks.c **** 						pxTCB->ucDelayAborted = pdTRUE;
2462:../freertos/tasks.c **** 					}
2463:../freertos/tasks.c **** 					else
2464:../freertos/tasks.c **** 					{
2465:../freertos/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2466:../freertos/tasks.c **** 					}
2467:../freertos/tasks.c **** 				}
2468:../freertos/tasks.c **** 				taskEXIT_CRITICAL();
2469:../freertos/tasks.c **** 
2470:../freertos/tasks.c **** 				/* Place the unblocked task into the appropriate ready list. */
2471:../freertos/tasks.c **** 				prvAddTaskToReadyList( pxTCB );
2472:../freertos/tasks.c **** 
2473:../freertos/tasks.c **** 				/* A task being unblocked cannot cause an immediate context
2474:../freertos/tasks.c **** 				switch if preemption is turned off. */
2475:../freertos/tasks.c **** 				#if (  configUSE_PREEMPTION == 1 )
2476:../freertos/tasks.c **** 				{
2477:../freertos/tasks.c **** 					/* Preemption is on, but a context switch should only be
2478:../freertos/tasks.c **** 					performed if the unblocked task has a priority that is
2479:../freertos/tasks.c **** 					equal to or higher than the currently executing task. */
2480:../freertos/tasks.c **** 					if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
2481:../freertos/tasks.c **** 					{
2482:../freertos/tasks.c **** 						/* Pend the yield to be performed when the scheduler
2483:../freertos/tasks.c **** 						is unsuspended. */
2484:../freertos/tasks.c **** 						xYieldPending = pdTRUE;
2485:../freertos/tasks.c **** 					}
2486:../freertos/tasks.c **** 					else
2487:../freertos/tasks.c **** 					{
2488:../freertos/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2489:../freertos/tasks.c **** 					}
2490:../freertos/tasks.c **** 				}
2491:../freertos/tasks.c **** 				#endif /* configUSE_PREEMPTION */
2492:../freertos/tasks.c **** 			}
2493:../freertos/tasks.c **** 			else
2494:../freertos/tasks.c **** 			{
2495:../freertos/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2496:../freertos/tasks.c **** 			}
2497:../freertos/tasks.c **** 		}
2498:../freertos/tasks.c **** 		xTaskResumeAll();
2499:../freertos/tasks.c **** 
2500:../freertos/tasks.c **** 		return xReturn;
2501:../freertos/tasks.c **** 	}
2502:../freertos/tasks.c **** 
2503:../freertos/tasks.c **** #endif /* INCLUDE_xTaskAbortDelay */
2504:../freertos/tasks.c **** /*----------------------------------------------------------*/
2505:../freertos/tasks.c **** 
2506:../freertos/tasks.c **** BaseType_t xTaskIncrementTick( void )
2507:../freertos/tasks.c **** {
 2598              		.loc 1 2507 0
 2599              		.cfi_startproc
 2600 0000 80B5     		push	{r7, lr}
 2601              		.cfi_def_cfa_offset 8
 2602              		.cfi_offset 7, -8
 2603              		.cfi_offset 14, -4
 2604 0002 86B0     		sub	sp, sp, #24
 2605              		.cfi_def_cfa_offset 32
 2606 0004 00AF     		add	r7, sp, #0
 2607              		.cfi_def_cfa_register 7
2508:../freertos/tasks.c **** TCB_t * pxTCB;
2509:../freertos/tasks.c **** TickType_t xItemValue;
2510:../freertos/tasks.c **** BaseType_t xSwitchRequired = pdFALSE;
 2608              		.loc 1 2510 0
 2609 0006 0023     		mov	r3, #0
 2610 0008 7B61     		str	r3, [r7, #20]
2511:../freertos/tasks.c **** 
2512:../freertos/tasks.c **** 	/* Called by the portable layer each time a tick interrupt occurs.
2513:../freertos/tasks.c **** 	Increments the tick then checks to see if the new tick value will cause any
2514:../freertos/tasks.c **** 	tasks to be unblocked. */
2515:../freertos/tasks.c **** 	traceTASK_INCREMENT_TICK( xTickCount );
2516:../freertos/tasks.c **** 	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 2611              		.loc 1 2516 0
 2612 000a 464B     		ldr	r3, .L219
 2613 000c 1B68     		ldr	r3, [r3]
 2614 000e 002B     		cmp	r3, #0
 2615 0010 00D0     		beq	.LCB2184
 2616 0012 76E0     		b	.L203	@long jump
 2617              	.LCB2184:
 2618              	.LBB5:
2517:../freertos/tasks.c **** 	{
2518:../freertos/tasks.c **** 		/* Minor optimisation.  The tick count cannot change in this
2519:../freertos/tasks.c **** 		block. */
2520:../freertos/tasks.c **** 		const TickType_t xConstTickCount = xTickCount + 1;
 2619              		.loc 1 2520 0
 2620 0014 444B     		ldr	r3, .L219+4
 2621 0016 1B68     		ldr	r3, [r3]
 2622 0018 0133     		add	r3, r3, #1
 2623 001a 3B61     		str	r3, [r7, #16]
2521:../freertos/tasks.c **** 
2522:../freertos/tasks.c **** 		/* Increment the RTOS tick, switching the delayed and overflowed
2523:../freertos/tasks.c **** 		delayed lists if it wraps to 0. */
2524:../freertos/tasks.c **** 		xTickCount = xConstTickCount;
 2624              		.loc 1 2524 0
 2625 001c 424B     		ldr	r3, .L219+4
 2626 001e 3A69     		ldr	r2, [r7, #16]
 2627 0020 1A60     		str	r2, [r3]
2525:../freertos/tasks.c **** 
2526:../freertos/tasks.c **** 		if( xConstTickCount == ( TickType_t ) 0U )
 2628              		.loc 1 2526 0
 2629 0022 3B69     		ldr	r3, [r7, #16]
 2630 0024 002B     		cmp	r3, #0
 2631 0026 17D1     		bne	.L204
 2632              	.LBB6:
2527:../freertos/tasks.c **** 		{
2528:../freertos/tasks.c **** 			taskSWITCH_DELAYED_LISTS();
 2633              		.loc 1 2528 0
 2634 0028 404B     		ldr	r3, .L219+8
 2635 002a 1B68     		ldr	r3, [r3]
 2636 002c 1B68     		ldr	r3, [r3]
 2637 002e 002B     		cmp	r3, #0
 2638 0030 01D0     		beq	.L205
 2639              		.loc 1 2528 0 is_stmt 0 discriminator 1
 2640              	@ 2528 "../freertos/tasks.c" 1
 2641 0032 72B6     		 cpsid i 
 2642              	@ 0 "" 2
 2643              		.code	16
 2644              	.L206:
 2645 0034 FEE7     		b	.L206
 2646              	.L205:
 2647              		.loc 1 2528 0 discriminator 2
 2648 0036 3D4B     		ldr	r3, .L219+8
 2649 0038 1B68     		ldr	r3, [r3]
 2650 003a FB60     		str	r3, [r7, #12]
 2651 003c 3C4B     		ldr	r3, .L219+12
 2652 003e 1A68     		ldr	r2, [r3]
 2653 0040 3A4B     		ldr	r3, .L219+8
 2654 0042 1A60     		str	r2, [r3]
 2655 0044 3A4B     		ldr	r3, .L219+12
 2656 0046 FA68     		ldr	r2, [r7, #12]
 2657 0048 1A60     		str	r2, [r3]
 2658 004a 3A4B     		ldr	r3, .L219+16
 2659 004c 1B68     		ldr	r3, [r3]
 2660 004e 5A1C     		add	r2, r3, #1
 2661 0050 384B     		ldr	r3, .L219+16
 2662 0052 1A60     		str	r2, [r3]
 2663 0054 FFF7FEFF 		bl	prvResetNextTaskUnblockTime
 2664              	.L204:
 2665              	.LBE6:
2529:../freertos/tasks.c **** 		}
2530:../freertos/tasks.c **** 		else
2531:../freertos/tasks.c **** 		{
2532:../freertos/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2533:../freertos/tasks.c **** 		}
2534:../freertos/tasks.c **** 
2535:../freertos/tasks.c **** 		/* See if this tick has made a timeout expire.  Tasks are stored in
2536:../freertos/tasks.c **** 		the	queue in the order of their wake time - meaning once one task
2537:../freertos/tasks.c **** 		has been found whose block time has not expired there is no need to
2538:../freertos/tasks.c **** 		look any further down the list. */
2539:../freertos/tasks.c **** 		if( xConstTickCount >= xNextTaskUnblockTime )
 2666              		.loc 1 2539 0 is_stmt 1
 2667 0058 374B     		ldr	r3, .L219+20
 2668 005a 1B68     		ldr	r3, [r3]
 2669 005c 3A69     		ldr	r2, [r7, #16]
 2670 005e 9A42     		cmp	r2, r3
 2671 0060 4ED3     		bcc	.L207
 2672              	.L215:
2540:../freertos/tasks.c **** 		{
2541:../freertos/tasks.c **** 			for( ;; )
2542:../freertos/tasks.c **** 			{
2543:../freertos/tasks.c **** 				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 2673              		.loc 1 2543 0
 2674 0062 324B     		ldr	r3, .L219+8
 2675 0064 1B68     		ldr	r3, [r3]
 2676 0066 1B68     		ldr	r3, [r3]
 2677 0068 002B     		cmp	r3, #0
 2678 006a 01D1     		bne	.L208
 2679              		.loc 1 2543 0 is_stmt 0 discriminator 1
 2680 006c 0123     		mov	r3, #1
 2681 006e 00E0     		b	.L209
 2682              	.L208:
 2683              		.loc 1 2543 0 discriminator 2
 2684 0070 0023     		mov	r3, #0
 2685              	.L209:
 2686              		.loc 1 2543 0 discriminator 3
 2687 0072 002B     		cmp	r3, #0
 2688 0074 04D0     		beq	.L210
2544:../freertos/tasks.c **** 				{
2545:../freertos/tasks.c **** 					/* The delayed list is empty.  Set xNextTaskUnblockTime
2546:../freertos/tasks.c **** 					to the maximum possible value so it is extremely
2547:../freertos/tasks.c **** 					unlikely that the
2548:../freertos/tasks.c **** 					if( xTickCount >= xNextTaskUnblockTime ) test will pass
2549:../freertos/tasks.c **** 					next time through. */
2550:../freertos/tasks.c **** 					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redun
 2689              		.loc 1 2550 0 is_stmt 1
 2690 0076 304B     		ldr	r3, .L219+20
 2691 0078 0122     		mov	r2, #1
 2692 007a 5242     		neg	r2, r2
 2693 007c 1A60     		str	r2, [r3]
2551:../freertos/tasks.c **** 					break;
 2694              		.loc 1 2551 0
 2695 007e 3FE0     		b	.L207
 2696              	.L210:
2552:../freertos/tasks.c **** 				}
2553:../freertos/tasks.c **** 				else
2554:../freertos/tasks.c **** 				{
2555:../freertos/tasks.c **** 					/* The delayed list is not empty, get the value of the
2556:../freertos/tasks.c **** 					item at the head of the delayed list.  This is the time
2557:../freertos/tasks.c **** 					at which the task at the head of the delayed list must
2558:../freertos/tasks.c **** 					be removed from the Blocked state. */
2559:../freertos/tasks.c **** 					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 2697              		.loc 1 2559 0
 2698 0080 2A4B     		ldr	r3, .L219+8
 2699 0082 1B68     		ldr	r3, [r3]
 2700 0084 DB68     		ldr	r3, [r3, #12]
 2701 0086 DB68     		ldr	r3, [r3, #12]
 2702 0088 BB60     		str	r3, [r7, #8]
2560:../freertos/tasks.c **** 					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 2703              		.loc 1 2560 0
 2704 008a BB68     		ldr	r3, [r7, #8]
 2705 008c 5B68     		ldr	r3, [r3, #4]
 2706 008e 7B60     		str	r3, [r7, #4]
2561:../freertos/tasks.c **** 
2562:../freertos/tasks.c **** 					if( xConstTickCount < xItemValue )
 2707              		.loc 1 2562 0
 2708 0090 3A69     		ldr	r2, [r7, #16]
 2709 0092 7B68     		ldr	r3, [r7, #4]
 2710 0094 9A42     		cmp	r2, r3
 2711 0096 03D2     		bcs	.L211
2563:../freertos/tasks.c **** 					{
2564:../freertos/tasks.c **** 						/* It is not time to unblock this item yet, but the
2565:../freertos/tasks.c **** 						item value is the time at which the task at the head
2566:../freertos/tasks.c **** 						of the blocked list must be removed from the Blocked
2567:../freertos/tasks.c **** 						state -	so record the item value in
2568:../freertos/tasks.c **** 						xNextTaskUnblockTime. */
2569:../freertos/tasks.c **** 						xNextTaskUnblockTime = xItemValue;
 2712              		.loc 1 2569 0
 2713 0098 274B     		ldr	r3, .L219+20
 2714 009a 7A68     		ldr	r2, [r7, #4]
 2715 009c 1A60     		str	r2, [r3]
2570:../freertos/tasks.c **** 						break;
 2716              		.loc 1 2570 0
 2717 009e 2FE0     		b	.L207
 2718              	.L211:
2571:../freertos/tasks.c **** 					}
2572:../freertos/tasks.c **** 					else
2573:../freertos/tasks.c **** 					{
2574:../freertos/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2575:../freertos/tasks.c **** 					}
2576:../freertos/tasks.c **** 
2577:../freertos/tasks.c **** 					/* It is time to remove the item from the Blocked state. */
2578:../freertos/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 2719              		.loc 1 2578 0
 2720 00a0 BB68     		ldr	r3, [r7, #8]
 2721 00a2 0433     		add	r3, r3, #4
 2722 00a4 181C     		mov	r0, r3
 2723 00a6 FFF7FEFF 		bl	uxListRemove
2579:../freertos/tasks.c **** 
2580:../freertos/tasks.c **** 					/* Is the task waiting on an event also?  If so remove
2581:../freertos/tasks.c **** 					it from the event list. */
2582:../freertos/tasks.c **** 					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 2724              		.loc 1 2582 0
 2725 00aa BB68     		ldr	r3, [r7, #8]
 2726 00ac 9B6A     		ldr	r3, [r3, #40]
 2727 00ae 002B     		cmp	r3, #0
 2728 00b0 04D0     		beq	.L212
2583:../freertos/tasks.c **** 					{
2584:../freertos/tasks.c **** 						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 2729              		.loc 1 2584 0
 2730 00b2 BB68     		ldr	r3, [r7, #8]
 2731 00b4 1833     		add	r3, r3, #24
 2732 00b6 181C     		mov	r0, r3
 2733 00b8 FFF7FEFF 		bl	uxListRemove
 2734              	.L212:
2585:../freertos/tasks.c **** 					}
2586:../freertos/tasks.c **** 					else
2587:../freertos/tasks.c **** 					{
2588:../freertos/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2589:../freertos/tasks.c **** 					}
2590:../freertos/tasks.c **** 
2591:../freertos/tasks.c **** 					/* Place the unblocked task into the appropriate ready
2592:../freertos/tasks.c **** 					list. */
2593:../freertos/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 2735              		.loc 1 2593 0
 2736 00bc BB68     		ldr	r3, [r7, #8]
 2737 00be DA6A     		ldr	r2, [r3, #44]
 2738 00c0 1E4B     		ldr	r3, .L219+24
 2739 00c2 1B68     		ldr	r3, [r3]
 2740 00c4 9A42     		cmp	r2, r3
 2741 00c6 03D9     		bls	.L213
 2742              		.loc 1 2593 0 is_stmt 0 discriminator 1
 2743 00c8 BB68     		ldr	r3, [r7, #8]
 2744 00ca DA6A     		ldr	r2, [r3, #44]
 2745 00cc 1B4B     		ldr	r3, .L219+24
 2746 00ce 1A60     		str	r2, [r3]
 2747              	.L213:
 2748              		.loc 1 2593 0 discriminator 2
 2749 00d0 BB68     		ldr	r3, [r7, #8]
 2750 00d2 DA6A     		ldr	r2, [r3, #44]
 2751 00d4 131C     		mov	r3, r2
 2752 00d6 9B00     		lsl	r3, r3, #2
 2753 00d8 9B18     		add	r3, r3, r2
 2754 00da 9B00     		lsl	r3, r3, #2
 2755 00dc 184A     		ldr	r2, .L219+28
 2756 00de 9A18     		add	r2, r3, r2
 2757 00e0 BB68     		ldr	r3, [r7, #8]
 2758 00e2 0433     		add	r3, r3, #4
 2759 00e4 101C     		mov	r0, r2
 2760 00e6 191C     		mov	r1, r3
 2761 00e8 FFF7FEFF 		bl	vListInsertEnd
2594:../freertos/tasks.c **** 
2595:../freertos/tasks.c **** 					/* A task being unblocked cannot cause an immediate
2596:../freertos/tasks.c **** 					context switch if preemption is turned off. */
2597:../freertos/tasks.c **** 					#if (  configUSE_PREEMPTION == 1 )
2598:../freertos/tasks.c **** 					{
2599:../freertos/tasks.c **** 						/* Preemption is on, but a context switch should
2600:../freertos/tasks.c **** 						only be performed if the unblocked task has a
2601:../freertos/tasks.c **** 						priority that is equal to or higher than the
2602:../freertos/tasks.c **** 						currently executing task. */
2603:../freertos/tasks.c **** 						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 2762              		.loc 1 2603 0 is_stmt 1 discriminator 2
 2763 00ec BB68     		ldr	r3, [r7, #8]
 2764 00ee DA6A     		ldr	r2, [r3, #44]
 2765 00f0 144B     		ldr	r3, .L219+32
 2766 00f2 1B68     		ldr	r3, [r3]
 2767 00f4 DB6A     		ldr	r3, [r3, #44]
 2768 00f6 9A42     		cmp	r2, r3
 2769 00f8 01D3     		bcc	.L214
2604:../freertos/tasks.c **** 						{
2605:../freertos/tasks.c **** 							xSwitchRequired = pdTRUE;
 2770              		.loc 1 2605 0
 2771 00fa 0123     		mov	r3, #1
 2772 00fc 7B61     		str	r3, [r7, #20]
 2773              	.L214:
2606:../freertos/tasks.c **** 						}
2607:../freertos/tasks.c **** 						else
2608:../freertos/tasks.c **** 						{
2609:../freertos/tasks.c **** 							mtCOVERAGE_TEST_MARKER();
2610:../freertos/tasks.c **** 						}
2611:../freertos/tasks.c **** 					}
2612:../freertos/tasks.c **** 					#endif /* configUSE_PREEMPTION */
2613:../freertos/tasks.c **** 				}
2614:../freertos/tasks.c **** 			}
 2774              		.loc 1 2614 0
 2775 00fe B0E7     		b	.L215
 2776              	.L207:
 2777              	.LBE5:
 2778 0100 04E0     		b	.L216
 2779              	.L203:
2615:../freertos/tasks.c **** 		}
2616:../freertos/tasks.c **** 
2617:../freertos/tasks.c **** 		/* Tasks of equal priority to the currently running task will share
2618:../freertos/tasks.c **** 		processing time (time slice) if preemption is on, and the application
2619:../freertos/tasks.c **** 		writer has not explicitly turned time slicing off. */
2620:../freertos/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
2621:../freertos/tasks.c **** 		{
2622:../freertos/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_
2623:../freertos/tasks.c **** 			{
2624:../freertos/tasks.c **** 				xSwitchRequired = pdTRUE;
2625:../freertos/tasks.c **** 			}
2626:../freertos/tasks.c **** 			else
2627:../freertos/tasks.c **** 			{
2628:../freertos/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2629:../freertos/tasks.c **** 			}
2630:../freertos/tasks.c **** 		}
2631:../freertos/tasks.c **** 		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
2632:../freertos/tasks.c **** 
2633:../freertos/tasks.c **** 		#if ( configUSE_TICK_HOOK == 1 )
2634:../freertos/tasks.c **** 		{
2635:../freertos/tasks.c **** 			/* Guard against the tick hook being called when the pended tick
2636:../freertos/tasks.c **** 			count is being unwound (when the scheduler is being unlocked). */
2637:../freertos/tasks.c **** 			if( uxPendedTicks == ( UBaseType_t ) 0U )
2638:../freertos/tasks.c **** 			{
2639:../freertos/tasks.c **** 				vApplicationTickHook();
2640:../freertos/tasks.c **** 			}
2641:../freertos/tasks.c **** 			else
2642:../freertos/tasks.c **** 			{
2643:../freertos/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2644:../freertos/tasks.c **** 			}
2645:../freertos/tasks.c **** 		}
2646:../freertos/tasks.c **** 		#endif /* configUSE_TICK_HOOK */
2647:../freertos/tasks.c **** 	}
2648:../freertos/tasks.c **** 	else
2649:../freertos/tasks.c **** 	{
2650:../freertos/tasks.c **** 		++uxPendedTicks;
 2780              		.loc 1 2650 0
 2781 0102 114B     		ldr	r3, .L219+36
 2782 0104 1B68     		ldr	r3, [r3]
 2783 0106 5A1C     		add	r2, r3, #1
 2784 0108 0F4B     		ldr	r3, .L219+36
 2785 010a 1A60     		str	r2, [r3]
 2786              	.L216:
2651:../freertos/tasks.c **** 
2652:../freertos/tasks.c **** 		/* The tick hook gets called at regular intervals, even if the
2653:../freertos/tasks.c **** 		scheduler is locked. */
2654:../freertos/tasks.c **** 		#if ( configUSE_TICK_HOOK == 1 )
2655:../freertos/tasks.c **** 		{
2656:../freertos/tasks.c **** 			vApplicationTickHook();
2657:../freertos/tasks.c **** 		}
2658:../freertos/tasks.c **** 		#endif
2659:../freertos/tasks.c **** 	}
2660:../freertos/tasks.c **** 
2661:../freertos/tasks.c **** 	#if ( configUSE_PREEMPTION == 1 )
2662:../freertos/tasks.c **** 	{
2663:../freertos/tasks.c **** 		if( xYieldPending != pdFALSE )
 2787              		.loc 1 2663 0
 2788 010c 0F4B     		ldr	r3, .L219+40
 2789 010e 1B68     		ldr	r3, [r3]
 2790 0110 002B     		cmp	r3, #0
 2791 0112 01D0     		beq	.L217
2664:../freertos/tasks.c **** 		{
2665:../freertos/tasks.c **** 			xSwitchRequired = pdTRUE;
 2792              		.loc 1 2665 0
 2793 0114 0123     		mov	r3, #1
 2794 0116 7B61     		str	r3, [r7, #20]
 2795              	.L217:
2666:../freertos/tasks.c **** 		}
2667:../freertos/tasks.c **** 		else
2668:../freertos/tasks.c **** 		{
2669:../freertos/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2670:../freertos/tasks.c **** 		}
2671:../freertos/tasks.c **** 	}
2672:../freertos/tasks.c **** 	#endif /* configUSE_PREEMPTION */
2673:../freertos/tasks.c **** 
2674:../freertos/tasks.c **** 	return xSwitchRequired;
 2796              		.loc 1 2674 0
 2797 0118 7B69     		ldr	r3, [r7, #20]
2675:../freertos/tasks.c **** }
 2798              		.loc 1 2675 0
 2799 011a 181C     		mov	r0, r3
 2800 011c BD46     		mov	sp, r7
 2801 011e 06B0     		add	sp, sp, #24
 2802              		@ sp needed
 2803 0120 80BD     		pop	{r7, pc}
 2804              	.L220:
 2805 0122 C046     		.align	2
 2806              	.L219:
 2807 0124 00000000 		.word	uxSchedulerSuspended
 2808 0128 00000000 		.word	xTickCount
 2809 012c 00000000 		.word	pxDelayedTaskList
 2810 0130 00000000 		.word	pxOverflowDelayedTaskList
 2811 0134 00000000 		.word	xNumOfOverflows
 2812 0138 00000000 		.word	xNextTaskUnblockTime
 2813 013c 00000000 		.word	uxTopReadyPriority
 2814 0140 00000000 		.word	pxReadyTasksLists
 2815 0144 00000000 		.word	pxCurrentTCB
 2816 0148 00000000 		.word	uxPendedTicks
 2817 014c 00000000 		.word	xYieldPending
 2818              		.cfi_endproc
 2819              	.LFE23:
 2821              		.section	.text.vTaskSwitchContext,"ax",%progbits
 2822              		.align	2
 2823              		.global	vTaskSwitchContext
 2824              		.code	16
 2825              		.thumb_func
 2827              	vTaskSwitchContext:
 2828              	.LFB24:
2676:../freertos/tasks.c **** /*-----------------------------------------------------------*/
2677:../freertos/tasks.c **** 
2678:../freertos/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2679:../freertos/tasks.c **** 
2680:../freertos/tasks.c **** 	void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction )
2681:../freertos/tasks.c **** 	{
2682:../freertos/tasks.c **** 	TCB_t *xTCB;
2683:../freertos/tasks.c **** 
2684:../freertos/tasks.c **** 		/* If xTask is NULL then it is the task hook of the calling task that is
2685:../freertos/tasks.c **** 		getting set. */
2686:../freertos/tasks.c **** 		if( xTask == NULL )
2687:../freertos/tasks.c **** 		{
2688:../freertos/tasks.c **** 			xTCB = ( TCB_t * ) pxCurrentTCB;
2689:../freertos/tasks.c **** 		}
2690:../freertos/tasks.c **** 		else
2691:../freertos/tasks.c **** 		{
2692:../freertos/tasks.c **** 			xTCB = ( TCB_t * ) xTask;
2693:../freertos/tasks.c **** 		}
2694:../freertos/tasks.c **** 
2695:../freertos/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
2696:../freertos/tasks.c **** 		the value can be accessed from an interrupt. */
2697:../freertos/tasks.c **** 		taskENTER_CRITICAL();
2698:../freertos/tasks.c **** 			xTCB->pxTaskTag = pxHookFunction;
2699:../freertos/tasks.c **** 		taskEXIT_CRITICAL();
2700:../freertos/tasks.c **** 	}
2701:../freertos/tasks.c **** 
2702:../freertos/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2703:../freertos/tasks.c **** /*-----------------------------------------------------------*/
2704:../freertos/tasks.c **** 
2705:../freertos/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2706:../freertos/tasks.c **** 
2707:../freertos/tasks.c **** 	TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask )
2708:../freertos/tasks.c **** 	{
2709:../freertos/tasks.c **** 	TCB_t *xTCB;
2710:../freertos/tasks.c **** 	TaskHookFunction_t xReturn;
2711:../freertos/tasks.c **** 
2712:../freertos/tasks.c **** 		/* If xTask is NULL then we are setting our own task hook. */
2713:../freertos/tasks.c **** 		if( xTask == NULL )
2714:../freertos/tasks.c **** 		{
2715:../freertos/tasks.c **** 			xTCB = ( TCB_t * ) pxCurrentTCB;
2716:../freertos/tasks.c **** 		}
2717:../freertos/tasks.c **** 		else
2718:../freertos/tasks.c **** 		{
2719:../freertos/tasks.c **** 			xTCB = ( TCB_t * ) xTask;
2720:../freertos/tasks.c **** 		}
2721:../freertos/tasks.c **** 
2722:../freertos/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
2723:../freertos/tasks.c **** 		the value can be accessed from an interrupt. */
2724:../freertos/tasks.c **** 		taskENTER_CRITICAL();
2725:../freertos/tasks.c **** 		{
2726:../freertos/tasks.c **** 			xReturn = xTCB->pxTaskTag;
2727:../freertos/tasks.c **** 		}
2728:../freertos/tasks.c **** 		taskEXIT_CRITICAL();
2729:../freertos/tasks.c **** 
2730:../freertos/tasks.c **** 		return xReturn;
2731:../freertos/tasks.c **** 	}
2732:../freertos/tasks.c **** 
2733:../freertos/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2734:../freertos/tasks.c **** /*-----------------------------------------------------------*/
2735:../freertos/tasks.c **** 
2736:../freertos/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2737:../freertos/tasks.c **** 
2738:../freertos/tasks.c **** 	BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter )
2739:../freertos/tasks.c **** 	{
2740:../freertos/tasks.c **** 	TCB_t *xTCB;
2741:../freertos/tasks.c **** 	BaseType_t xReturn;
2742:../freertos/tasks.c **** 
2743:../freertos/tasks.c **** 		/* If xTask is NULL then we are calling our own task hook. */
2744:../freertos/tasks.c **** 		if( xTask == NULL )
2745:../freertos/tasks.c **** 		{
2746:../freertos/tasks.c **** 			xTCB = ( TCB_t * ) pxCurrentTCB;
2747:../freertos/tasks.c **** 		}
2748:../freertos/tasks.c **** 		else
2749:../freertos/tasks.c **** 		{
2750:../freertos/tasks.c **** 			xTCB = ( TCB_t * ) xTask;
2751:../freertos/tasks.c **** 		}
2752:../freertos/tasks.c **** 
2753:../freertos/tasks.c **** 		if( xTCB->pxTaskTag != NULL )
2754:../freertos/tasks.c **** 		{
2755:../freertos/tasks.c **** 			xReturn = xTCB->pxTaskTag( pvParameter );
2756:../freertos/tasks.c **** 		}
2757:../freertos/tasks.c **** 		else
2758:../freertos/tasks.c **** 		{
2759:../freertos/tasks.c **** 			xReturn = pdFAIL;
2760:../freertos/tasks.c **** 		}
2761:../freertos/tasks.c **** 
2762:../freertos/tasks.c **** 		return xReturn;
2763:../freertos/tasks.c **** 	}
2764:../freertos/tasks.c **** 
2765:../freertos/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2766:../freertos/tasks.c **** /*-----------------------------------------------------------*/
2767:../freertos/tasks.c **** 
2768:../freertos/tasks.c **** void vTaskSwitchContext( void )
2769:../freertos/tasks.c **** {
 2829              		.loc 1 2769 0
 2830              		.cfi_startproc
 2831 0000 80B5     		push	{r7, lr}
 2832              		.cfi_def_cfa_offset 8
 2833              		.cfi_offset 7, -8
 2834              		.cfi_offset 14, -4
 2835 0002 82B0     		sub	sp, sp, #8
 2836              		.cfi_def_cfa_offset 16
 2837 0004 00AF     		add	r7, sp, #0
 2838              		.cfi_def_cfa_register 7
2770:../freertos/tasks.c **** 	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 2839              		.loc 1 2770 0
 2840 0006 214B     		ldr	r3, .L229
 2841 0008 1B68     		ldr	r3, [r3]
 2842 000a 002B     		cmp	r3, #0
 2843 000c 03D0     		beq	.L222
2771:../freertos/tasks.c **** 	{
2772:../freertos/tasks.c **** 		/* The scheduler is currently suspended - do not allow a context
2773:../freertos/tasks.c **** 		switch. */
2774:../freertos/tasks.c **** 		xYieldPending = pdTRUE;
 2844              		.loc 1 2774 0
 2845 000e 204B     		ldr	r3, .L229+4
 2846 0010 0122     		mov	r2, #1
 2847 0012 1A60     		str	r2, [r3]
 2848 0014 37E0     		b	.L221
 2849              	.L222:
2775:../freertos/tasks.c **** 	}
2776:../freertos/tasks.c **** 	else
2777:../freertos/tasks.c **** 	{
2778:../freertos/tasks.c **** 		xYieldPending = pdFALSE;
 2850              		.loc 1 2778 0
 2851 0016 1E4B     		ldr	r3, .L229+4
 2852 0018 0022     		mov	r2, #0
 2853 001a 1A60     		str	r2, [r3]
 2854              	.LBB7:
2779:../freertos/tasks.c **** 		traceTASK_SWITCHED_OUT();
2780:../freertos/tasks.c **** 
2781:../freertos/tasks.c **** 		#if ( configGENERATE_RUN_TIME_STATS == 1 )
2782:../freertos/tasks.c **** 		{
2783:../freertos/tasks.c **** 				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
2784:../freertos/tasks.c **** 					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
2785:../freertos/tasks.c **** 				#else
2786:../freertos/tasks.c **** 					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
2787:../freertos/tasks.c **** 				#endif
2788:../freertos/tasks.c **** 
2789:../freertos/tasks.c **** 				/* Add the amount of time the task has been running to the
2790:../freertos/tasks.c **** 				accumulated time so far.  The time the task started running was
2791:../freertos/tasks.c **** 				stored in ulTaskSwitchedInTime.  Note that there is no overflow
2792:../freertos/tasks.c **** 				protection here so count values are only valid until the timer
2793:../freertos/tasks.c **** 				overflows.  The guard against negative values is to protect
2794:../freertos/tasks.c **** 				against suspect run time stat counter implementations - which
2795:../freertos/tasks.c **** 				are provided by the application, not the kernel. */
2796:../freertos/tasks.c **** 				if( ulTotalRunTime > ulTaskSwitchedInTime )
2797:../freertos/tasks.c **** 				{
2798:../freertos/tasks.c **** 					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
2799:../freertos/tasks.c **** 				}
2800:../freertos/tasks.c **** 				else
2801:../freertos/tasks.c **** 				{
2802:../freertos/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
2803:../freertos/tasks.c **** 				}
2804:../freertos/tasks.c **** 				ulTaskSwitchedInTime = ulTotalRunTime;
2805:../freertos/tasks.c **** 		}
2806:../freertos/tasks.c **** 		#endif /* configGENERATE_RUN_TIME_STATS */
2807:../freertos/tasks.c **** 
2808:../freertos/tasks.c **** 		/* Check for stack overflow, if configured. */
2809:../freertos/tasks.c **** 		taskCHECK_FOR_STACK_OVERFLOW();
2810:../freertos/tasks.c **** 
2811:../freertos/tasks.c **** 		/* Select a new task to run using either the generic C or port
2812:../freertos/tasks.c **** 		optimised asm code. */
2813:../freertos/tasks.c **** 		taskSELECT_HIGHEST_PRIORITY_TASK();
 2855              		.loc 1 2813 0
 2856 001c 1D4B     		ldr	r3, .L229+8
 2857 001e 1B68     		ldr	r3, [r3]
 2858 0020 7B60     		str	r3, [r7, #4]
 2859 0022 07E0     		b	.L224
 2860              	.L227:
 2861              		.loc 1 2813 0 is_stmt 0 discriminator 2
 2862 0024 7B68     		ldr	r3, [r7, #4]
 2863 0026 002B     		cmp	r3, #0
 2864 0028 01D1     		bne	.L225
 2865              		.loc 1 2813 0 discriminator 1
 2866              	@ 2813 "../freertos/tasks.c" 1
 2867 002a 72B6     		 cpsid i 
 2868              	@ 0 "" 2
 2869              		.code	16
 2870              	.L226:
 2871 002c FEE7     		b	.L226
 2872              	.L225:
 2873              		.loc 1 2813 0 discriminator 2
 2874 002e 7B68     		ldr	r3, [r7, #4]
 2875 0030 013B     		sub	r3, r3, #1
 2876 0032 7B60     		str	r3, [r7, #4]
 2877              	.L224:
 2878              		.loc 1 2813 0 discriminator 1
 2879 0034 1849     		ldr	r1, .L229+12
 2880 0036 7A68     		ldr	r2, [r7, #4]
 2881 0038 131C     		mov	r3, r2
 2882 003a 9B00     		lsl	r3, r3, #2
 2883 003c 9B18     		add	r3, r3, r2
 2884 003e 9B00     		lsl	r3, r3, #2
 2885 0040 5B58     		ldr	r3, [r3, r1]
 2886 0042 002B     		cmp	r3, #0
 2887 0044 EED0     		beq	.L227
 2888              	.LBB8:
 2889              		.loc 1 2813 0 discriminator 3
 2890 0046 7A68     		ldr	r2, [r7, #4]
 2891 0048 131C     		mov	r3, r2
 2892 004a 9B00     		lsl	r3, r3, #2
 2893 004c 9B18     		add	r3, r3, r2
 2894 004e 9B00     		lsl	r3, r3, #2
 2895 0050 114A     		ldr	r2, .L229+12
 2896 0052 9B18     		add	r3, r3, r2
 2897 0054 3B60     		str	r3, [r7]
 2898 0056 3B68     		ldr	r3, [r7]
 2899 0058 5B68     		ldr	r3, [r3, #4]
 2900 005a 5A68     		ldr	r2, [r3, #4]
 2901 005c 3B68     		ldr	r3, [r7]
 2902 005e 5A60     		str	r2, [r3, #4]
 2903 0060 3B68     		ldr	r3, [r7]
 2904 0062 5A68     		ldr	r2, [r3, #4]
 2905 0064 3B68     		ldr	r3, [r7]
 2906 0066 0833     		add	r3, r3, #8
 2907 0068 9A42     		cmp	r2, r3
 2908 006a 04D1     		bne	.L228
 2909              		.loc 1 2813 0 discriminator 1
 2910 006c 3B68     		ldr	r3, [r7]
 2911 006e 5B68     		ldr	r3, [r3, #4]
 2912 0070 5A68     		ldr	r2, [r3, #4]
 2913 0072 3B68     		ldr	r3, [r7]
 2914 0074 5A60     		str	r2, [r3, #4]
 2915              	.L228:
 2916              		.loc 1 2813 0 discriminator 2
 2917 0076 3B68     		ldr	r3, [r7]
 2918 0078 5B68     		ldr	r3, [r3, #4]
 2919 007a DA68     		ldr	r2, [r3, #12]
 2920 007c 074B     		ldr	r3, .L229+16
 2921 007e 1A60     		str	r2, [r3]
 2922              	.LBE8:
 2923 0080 044B     		ldr	r3, .L229+8
 2924 0082 7A68     		ldr	r2, [r7, #4]
 2925 0084 1A60     		str	r2, [r3]
 2926              	.L221:
 2927              	.LBE7:
2814:../freertos/tasks.c **** 		traceTASK_SWITCHED_IN();
2815:../freertos/tasks.c **** 
2816:../freertos/tasks.c **** 		#if ( configUSE_NEWLIB_REENTRANT == 1 )
2817:../freertos/tasks.c **** 		{
2818:../freertos/tasks.c **** 			/* Switch Newlib's _impure_ptr variable to point to the _reent
2819:../freertos/tasks.c **** 			structure specific to this task. */
2820:../freertos/tasks.c **** 			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
2821:../freertos/tasks.c **** 		}
2822:../freertos/tasks.c **** 		#endif /* configUSE_NEWLIB_REENTRANT */
2823:../freertos/tasks.c **** 	}
2824:../freertos/tasks.c **** }
 2928              		.loc 1 2824 0 is_stmt 1
 2929 0086 BD46     		mov	sp, r7
 2930 0088 02B0     		add	sp, sp, #8
 2931              		@ sp needed
 2932 008a 80BD     		pop	{r7, pc}
 2933              	.L230:
 2934              		.align	2
 2935              	.L229:
 2936 008c 00000000 		.word	uxSchedulerSuspended
 2937 0090 00000000 		.word	xYieldPending
 2938 0094 00000000 		.word	uxTopReadyPriority
 2939 0098 00000000 		.word	pxReadyTasksLists
 2940 009c 00000000 		.word	pxCurrentTCB
 2941              		.cfi_endproc
 2942              	.LFE24:
 2944              		.section	.text.vTaskPlaceOnEventList,"ax",%progbits
 2945              		.align	2
 2946              		.global	vTaskPlaceOnEventList
 2947              		.code	16
 2948              		.thumb_func
 2950              	vTaskPlaceOnEventList:
 2951              	.LFB25:
2825:../freertos/tasks.c **** /*-----------------------------------------------------------*/
2826:../freertos/tasks.c **** 
2827:../freertos/tasks.c **** void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
2828:../freertos/tasks.c **** {
 2952              		.loc 1 2828 0
 2953              		.cfi_startproc
 2954 0000 80B5     		push	{r7, lr}
 2955              		.cfi_def_cfa_offset 8
 2956              		.cfi_offset 7, -8
 2957              		.cfi_offset 14, -4
 2958 0002 82B0     		sub	sp, sp, #8
 2959              		.cfi_def_cfa_offset 16
 2960 0004 00AF     		add	r7, sp, #0
 2961              		.cfi_def_cfa_register 7
 2962 0006 7860     		str	r0, [r7, #4]
 2963 0008 3960     		str	r1, [r7]
2829:../freertos/tasks.c **** 	configASSERT( pxEventList );
 2964              		.loc 1 2829 0
 2965 000a 7B68     		ldr	r3, [r7, #4]
 2966 000c 002B     		cmp	r3, #0
 2967 000e 01D1     		bne	.L232
 2968              		.loc 1 2829 0 is_stmt 0 discriminator 1
 2969              	@ 2829 "../freertos/tasks.c" 1
 2970 0010 72B6     		 cpsid i 
 2971              	@ 0 "" 2
 2972              		.code	16
 2973              	.L233:
 2974 0012 FEE7     		b	.L233
 2975              	.L232:
2830:../freertos/tasks.c **** 
2831:../freertos/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH EITHER INTERRUPTS DISABLED OR THE
2832:../freertos/tasks.c **** 	SCHEDULER SUSPENDED AND THE QUEUE BEING ACCESSED LOCKED. */
2833:../freertos/tasks.c **** 
2834:../freertos/tasks.c **** 	/* Place the event list item of the TCB in the appropriate event list.
2835:../freertos/tasks.c **** 	This is placed in the list in priority order so the highest priority task
2836:../freertos/tasks.c **** 	is the first to be woken by the event.  The queue that contains the event
2837:../freertos/tasks.c **** 	list is locked, preventing simultaneous access from interrupts. */
2838:../freertos/tasks.c **** 	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 2976              		.loc 1 2838 0 is_stmt 1
 2977 0014 074B     		ldr	r3, .L234
 2978 0016 1B68     		ldr	r3, [r3]
 2979 0018 1833     		add	r3, r3, #24
 2980 001a 7A68     		ldr	r2, [r7, #4]
 2981 001c 101C     		mov	r0, r2
 2982 001e 191C     		mov	r1, r3
 2983 0020 FFF7FEFF 		bl	vListInsert
2839:../freertos/tasks.c **** 
2840:../freertos/tasks.c **** 	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 2984              		.loc 1 2840 0
 2985 0024 3B68     		ldr	r3, [r7]
 2986 0026 181C     		mov	r0, r3
 2987 0028 0121     		mov	r1, #1
 2988 002a FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
2841:../freertos/tasks.c **** }
 2989              		.loc 1 2841 0
 2990 002e BD46     		mov	sp, r7
 2991 0030 02B0     		add	sp, sp, #8
 2992              		@ sp needed
 2993 0032 80BD     		pop	{r7, pc}
 2994              	.L235:
 2995              		.align	2
 2996              	.L234:
 2997 0034 00000000 		.word	pxCurrentTCB
 2998              		.cfi_endproc
 2999              	.LFE25:
 3001              		.section	.text.vTaskPlaceOnUnorderedEventList,"ax",%progbits
 3002              		.align	2
 3003              		.global	vTaskPlaceOnUnorderedEventList
 3004              		.code	16
 3005              		.thumb_func
 3007              	vTaskPlaceOnUnorderedEventList:
 3008              	.LFB26:
2842:../freertos/tasks.c **** /*-----------------------------------------------------------*/
2843:../freertos/tasks.c **** 
2844:../freertos/tasks.c **** void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickT
2845:../freertos/tasks.c **** {
 3009              		.loc 1 2845 0
 3010              		.cfi_startproc
 3011 0000 80B5     		push	{r7, lr}
 3012              		.cfi_def_cfa_offset 8
 3013              		.cfi_offset 7, -8
 3014              		.cfi_offset 14, -4
 3015 0002 84B0     		sub	sp, sp, #16
 3016              		.cfi_def_cfa_offset 24
 3017 0004 00AF     		add	r7, sp, #0
 3018              		.cfi_def_cfa_register 7
 3019 0006 F860     		str	r0, [r7, #12]
 3020 0008 B960     		str	r1, [r7, #8]
 3021 000a 7A60     		str	r2, [r7, #4]
2846:../freertos/tasks.c **** 	configASSERT( pxEventList );
 3022              		.loc 1 2846 0
 3023 000c FB68     		ldr	r3, [r7, #12]
 3024 000e 002B     		cmp	r3, #0
 3025 0010 01D1     		bne	.L237
 3026              		.loc 1 2846 0 is_stmt 0 discriminator 1
 3027              	@ 2846 "../freertos/tasks.c" 1
 3028 0012 72B6     		 cpsid i 
 3029              	@ 0 "" 2
 3030              		.code	16
 3031              	.L238:
 3032 0014 FEE7     		b	.L238
 3033              	.L237:
2847:../freertos/tasks.c **** 
2848:../freertos/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
2849:../freertos/tasks.c **** 	the event groups implementation. */
2850:../freertos/tasks.c **** 	configASSERT( uxSchedulerSuspended != 0 );
 3034              		.loc 1 2850 0 is_stmt 1
 3035 0016 0E4B     		ldr	r3, .L241
 3036 0018 1B68     		ldr	r3, [r3]
 3037 001a 002B     		cmp	r3, #0
 3038 001c 01D1     		bne	.L239
 3039              		.loc 1 2850 0 is_stmt 0 discriminator 1
 3040              	@ 2850 "../freertos/tasks.c" 1
 3041 001e 72B6     		 cpsid i 
 3042              	@ 0 "" 2
 3043              		.code	16
 3044              	.L240:
 3045 0020 FEE7     		b	.L240
 3046              	.L239:
2851:../freertos/tasks.c **** 
2852:../freertos/tasks.c **** 	/* Store the item value in the event list item.  It is safe to access the
2853:../freertos/tasks.c **** 	event list item here as interrupts won't access the event list item of a
2854:../freertos/tasks.c **** 	task that is not in the Blocked state. */
2855:../freertos/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE
 3047              		.loc 1 2855 0 is_stmt 1
 3048 0022 0C4B     		ldr	r3, .L241+4
 3049 0024 1B68     		ldr	r3, [r3]
 3050 0026 BA68     		ldr	r2, [r7, #8]
 3051 0028 8021     		mov	r1, #128
 3052 002a 0906     		lsl	r1, r1, #24
 3053 002c 0A43     		orr	r2, r1
 3054 002e 9A61     		str	r2, [r3, #24]
2856:../freertos/tasks.c **** 
2857:../freertos/tasks.c **** 	/* Place the event list item of the TCB at the end of the appropriate event
2858:../freertos/tasks.c **** 	list.  It is safe to access the event list here because it is part of an
2859:../freertos/tasks.c **** 	event group implementation - and interrupts don't access event groups
2860:../freertos/tasks.c **** 	directly (instead they access them indirectly by pending function calls to
2861:../freertos/tasks.c **** 	the task level). */
2862:../freertos/tasks.c **** 	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 3055              		.loc 1 2862 0
 3056 0030 084B     		ldr	r3, .L241+4
 3057 0032 1B68     		ldr	r3, [r3]
 3058 0034 1833     		add	r3, r3, #24
 3059 0036 FA68     		ldr	r2, [r7, #12]
 3060 0038 101C     		mov	r0, r2
 3061 003a 191C     		mov	r1, r3
 3062 003c FFF7FEFF 		bl	vListInsertEnd
2863:../freertos/tasks.c **** 
2864:../freertos/tasks.c **** 	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 3063              		.loc 1 2864 0
 3064 0040 7B68     		ldr	r3, [r7, #4]
 3065 0042 181C     		mov	r0, r3
 3066 0044 0121     		mov	r1, #1
 3067 0046 FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
2865:../freertos/tasks.c **** }
 3068              		.loc 1 2865 0
 3069 004a BD46     		mov	sp, r7
 3070 004c 04B0     		add	sp, sp, #16
 3071              		@ sp needed
 3072 004e 80BD     		pop	{r7, pc}
 3073              	.L242:
 3074              		.align	2
 3075              	.L241:
 3076 0050 00000000 		.word	uxSchedulerSuspended
 3077 0054 00000000 		.word	pxCurrentTCB
 3078              		.cfi_endproc
 3079              	.LFE26:
 3081              		.section	.text.vTaskPlaceOnEventListRestricted,"ax",%progbits
 3082              		.align	2
 3083              		.global	vTaskPlaceOnEventListRestricted
 3084              		.code	16
 3085              		.thumb_func
 3087              	vTaskPlaceOnEventListRestricted:
 3088              	.LFB27:
2866:../freertos/tasks.c **** /*-----------------------------------------------------------*/
2867:../freertos/tasks.c **** 
2868:../freertos/tasks.c **** #if( configUSE_TIMERS == 1 )
2869:../freertos/tasks.c **** 
2870:../freertos/tasks.c **** 	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const B
2871:../freertos/tasks.c **** 	{
 3089              		.loc 1 2871 0
 3090              		.cfi_startproc
 3091 0000 80B5     		push	{r7, lr}
 3092              		.cfi_def_cfa_offset 8
 3093              		.cfi_offset 7, -8
 3094              		.cfi_offset 14, -4
 3095 0002 84B0     		sub	sp, sp, #16
 3096              		.cfi_def_cfa_offset 24
 3097 0004 00AF     		add	r7, sp, #0
 3098              		.cfi_def_cfa_register 7
 3099 0006 F860     		str	r0, [r7, #12]
 3100 0008 B960     		str	r1, [r7, #8]
 3101 000a 7A60     		str	r2, [r7, #4]
2872:../freertos/tasks.c **** 		configASSERT( pxEventList );
 3102              		.loc 1 2872 0
 3103 000c FB68     		ldr	r3, [r7, #12]
 3104 000e 002B     		cmp	r3, #0
 3105 0010 01D1     		bne	.L244
 3106              		.loc 1 2872 0 is_stmt 0 discriminator 1
 3107              	@ 2872 "../freertos/tasks.c" 1
 3108 0012 72B6     		 cpsid i 
 3109              	@ 0 "" 2
 3110              		.code	16
 3111              	.L245:
 3112 0014 FEE7     		b	.L245
 3113              	.L244:
2873:../freertos/tasks.c **** 
2874:../freertos/tasks.c **** 		/* This function should not be called by application code hence the
2875:../freertos/tasks.c **** 		'Restricted' in its name.  It is not part of the public API.  It is
2876:../freertos/tasks.c **** 		designed for use by kernel code, and has special calling requirements -
2877:../freertos/tasks.c **** 		it should be called with the scheduler suspended. */
2878:../freertos/tasks.c **** 
2879:../freertos/tasks.c **** 
2880:../freertos/tasks.c **** 		/* Place the event list item of the TCB in the appropriate event list.
2881:../freertos/tasks.c **** 		In this case it is assume that this is the only task that is going to
2882:../freertos/tasks.c **** 		be waiting on this event list, so the faster vListInsertEnd() function
2883:../freertos/tasks.c **** 		can be used in place of vListInsert. */
2884:../freertos/tasks.c **** 		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 3114              		.loc 1 2884 0 is_stmt 1
 3115 0016 0B4B     		ldr	r3, .L247
 3116 0018 1B68     		ldr	r3, [r3]
 3117 001a 1833     		add	r3, r3, #24
 3118 001c FA68     		ldr	r2, [r7, #12]
 3119 001e 101C     		mov	r0, r2
 3120 0020 191C     		mov	r1, r3
 3121 0022 FFF7FEFF 		bl	vListInsertEnd
2885:../freertos/tasks.c **** 
2886:../freertos/tasks.c **** 		/* If the task should block indefinitely then set the block time to a
2887:../freertos/tasks.c **** 		value that will be recognised as an indefinite delay inside the
2888:../freertos/tasks.c **** 		prvAddCurrentTaskToDelayedList() function. */
2889:../freertos/tasks.c **** 		if( xWaitIndefinitely != pdFALSE )
 3122              		.loc 1 2889 0
 3123 0026 7B68     		ldr	r3, [r7, #4]
 3124 0028 002B     		cmp	r3, #0
 3125 002a 02D0     		beq	.L246
2890:../freertos/tasks.c **** 		{
2891:../freertos/tasks.c **** 			xTicksToWait = portMAX_DELAY;
 3126              		.loc 1 2891 0
 3127 002c 0123     		mov	r3, #1
 3128 002e 5B42     		neg	r3, r3
 3129 0030 BB60     		str	r3, [r7, #8]
 3130              	.L246:
2892:../freertos/tasks.c **** 		}
2893:../freertos/tasks.c **** 
2894:../freertos/tasks.c **** 		traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
2895:../freertos/tasks.c **** 		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
 3131              		.loc 1 2895 0
 3132 0032 BA68     		ldr	r2, [r7, #8]
 3133 0034 7B68     		ldr	r3, [r7, #4]
 3134 0036 101C     		mov	r0, r2
 3135 0038 191C     		mov	r1, r3
 3136 003a FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
2896:../freertos/tasks.c **** 	}
 3137              		.loc 1 2896 0
 3138 003e BD46     		mov	sp, r7
 3139 0040 04B0     		add	sp, sp, #16
 3140              		@ sp needed
 3141 0042 80BD     		pop	{r7, pc}
 3142              	.L248:
 3143              		.align	2
 3144              	.L247:
 3145 0044 00000000 		.word	pxCurrentTCB
 3146              		.cfi_endproc
 3147              	.LFE27:
 3149              		.section	.text.xTaskRemoveFromEventList,"ax",%progbits
 3150              		.align	2
 3151              		.global	xTaskRemoveFromEventList
 3152              		.code	16
 3153              		.thumb_func
 3155              	xTaskRemoveFromEventList:
 3156              	.LFB28:
2897:../freertos/tasks.c **** 
2898:../freertos/tasks.c **** #endif /* configUSE_TIMERS */
2899:../freertos/tasks.c **** /*-----------------------------------------------------------*/
2900:../freertos/tasks.c **** 
2901:../freertos/tasks.c **** BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
2902:../freertos/tasks.c **** {
 3157              		.loc 1 2902 0
 3158              		.cfi_startproc
 3159 0000 80B5     		push	{r7, lr}
 3160              		.cfi_def_cfa_offset 8
 3161              		.cfi_offset 7, -8
 3162              		.cfi_offset 14, -4
 3163 0002 84B0     		sub	sp, sp, #16
 3164              		.cfi_def_cfa_offset 24
 3165 0004 00AF     		add	r7, sp, #0
 3166              		.cfi_def_cfa_register 7
 3167 0006 7860     		str	r0, [r7, #4]
2903:../freertos/tasks.c **** TCB_t *pxUnblockedTCB;
2904:../freertos/tasks.c **** BaseType_t xReturn;
2905:../freertos/tasks.c **** 
2906:../freertos/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED FROM A CRITICAL SECTION.  It can also be
2907:../freertos/tasks.c **** 	called from a critical section within an ISR. */
2908:../freertos/tasks.c **** 
2909:../freertos/tasks.c **** 	/* The event list is sorted in priority order, so the first in the list can
2910:../freertos/tasks.c **** 	be removed as it is known to be the highest priority.  Remove the TCB from
2911:../freertos/tasks.c **** 	the delayed list, and add it to the ready list.
2912:../freertos/tasks.c **** 
2913:../freertos/tasks.c **** 	If an event is for a queue that is locked then this function will never
2914:../freertos/tasks.c **** 	get called - the lock count on the queue will get modified instead.  This
2915:../freertos/tasks.c **** 	means exclusive access to the event list is guaranteed here.
2916:../freertos/tasks.c **** 
2917:../freertos/tasks.c **** 	This function assumes that a check has already been made to ensure that
2918:../freertos/tasks.c **** 	pxEventList is not empty. */
2919:../freertos/tasks.c **** 	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 3168              		.loc 1 2919 0
 3169 0008 7B68     		ldr	r3, [r7, #4]
 3170 000a DB68     		ldr	r3, [r3, #12]
 3171 000c DB68     		ldr	r3, [r3, #12]
 3172 000e BB60     		str	r3, [r7, #8]
2920:../freertos/tasks.c **** 	configASSERT( pxUnblockedTCB );
 3173              		.loc 1 2920 0
 3174 0010 BB68     		ldr	r3, [r7, #8]
 3175 0012 002B     		cmp	r3, #0
 3176 0014 01D1     		bne	.L250
 3177              		.loc 1 2920 0 is_stmt 0 discriminator 1
 3178              	@ 2920 "../freertos/tasks.c" 1
 3179 0016 72B6     		 cpsid i 
 3180              	@ 0 "" 2
 3181              		.code	16
 3182              	.L251:
 3183 0018 FEE7     		b	.L251
 3184              	.L250:
2921:../freertos/tasks.c **** 	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 3185              		.loc 1 2921 0 is_stmt 1
 3186 001a BB68     		ldr	r3, [r7, #8]
 3187 001c 1833     		add	r3, r3, #24
 3188 001e 181C     		mov	r0, r3
 3189 0020 FFF7FEFF 		bl	uxListRemove
2922:../freertos/tasks.c **** 
2923:../freertos/tasks.c **** 	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 3190              		.loc 1 2923 0
 3191 0024 1E4B     		ldr	r3, .L258
 3192 0026 1B68     		ldr	r3, [r3]
 3193 0028 002B     		cmp	r3, #0
 3194 002a 1DD1     		bne	.L252
2924:../freertos/tasks.c **** 	{
2925:../freertos/tasks.c **** 		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 3195              		.loc 1 2925 0
 3196 002c BB68     		ldr	r3, [r7, #8]
 3197 002e 0433     		add	r3, r3, #4
 3198 0030 181C     		mov	r0, r3
 3199 0032 FFF7FEFF 		bl	uxListRemove
2926:../freertos/tasks.c **** 		prvAddTaskToReadyList( pxUnblockedTCB );
 3200              		.loc 1 2926 0
 3201 0036 BB68     		ldr	r3, [r7, #8]
 3202 0038 DA6A     		ldr	r2, [r3, #44]
 3203 003a 1A4B     		ldr	r3, .L258+4
 3204 003c 1B68     		ldr	r3, [r3]
 3205 003e 9A42     		cmp	r2, r3
 3206 0040 03D9     		bls	.L253
 3207              		.loc 1 2926 0 is_stmt 0 discriminator 1
 3208 0042 BB68     		ldr	r3, [r7, #8]
 3209 0044 DA6A     		ldr	r2, [r3, #44]
 3210 0046 174B     		ldr	r3, .L258+4
 3211 0048 1A60     		str	r2, [r3]
 3212              	.L253:
 3213              		.loc 1 2926 0 discriminator 2
 3214 004a BB68     		ldr	r3, [r7, #8]
 3215 004c DA6A     		ldr	r2, [r3, #44]
 3216 004e 131C     		mov	r3, r2
 3217 0050 9B00     		lsl	r3, r3, #2
 3218 0052 9B18     		add	r3, r3, r2
 3219 0054 9B00     		lsl	r3, r3, #2
 3220 0056 144A     		ldr	r2, .L258+8
 3221 0058 9A18     		add	r2, r3, r2
 3222 005a BB68     		ldr	r3, [r7, #8]
 3223 005c 0433     		add	r3, r3, #4
 3224 005e 101C     		mov	r0, r2
 3225 0060 191C     		mov	r1, r3
 3226 0062 FFF7FEFF 		bl	vListInsertEnd
 3227 0066 06E0     		b	.L254
 3228              	.L252:
2927:../freertos/tasks.c **** 	}
2928:../freertos/tasks.c **** 	else
2929:../freertos/tasks.c **** 	{
2930:../freertos/tasks.c **** 		/* The delayed and ready lists cannot be accessed, so hold this task
2931:../freertos/tasks.c **** 		pending until the scheduler is resumed. */
2932:../freertos/tasks.c **** 		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 3229              		.loc 1 2932 0 is_stmt 1
 3230 0068 BB68     		ldr	r3, [r7, #8]
 3231 006a 1833     		add	r3, r3, #24
 3232 006c 0F4A     		ldr	r2, .L258+12
 3233 006e 101C     		mov	r0, r2
 3234 0070 191C     		mov	r1, r3
 3235 0072 FFF7FEFF 		bl	vListInsertEnd
 3236              	.L254:
2933:../freertos/tasks.c **** 	}
2934:../freertos/tasks.c **** 
2935:../freertos/tasks.c **** 	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 3237              		.loc 1 2935 0
 3238 0076 BB68     		ldr	r3, [r7, #8]
 3239 0078 DA6A     		ldr	r2, [r3, #44]
 3240 007a 0D4B     		ldr	r3, .L258+16
 3241 007c 1B68     		ldr	r3, [r3]
 3242 007e DB6A     		ldr	r3, [r3, #44]
 3243 0080 9A42     		cmp	r2, r3
 3244 0082 05D9     		bls	.L255
2936:../freertos/tasks.c **** 	{
2937:../freertos/tasks.c **** 		/* Return true if the task removed from the event list has a higher
2938:../freertos/tasks.c **** 		priority than the calling task.  This allows the calling task to know if
2939:../freertos/tasks.c **** 		it should force a context switch now. */
2940:../freertos/tasks.c **** 		xReturn = pdTRUE;
 3245              		.loc 1 2940 0
 3246 0084 0123     		mov	r3, #1
 3247 0086 FB60     		str	r3, [r7, #12]
2941:../freertos/tasks.c **** 
2942:../freertos/tasks.c **** 		/* Mark that a yield is pending in case the user is not using the
2943:../freertos/tasks.c **** 		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
2944:../freertos/tasks.c **** 		xYieldPending = pdTRUE;
 3248              		.loc 1 2944 0
 3249 0088 0A4B     		ldr	r3, .L258+20
 3250 008a 0122     		mov	r2, #1
 3251 008c 1A60     		str	r2, [r3]
 3252 008e 01E0     		b	.L256
 3253              	.L255:
2945:../freertos/tasks.c **** 	}
2946:../freertos/tasks.c **** 	else
2947:../freertos/tasks.c **** 	{
2948:../freertos/tasks.c **** 		xReturn = pdFALSE;
 3254              		.loc 1 2948 0
 3255 0090 0023     		mov	r3, #0
 3256 0092 FB60     		str	r3, [r7, #12]
 3257              	.L256:
2949:../freertos/tasks.c **** 	}
2950:../freertos/tasks.c **** 
2951:../freertos/tasks.c **** 	#if( configUSE_TICKLESS_IDLE != 0 )
2952:../freertos/tasks.c **** 	{
2953:../freertos/tasks.c **** 		/* If a task is blocked on a kernel object then xNextTaskUnblockTime
2954:../freertos/tasks.c **** 		might be set to the blocked task's time out time.  If the task is
2955:../freertos/tasks.c **** 		unblocked for a reason other than a timeout xNextTaskUnblockTime is
2956:../freertos/tasks.c **** 		normally left unchanged, because it is automatically reset to a new
2957:../freertos/tasks.c **** 		value when the tick count equals xNextTaskUnblockTime.  However if
2958:../freertos/tasks.c **** 		tickless idling is used it might be more important to enter sleep mode
2959:../freertos/tasks.c **** 		at the earliest possible time - so reset xNextTaskUnblockTime here to
2960:../freertos/tasks.c **** 		ensure it is updated at the earliest possible time. */
2961:../freertos/tasks.c **** 		prvResetNextTaskUnblockTime();
2962:../freertos/tasks.c **** 	}
2963:../freertos/tasks.c **** 	#endif
2964:../freertos/tasks.c **** 
2965:../freertos/tasks.c **** 	return xReturn;
 3258              		.loc 1 2965 0
 3259 0094 FB68     		ldr	r3, [r7, #12]
2966:../freertos/tasks.c **** }
 3260              		.loc 1 2966 0
 3261 0096 181C     		mov	r0, r3
 3262 0098 BD46     		mov	sp, r7
 3263 009a 04B0     		add	sp, sp, #16
 3264              		@ sp needed
 3265 009c 80BD     		pop	{r7, pc}
 3266              	.L259:
 3267 009e C046     		.align	2
 3268              	.L258:
 3269 00a0 00000000 		.word	uxSchedulerSuspended
 3270 00a4 00000000 		.word	uxTopReadyPriority
 3271 00a8 00000000 		.word	pxReadyTasksLists
 3272 00ac 00000000 		.word	xPendingReadyList
 3273 00b0 00000000 		.word	pxCurrentTCB
 3274 00b4 00000000 		.word	xYieldPending
 3275              		.cfi_endproc
 3276              	.LFE28:
 3278              		.section	.text.xTaskRemoveFromUnorderedEventList,"ax",%progbits
 3279              		.align	2
 3280              		.global	xTaskRemoveFromUnorderedEventList
 3281              		.code	16
 3282              		.thumb_func
 3284              	xTaskRemoveFromUnorderedEventList:
 3285              	.LFB29:
2967:../freertos/tasks.c **** /*-----------------------------------------------------------*/
2968:../freertos/tasks.c **** 
2969:../freertos/tasks.c **** BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemV
2970:../freertos/tasks.c **** {
 3286              		.loc 1 2970 0
 3287              		.cfi_startproc
 3288 0000 80B5     		push	{r7, lr}
 3289              		.cfi_def_cfa_offset 8
 3290              		.cfi_offset 7, -8
 3291              		.cfi_offset 14, -4
 3292 0002 84B0     		sub	sp, sp, #16
 3293              		.cfi_def_cfa_offset 24
 3294 0004 00AF     		add	r7, sp, #0
 3295              		.cfi_def_cfa_register 7
 3296 0006 7860     		str	r0, [r7, #4]
 3297 0008 3960     		str	r1, [r7]
2971:../freertos/tasks.c **** TCB_t *pxUnblockedTCB;
2972:../freertos/tasks.c **** BaseType_t xReturn;
2973:../freertos/tasks.c **** 
2974:../freertos/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
2975:../freertos/tasks.c **** 	the event flags implementation. */
2976:../freertos/tasks.c **** 	configASSERT( uxSchedulerSuspended != pdFALSE );
 3298              		.loc 1 2976 0
 3299 000a 244B     		ldr	r3, .L269
 3300 000c 1B68     		ldr	r3, [r3]
 3301 000e 002B     		cmp	r3, #0
 3302 0010 01D1     		bne	.L261
 3303              		.loc 1 2976 0 is_stmt 0 discriminator 1
 3304              	@ 2976 "../freertos/tasks.c" 1
 3305 0012 72B6     		 cpsid i 
 3306              	@ 0 "" 2
 3307              		.code	16
 3308              	.L262:
 3309 0014 FEE7     		b	.L262
 3310              	.L261:
2977:../freertos/tasks.c **** 
2978:../freertos/tasks.c **** 	/* Store the new item value in the event list. */
2979:../freertos/tasks.c **** 	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
 3311              		.loc 1 2979 0 is_stmt 1
 3312 0016 3B68     		ldr	r3, [r7]
 3313 0018 8022     		mov	r2, #128
 3314 001a 1206     		lsl	r2, r2, #24
 3315 001c 1A43     		orr	r2, r3
 3316 001e 7B68     		ldr	r3, [r7, #4]
 3317 0020 1A60     		str	r2, [r3]
2980:../freertos/tasks.c **** 
2981:../freertos/tasks.c **** 	/* Remove the event list form the event flag.  Interrupts do not access
2982:../freertos/tasks.c **** 	event flags. */
2983:../freertos/tasks.c **** 	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
 3318              		.loc 1 2983 0
 3319 0022 7B68     		ldr	r3, [r7, #4]
 3320 0024 DB68     		ldr	r3, [r3, #12]
 3321 0026 BB60     		str	r3, [r7, #8]
2984:../freertos/tasks.c **** 	configASSERT( pxUnblockedTCB );
 3322              		.loc 1 2984 0
 3323 0028 BB68     		ldr	r3, [r7, #8]
 3324 002a 002B     		cmp	r3, #0
 3325 002c 01D1     		bne	.L263
 3326              		.loc 1 2984 0 is_stmt 0 discriminator 1
 3327              	@ 2984 "../freertos/tasks.c" 1
 3328 002e 72B6     		 cpsid i 
 3329              	@ 0 "" 2
 3330              		.code	16
 3331              	.L264:
 3332 0030 FEE7     		b	.L264
 3333              	.L263:
2985:../freertos/tasks.c **** 	( void ) uxListRemove( pxEventListItem );
 3334              		.loc 1 2985 0 is_stmt 1
 3335 0032 7B68     		ldr	r3, [r7, #4]
 3336 0034 181C     		mov	r0, r3
 3337 0036 FFF7FEFF 		bl	uxListRemove
2986:../freertos/tasks.c **** 
2987:../freertos/tasks.c **** 	/* Remove the task from the delayed list and add it to the ready list.  The
2988:../freertos/tasks.c **** 	scheduler is suspended so interrupts will not be accessing the ready
2989:../freertos/tasks.c **** 	lists. */
2990:../freertos/tasks.c **** 	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 3338              		.loc 1 2990 0
 3339 003a BB68     		ldr	r3, [r7, #8]
 3340 003c 0433     		add	r3, r3, #4
 3341 003e 181C     		mov	r0, r3
 3342 0040 FFF7FEFF 		bl	uxListRemove
2991:../freertos/tasks.c **** 	prvAddTaskToReadyList( pxUnblockedTCB );
 3343              		.loc 1 2991 0
 3344 0044 BB68     		ldr	r3, [r7, #8]
 3345 0046 DA6A     		ldr	r2, [r3, #44]
 3346 0048 154B     		ldr	r3, .L269+4
 3347 004a 1B68     		ldr	r3, [r3]
 3348 004c 9A42     		cmp	r2, r3
 3349 004e 03D9     		bls	.L265
 3350              		.loc 1 2991 0 is_stmt 0 discriminator 1
 3351 0050 BB68     		ldr	r3, [r7, #8]
 3352 0052 DA6A     		ldr	r2, [r3, #44]
 3353 0054 124B     		ldr	r3, .L269+4
 3354 0056 1A60     		str	r2, [r3]
 3355              	.L265:
 3356              		.loc 1 2991 0 discriminator 2
 3357 0058 BB68     		ldr	r3, [r7, #8]
 3358 005a DA6A     		ldr	r2, [r3, #44]
 3359 005c 131C     		mov	r3, r2
 3360 005e 9B00     		lsl	r3, r3, #2
 3361 0060 9B18     		add	r3, r3, r2
 3362 0062 9B00     		lsl	r3, r3, #2
 3363 0064 0F4A     		ldr	r2, .L269+8
 3364 0066 9A18     		add	r2, r3, r2
 3365 0068 BB68     		ldr	r3, [r7, #8]
 3366 006a 0433     		add	r3, r3, #4
 3367 006c 101C     		mov	r0, r2
 3368 006e 191C     		mov	r1, r3
 3369 0070 FFF7FEFF 		bl	vListInsertEnd
2992:../freertos/tasks.c **** 
2993:../freertos/tasks.c **** 	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 3370              		.loc 1 2993 0 is_stmt 1 discriminator 2
 3371 0074 BB68     		ldr	r3, [r7, #8]
 3372 0076 DA6A     		ldr	r2, [r3, #44]
 3373 0078 0B4B     		ldr	r3, .L269+12
 3374 007a 1B68     		ldr	r3, [r3]
 3375 007c DB6A     		ldr	r3, [r3, #44]
 3376 007e 9A42     		cmp	r2, r3
 3377 0080 05D9     		bls	.L266
2994:../freertos/tasks.c **** 	{
2995:../freertos/tasks.c **** 		/* Return true if the task removed from the event list has
2996:../freertos/tasks.c **** 		a higher priority than the calling task.  This allows
2997:../freertos/tasks.c **** 		the calling task to know if it should force a context
2998:../freertos/tasks.c **** 		switch now. */
2999:../freertos/tasks.c **** 		xReturn = pdTRUE;
 3378              		.loc 1 2999 0
 3379 0082 0123     		mov	r3, #1
 3380 0084 FB60     		str	r3, [r7, #12]
3000:../freertos/tasks.c **** 
3001:../freertos/tasks.c **** 		/* Mark that a yield is pending in case the user is not using the
3002:../freertos/tasks.c **** 		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
3003:../freertos/tasks.c **** 		xYieldPending = pdTRUE;
 3381              		.loc 1 3003 0
 3382 0086 094B     		ldr	r3, .L269+16
 3383 0088 0122     		mov	r2, #1
 3384 008a 1A60     		str	r2, [r3]
 3385 008c 01E0     		b	.L267
 3386              	.L266:
3004:../freertos/tasks.c **** 	}
3005:../freertos/tasks.c **** 	else
3006:../freertos/tasks.c **** 	{
3007:../freertos/tasks.c **** 		xReturn = pdFALSE;
 3387              		.loc 1 3007 0
 3388 008e 0023     		mov	r3, #0
 3389 0090 FB60     		str	r3, [r7, #12]
 3390              	.L267:
3008:../freertos/tasks.c **** 	}
3009:../freertos/tasks.c **** 
3010:../freertos/tasks.c **** 	return xReturn;
 3391              		.loc 1 3010 0
 3392 0092 FB68     		ldr	r3, [r7, #12]
3011:../freertos/tasks.c **** }
 3393              		.loc 1 3011 0
 3394 0094 181C     		mov	r0, r3
 3395 0096 BD46     		mov	sp, r7
 3396 0098 04B0     		add	sp, sp, #16
 3397              		@ sp needed
 3398 009a 80BD     		pop	{r7, pc}
 3399              	.L270:
 3400              		.align	2
 3401              	.L269:
 3402 009c 00000000 		.word	uxSchedulerSuspended
 3403 00a0 00000000 		.word	uxTopReadyPriority
 3404 00a4 00000000 		.word	pxReadyTasksLists
 3405 00a8 00000000 		.word	pxCurrentTCB
 3406 00ac 00000000 		.word	xYieldPending
 3407              		.cfi_endproc
 3408              	.LFE29:
 3410              		.section	.text.vTaskSetTimeOutState,"ax",%progbits
 3411              		.align	2
 3412              		.global	vTaskSetTimeOutState
 3413              		.code	16
 3414              		.thumb_func
 3416              	vTaskSetTimeOutState:
 3417              	.LFB30:
3012:../freertos/tasks.c **** /*-----------------------------------------------------------*/
3013:../freertos/tasks.c **** 
3014:../freertos/tasks.c **** void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
3015:../freertos/tasks.c **** {
 3418              		.loc 1 3015 0
 3419              		.cfi_startproc
 3420 0000 80B5     		push	{r7, lr}
 3421              		.cfi_def_cfa_offset 8
 3422              		.cfi_offset 7, -8
 3423              		.cfi_offset 14, -4
 3424 0002 82B0     		sub	sp, sp, #8
 3425              		.cfi_def_cfa_offset 16
 3426 0004 00AF     		add	r7, sp, #0
 3427              		.cfi_def_cfa_register 7
 3428 0006 7860     		str	r0, [r7, #4]
3016:../freertos/tasks.c **** 	configASSERT( pxTimeOut );
 3429              		.loc 1 3016 0
 3430 0008 7B68     		ldr	r3, [r7, #4]
 3431 000a 002B     		cmp	r3, #0
 3432 000c 01D1     		bne	.L272
 3433              		.loc 1 3016 0 is_stmt 0 discriminator 1
 3434              	@ 3016 "../freertos/tasks.c" 1
 3435 000e 72B6     		 cpsid i 
 3436              	@ 0 "" 2
 3437              		.code	16
 3438              	.L273:
 3439 0010 FEE7     		b	.L273
 3440              	.L272:
3017:../freertos/tasks.c **** 	pxTimeOut->xOverflowCount = xNumOfOverflows;
 3441              		.loc 1 3017 0 is_stmt 1
 3442 0012 054B     		ldr	r3, .L274
 3443 0014 1A68     		ldr	r2, [r3]
 3444 0016 7B68     		ldr	r3, [r7, #4]
 3445 0018 1A60     		str	r2, [r3]
3018:../freertos/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
 3446              		.loc 1 3018 0
 3447 001a 044B     		ldr	r3, .L274+4
 3448 001c 1A68     		ldr	r2, [r3]
 3449 001e 7B68     		ldr	r3, [r7, #4]
 3450 0020 5A60     		str	r2, [r3, #4]
3019:../freertos/tasks.c **** }
 3451              		.loc 1 3019 0
 3452 0022 BD46     		mov	sp, r7
 3453 0024 02B0     		add	sp, sp, #8
 3454              		@ sp needed
 3455 0026 80BD     		pop	{r7, pc}
 3456              	.L275:
 3457              		.align	2
 3458              	.L274:
 3459 0028 00000000 		.word	xNumOfOverflows
 3460 002c 00000000 		.word	xTickCount
 3461              		.cfi_endproc
 3462              	.LFE30:
 3464              		.section	.text.xTaskCheckForTimeOut,"ax",%progbits
 3465              		.align	2
 3466              		.global	xTaskCheckForTimeOut
 3467              		.code	16
 3468              		.thumb_func
 3470              	xTaskCheckForTimeOut:
 3471              	.LFB31:
3020:../freertos/tasks.c **** /*-----------------------------------------------------------*/
3021:../freertos/tasks.c **** 
3022:../freertos/tasks.c **** BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
3023:../freertos/tasks.c **** {
 3472              		.loc 1 3023 0
 3473              		.cfi_startproc
 3474 0000 80B5     		push	{r7, lr}
 3475              		.cfi_def_cfa_offset 8
 3476              		.cfi_offset 7, -8
 3477              		.cfi_offset 14, -4
 3478 0002 84B0     		sub	sp, sp, #16
 3479              		.cfi_def_cfa_offset 24
 3480 0004 00AF     		add	r7, sp, #0
 3481              		.cfi_def_cfa_register 7
 3482 0006 7860     		str	r0, [r7, #4]
 3483 0008 3960     		str	r1, [r7]
3024:../freertos/tasks.c **** BaseType_t xReturn;
3025:../freertos/tasks.c **** 
3026:../freertos/tasks.c **** 	configASSERT( pxTimeOut );
 3484              		.loc 1 3026 0
 3485 000a 7B68     		ldr	r3, [r7, #4]
 3486 000c 002B     		cmp	r3, #0
 3487 000e 01D1     		bne	.L277
 3488              		.loc 1 3026 0 is_stmt 0 discriminator 1
 3489              	@ 3026 "../freertos/tasks.c" 1
 3490 0010 72B6     		 cpsid i 
 3491              	@ 0 "" 2
 3492              		.code	16
 3493              	.L278:
 3494 0012 FEE7     		b	.L278
 3495              	.L277:
3027:../freertos/tasks.c **** 	configASSERT( pxTicksToWait );
 3496              		.loc 1 3027 0 is_stmt 1
 3497 0014 3B68     		ldr	r3, [r7]
 3498 0016 002B     		cmp	r3, #0
 3499 0018 01D1     		bne	.L279
 3500              		.loc 1 3027 0 is_stmt 0 discriminator 1
 3501              	@ 3027 "../freertos/tasks.c" 1
 3502 001a 72B6     		 cpsid i 
 3503              	@ 0 "" 2
 3504              		.code	16
 3505              	.L280:
 3506 001c FEE7     		b	.L280
 3507              	.L279:
3028:../freertos/tasks.c **** 
3029:../freertos/tasks.c **** 	taskENTER_CRITICAL();
 3508              		.loc 1 3029 0 is_stmt 1
 3509 001e FFF7FEFF 		bl	vPortEnterCritical
 3510              	.LBB9:
3030:../freertos/tasks.c **** 	{
3031:../freertos/tasks.c **** 		/* Minor optimisation.  The tick count cannot change in this block. */
3032:../freertos/tasks.c **** 		const TickType_t xConstTickCount = xTickCount;
 3511              		.loc 1 3032 0
 3512 0022 1C4B     		ldr	r3, .L286
 3513 0024 1B68     		ldr	r3, [r3]
 3514 0026 BB60     		str	r3, [r7, #8]
3033:../freertos/tasks.c **** 
3034:../freertos/tasks.c **** 		#if( INCLUDE_xTaskAbortDelay == 1 )
3035:../freertos/tasks.c **** 			if( pxCurrentTCB->ucDelayAborted != pdFALSE )
3036:../freertos/tasks.c **** 			{
3037:../freertos/tasks.c **** 				/* The delay was aborted, which is not the same as a time out,
3038:../freertos/tasks.c **** 				but has the same result. */
3039:../freertos/tasks.c **** 				pxCurrentTCB->ucDelayAborted = pdFALSE;
3040:../freertos/tasks.c **** 				xReturn = pdTRUE;
3041:../freertos/tasks.c **** 			}
3042:../freertos/tasks.c **** 			else
3043:../freertos/tasks.c **** 		#endif
3044:../freertos/tasks.c **** 
3045:../freertos/tasks.c **** 		#if ( INCLUDE_vTaskSuspend == 1 )
3046:../freertos/tasks.c **** 			if( *pxTicksToWait == portMAX_DELAY )
 3515              		.loc 1 3046 0
 3516 0028 3B68     		ldr	r3, [r7]
 3517 002a 1B68     		ldr	r3, [r3]
 3518 002c 0133     		add	r3, r3, #1
 3519 002e 02D1     		bne	.L281
3047:../freertos/tasks.c **** 			{
3048:../freertos/tasks.c **** 				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
3049:../freertos/tasks.c **** 				specified is the maximum block time then the task should block
3050:../freertos/tasks.c **** 				indefinitely, and therefore never time out. */
3051:../freertos/tasks.c **** 				xReturn = pdFALSE;
 3520              		.loc 1 3051 0
 3521 0030 0023     		mov	r3, #0
 3522 0032 FB60     		str	r3, [r7, #12]
 3523 0034 27E0     		b	.L282
 3524              	.L281:
3052:../freertos/tasks.c **** 			}
3053:../freertos/tasks.c **** 			else
3054:../freertos/tasks.c **** 		#endif
3055:../freertos/tasks.c **** 
3056:../freertos/tasks.c **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEn
 3525              		.loc 1 3056 0
 3526 0036 7B68     		ldr	r3, [r7, #4]
 3527 0038 1A68     		ldr	r2, [r3]
 3528 003a 174B     		ldr	r3, .L286+4
 3529 003c 1B68     		ldr	r3, [r3]
 3530 003e 9A42     		cmp	r2, r3
 3531 0040 07D0     		beq	.L283
 3532              		.loc 1 3056 0 is_stmt 0 discriminator 1
 3533 0042 7B68     		ldr	r3, [r7, #4]
 3534 0044 5A68     		ldr	r2, [r3, #4]
 3535 0046 BB68     		ldr	r3, [r7, #8]
 3536 0048 9A42     		cmp	r2, r3
 3537 004a 02D8     		bhi	.L283
3057:../freertos/tasks.c **** 		{
3058:../freertos/tasks.c **** 			/* The tick count is greater than the time at which
3059:../freertos/tasks.c **** 			vTaskSetTimeout() was called, but has also overflowed since
3060:../freertos/tasks.c **** 			vTaskSetTimeOut() was called.  It must have wrapped all the way
3061:../freertos/tasks.c **** 			around and gone past again. This passed since vTaskSetTimeout()
3062:../freertos/tasks.c **** 			was called. */
3063:../freertos/tasks.c **** 			xReturn = pdTRUE;
 3538              		.loc 1 3063 0 is_stmt 1
 3539 004c 0123     		mov	r3, #1
 3540 004e FB60     		str	r3, [r7, #12]
 3541 0050 19E0     		b	.L282
 3542              	.L283:
3064:../freertos/tasks.c **** 		}
3065:../freertos/tasks.c **** 		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /
 3543              		.loc 1 3065 0
 3544 0052 7B68     		ldr	r3, [r7, #4]
 3545 0054 5B68     		ldr	r3, [r3, #4]
 3546 0056 BA68     		ldr	r2, [r7, #8]
 3547 0058 D21A     		sub	r2, r2, r3
 3548 005a 3B68     		ldr	r3, [r7]
 3549 005c 1B68     		ldr	r3, [r3]
 3550 005e 9A42     		cmp	r2, r3
 3551 0060 0FD2     		bcs	.L284
3066:../freertos/tasks.c **** 		{
3067:../freertos/tasks.c **** 			/* Not a genuine timeout. Adjust parameters for time remaining. */
3068:../freertos/tasks.c **** 			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
 3552              		.loc 1 3068 0
 3553 0062 3B68     		ldr	r3, [r7]
 3554 0064 1A68     		ldr	r2, [r3]
 3555 0066 7B68     		ldr	r3, [r7, #4]
 3556 0068 5968     		ldr	r1, [r3, #4]
 3557 006a BB68     		ldr	r3, [r7, #8]
 3558 006c CB1A     		sub	r3, r1, r3
 3559 006e D218     		add	r2, r2, r3
 3560 0070 3B68     		ldr	r3, [r7]
 3561 0072 1A60     		str	r2, [r3]
3069:../freertos/tasks.c **** 			vTaskSetTimeOutState( pxTimeOut );
 3562              		.loc 1 3069 0
 3563 0074 7B68     		ldr	r3, [r7, #4]
 3564 0076 181C     		mov	r0, r3
 3565 0078 FFF7FEFF 		bl	vTaskSetTimeOutState
3070:../freertos/tasks.c **** 			xReturn = pdFALSE;
 3566              		.loc 1 3070 0
 3567 007c 0023     		mov	r3, #0
 3568 007e FB60     		str	r3, [r7, #12]
 3569 0080 01E0     		b	.L282
 3570              	.L284:
3071:../freertos/tasks.c **** 		}
3072:../freertos/tasks.c **** 		else
3073:../freertos/tasks.c **** 		{
3074:../freertos/tasks.c **** 			xReturn = pdTRUE;
 3571              		.loc 1 3074 0
 3572 0082 0123     		mov	r3, #1
 3573 0084 FB60     		str	r3, [r7, #12]
 3574              	.L282:
 3575              	.LBE9:
3075:../freertos/tasks.c **** 		}
3076:../freertos/tasks.c **** 	}
3077:../freertos/tasks.c **** 	taskEXIT_CRITICAL();
 3576              		.loc 1 3077 0
 3577 0086 FFF7FEFF 		bl	vPortExitCritical
3078:../freertos/tasks.c **** 
3079:../freertos/tasks.c **** 	return xReturn;
 3578              		.loc 1 3079 0
 3579 008a FB68     		ldr	r3, [r7, #12]
3080:../freertos/tasks.c **** }
 3580              		.loc 1 3080 0
 3581 008c 181C     		mov	r0, r3
 3582 008e BD46     		mov	sp, r7
 3583 0090 04B0     		add	sp, sp, #16
 3584              		@ sp needed
 3585 0092 80BD     		pop	{r7, pc}
 3586              	.L287:
 3587              		.align	2
 3588              	.L286:
 3589 0094 00000000 		.word	xTickCount
 3590 0098 00000000 		.word	xNumOfOverflows
 3591              		.cfi_endproc
 3592              	.LFE31:
 3594              		.section	.text.vTaskMissedYield,"ax",%progbits
 3595              		.align	2
 3596              		.global	vTaskMissedYield
 3597              		.code	16
 3598              		.thumb_func
 3600              	vTaskMissedYield:
 3601              	.LFB32:
3081:../freertos/tasks.c **** /*-----------------------------------------------------------*/
3082:../freertos/tasks.c **** 
3083:../freertos/tasks.c **** void vTaskMissedYield( void )
3084:../freertos/tasks.c **** {
 3602              		.loc 1 3084 0
 3603              		.cfi_startproc
 3604 0000 80B5     		push	{r7, lr}
 3605              		.cfi_def_cfa_offset 8
 3606              		.cfi_offset 7, -8
 3607              		.cfi_offset 14, -4
 3608 0002 00AF     		add	r7, sp, #0
 3609              		.cfi_def_cfa_register 7
3085:../freertos/tasks.c **** 	xYieldPending = pdTRUE;
 3610              		.loc 1 3085 0
 3611 0004 024B     		ldr	r3, .L289
 3612 0006 0122     		mov	r2, #1
 3613 0008 1A60     		str	r2, [r3]
3086:../freertos/tasks.c **** }
 3614              		.loc 1 3086 0
 3615 000a BD46     		mov	sp, r7
 3616              		@ sp needed
 3617 000c 80BD     		pop	{r7, pc}
 3618              	.L290:
 3619 000e C046     		.align	2
 3620              	.L289:
 3621 0010 00000000 		.word	xYieldPending
 3622              		.cfi_endproc
 3623              	.LFE32:
 3625              		.section	.text.uxTaskGetTaskNumber,"ax",%progbits
 3626              		.align	2
 3627              		.global	uxTaskGetTaskNumber
 3628              		.code	16
 3629              		.thumb_func
 3631              	uxTaskGetTaskNumber:
 3632              	.LFB33:
3087:../freertos/tasks.c **** /*-----------------------------------------------------------*/
3088:../freertos/tasks.c **** 
3089:../freertos/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
3090:../freertos/tasks.c **** 
3091:../freertos/tasks.c **** 	UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
3092:../freertos/tasks.c **** 	{
 3633              		.loc 1 3092 0
 3634              		.cfi_startproc
 3635 0000 80B5     		push	{r7, lr}
 3636              		.cfi_def_cfa_offset 8
 3637              		.cfi_offset 7, -8
 3638              		.cfi_offset 14, -4
 3639 0002 84B0     		sub	sp, sp, #16
 3640              		.cfi_def_cfa_offset 24
 3641 0004 00AF     		add	r7, sp, #0
 3642              		.cfi_def_cfa_register 7
 3643 0006 7860     		str	r0, [r7, #4]
3093:../freertos/tasks.c **** 	UBaseType_t uxReturn;
3094:../freertos/tasks.c **** 	TCB_t *pxTCB;
3095:../freertos/tasks.c **** 
3096:../freertos/tasks.c **** 		if( xTask != NULL )
 3644              		.loc 1 3096 0
 3645 0008 7B68     		ldr	r3, [r7, #4]
 3646 000a 002B     		cmp	r3, #0
 3647 000c 05D0     		beq	.L292
3097:../freertos/tasks.c **** 		{
3098:../freertos/tasks.c **** 			pxTCB = ( TCB_t * ) xTask;
 3648              		.loc 1 3098 0
 3649 000e 7B68     		ldr	r3, [r7, #4]
 3650 0010 BB60     		str	r3, [r7, #8]
3099:../freertos/tasks.c **** 			uxReturn = pxTCB->uxTaskNumber;
 3651              		.loc 1 3099 0
 3652 0012 BB68     		ldr	r3, [r7, #8]
 3653 0014 DB6C     		ldr	r3, [r3, #76]
 3654 0016 FB60     		str	r3, [r7, #12]
 3655 0018 01E0     		b	.L293
 3656              	.L292:
3100:../freertos/tasks.c **** 		}
3101:../freertos/tasks.c **** 		else
3102:../freertos/tasks.c **** 		{
3103:../freertos/tasks.c **** 			uxReturn = 0U;
 3657              		.loc 1 3103 0
 3658 001a 0023     		mov	r3, #0
 3659 001c FB60     		str	r3, [r7, #12]
 3660              	.L293:
3104:../freertos/tasks.c **** 		}
3105:../freertos/tasks.c **** 
3106:../freertos/tasks.c **** 		return uxReturn;
 3661              		.loc 1 3106 0
 3662 001e FB68     		ldr	r3, [r7, #12]
3107:../freertos/tasks.c **** 	}
 3663              		.loc 1 3107 0
 3664 0020 181C     		mov	r0, r3
 3665 0022 BD46     		mov	sp, r7
 3666 0024 04B0     		add	sp, sp, #16
 3667              		@ sp needed
 3668 0026 80BD     		pop	{r7, pc}
 3669              		.cfi_endproc
 3670              	.LFE33:
 3672              		.section	.text.vTaskSetTaskNumber,"ax",%progbits
 3673              		.align	2
 3674              		.global	vTaskSetTaskNumber
 3675              		.code	16
 3676              		.thumb_func
 3678              	vTaskSetTaskNumber:
 3679              	.LFB34:
3108:../freertos/tasks.c **** 
3109:../freertos/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3110:../freertos/tasks.c **** /*-----------------------------------------------------------*/
3111:../freertos/tasks.c **** 
3112:../freertos/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
3113:../freertos/tasks.c **** 
3114:../freertos/tasks.c **** 	void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle )
3115:../freertos/tasks.c **** 	{
 3680              		.loc 1 3115 0
 3681              		.cfi_startproc
 3682 0000 80B5     		push	{r7, lr}
 3683              		.cfi_def_cfa_offset 8
 3684              		.cfi_offset 7, -8
 3685              		.cfi_offset 14, -4
 3686 0002 84B0     		sub	sp, sp, #16
 3687              		.cfi_def_cfa_offset 24
 3688 0004 00AF     		add	r7, sp, #0
 3689              		.cfi_def_cfa_register 7
 3690 0006 7860     		str	r0, [r7, #4]
 3691 0008 3960     		str	r1, [r7]
3116:../freertos/tasks.c **** 	TCB_t *pxTCB;
3117:../freertos/tasks.c **** 
3118:../freertos/tasks.c **** 		if( xTask != NULL )
 3692              		.loc 1 3118 0
 3693 000a 7B68     		ldr	r3, [r7, #4]
 3694 000c 002B     		cmp	r3, #0
 3695 000e 04D0     		beq	.L295
3119:../freertos/tasks.c **** 		{
3120:../freertos/tasks.c **** 			pxTCB = ( TCB_t * ) xTask;
 3696              		.loc 1 3120 0
 3697 0010 7B68     		ldr	r3, [r7, #4]
 3698 0012 FB60     		str	r3, [r7, #12]
3121:../freertos/tasks.c **** 			pxTCB->uxTaskNumber = uxHandle;
 3699              		.loc 1 3121 0
 3700 0014 FB68     		ldr	r3, [r7, #12]
 3701 0016 3A68     		ldr	r2, [r7]
 3702 0018 DA64     		str	r2, [r3, #76]
 3703              	.L295:
3122:../freertos/tasks.c **** 		}
3123:../freertos/tasks.c **** 	}
 3704              		.loc 1 3123 0
 3705 001a BD46     		mov	sp, r7
 3706 001c 04B0     		add	sp, sp, #16
 3707              		@ sp needed
 3708 001e 80BD     		pop	{r7, pc}
 3709              		.cfi_endproc
 3710              	.LFE34:
 3712              		.section	.text.prvIdleTask,"ax",%progbits
 3713              		.align	2
 3714              		.code	16
 3715              		.thumb_func
 3717              	prvIdleTask:
 3718              	.LFB35:
3124:../freertos/tasks.c **** 
3125:../freertos/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3126:../freertos/tasks.c **** 
3127:../freertos/tasks.c **** /*
3128:../freertos/tasks.c ****  * -----------------------------------------------------------
3129:../freertos/tasks.c ****  * The Idle task.
3130:../freertos/tasks.c ****  * ----------------------------------------------------------
3131:../freertos/tasks.c ****  *
3132:../freertos/tasks.c ****  * The portTASK_FUNCTION() macro is used to allow port/compiler specific
3133:../freertos/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
3134:../freertos/tasks.c ****  *
3135:../freertos/tasks.c ****  * void prvIdleTask( void *pvParameters );
3136:../freertos/tasks.c ****  *
3137:../freertos/tasks.c ****  */
3138:../freertos/tasks.c **** static portTASK_FUNCTION( prvIdleTask, pvParameters )
3139:../freertos/tasks.c **** {
 3719              		.loc 1 3139 0
 3720              		.cfi_startproc
 3721 0000 80B5     		push	{r7, lr}
 3722              		.cfi_def_cfa_offset 8
 3723              		.cfi_offset 7, -8
 3724              		.cfi_offset 14, -4
 3725 0002 82B0     		sub	sp, sp, #8
 3726              		.cfi_def_cfa_offset 16
 3727 0004 00AF     		add	r7, sp, #0
 3728              		.cfi_def_cfa_register 7
 3729 0006 7860     		str	r0, [r7, #4]
 3730              	.L299:
3140:../freertos/tasks.c **** 	/* Stop warnings. */
3141:../freertos/tasks.c **** 	( void ) pvParameters;
3142:../freertos/tasks.c **** 
3143:../freertos/tasks.c **** 	/** THIS IS THE RTOS IDLE TASK - WHICH IS CREATED AUTOMATICALLY WHEN THE
3144:../freertos/tasks.c **** 	SCHEDULER IS STARTED. **/
3145:../freertos/tasks.c **** 
3146:../freertos/tasks.c **** 	for( ;; )
3147:../freertos/tasks.c **** 	{
3148:../freertos/tasks.c **** 		/* See if any tasks have deleted themselves - if so then the idle task
3149:../freertos/tasks.c **** 		is responsible for freeing the deleted task's TCB and stack. */
3150:../freertos/tasks.c **** 		prvCheckTasksWaitingTermination();
 3731              		.loc 1 3150 0
 3732 0008 FFF7FEFF 		bl	prvCheckTasksWaitingTermination
3151:../freertos/tasks.c **** 
3152:../freertos/tasks.c **** 		#if ( configUSE_PREEMPTION == 0 )
3153:../freertos/tasks.c **** 		{
3154:../freertos/tasks.c **** 			/* If we are not using preemption we keep forcing a task switch to
3155:../freertos/tasks.c **** 			see if any other task has become available.  If we are using
3156:../freertos/tasks.c **** 			preemption we don't need to do this as any task becoming available
3157:../freertos/tasks.c **** 			will automatically get the processor anyway. */
3158:../freertos/tasks.c **** 			taskYIELD();
3159:../freertos/tasks.c **** 		}
3160:../freertos/tasks.c **** 		#endif /* configUSE_PREEMPTION */
3161:../freertos/tasks.c **** 
3162:../freertos/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
3163:../freertos/tasks.c **** 		{
3164:../freertos/tasks.c **** 			/* When using preemption tasks of equal priority will be
3165:../freertos/tasks.c **** 			timesliced.  If a task that is sharing the idle priority is ready
3166:../freertos/tasks.c **** 			to run then the idle task should yield before the end of the
3167:../freertos/tasks.c **** 			timeslice.
3168:../freertos/tasks.c **** 
3169:../freertos/tasks.c **** 			A critical region is not required here as we are just reading from
3170:../freertos/tasks.c **** 			the list, and an occasional incorrect value will not matter.  If
3171:../freertos/tasks.c **** 			the ready list at the idle priority contains more than one task
3172:../freertos/tasks.c **** 			then a task other than the idle task is ready to execute. */
3173:../freertos/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 3733              		.loc 1 3173 0
 3734 000c 034B     		ldr	r3, .L300
 3735 000e 1B68     		ldr	r3, [r3]
 3736 0010 012B     		cmp	r3, #1
 3737 0012 01D9     		bls	.L298
3174:../freertos/tasks.c **** 			{
3175:../freertos/tasks.c **** 				taskYIELD();
 3738              		.loc 1 3175 0
 3739 0014 FFF7FEFF 		bl	vPortYield
 3740              	.L298:
3176:../freertos/tasks.c **** 			}
3177:../freertos/tasks.c **** 			else
3178:../freertos/tasks.c **** 			{
3179:../freertos/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3180:../freertos/tasks.c **** 			}
3181:../freertos/tasks.c **** 		}
3182:../freertos/tasks.c **** 		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
3183:../freertos/tasks.c **** 
3184:../freertos/tasks.c **** 		#if ( configUSE_IDLE_HOOK == 1 )
3185:../freertos/tasks.c **** 		{
3186:../freertos/tasks.c **** 			extern void vApplicationIdleHook( void );
3187:../freertos/tasks.c **** 
3188:../freertos/tasks.c **** 			/* Call the user defined function from within the idle task.  This
3189:../freertos/tasks.c **** 			allows the application designer to add background functionality
3190:../freertos/tasks.c **** 			without the overhead of a separate task.
3191:../freertos/tasks.c **** 			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
3192:../freertos/tasks.c **** 			CALL A FUNCTION THAT MIGHT BLOCK. */
3193:../freertos/tasks.c **** 			vApplicationIdleHook();
3194:../freertos/tasks.c **** 		}
3195:../freertos/tasks.c **** 		#endif /* configUSE_IDLE_HOOK */
3196:../freertos/tasks.c **** 
3197:../freertos/tasks.c **** 		/* This conditional compilation should use inequality to 0, not equality
3198:../freertos/tasks.c **** 		to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
3199:../freertos/tasks.c **** 		user defined low power mode	implementations require
3200:../freertos/tasks.c **** 		configUSE_TICKLESS_IDLE to be set to a value other than 1. */
3201:../freertos/tasks.c **** 		#if ( configUSE_TICKLESS_IDLE != 0 )
3202:../freertos/tasks.c **** 		{
3203:../freertos/tasks.c **** 		TickType_t xExpectedIdleTime;
3204:../freertos/tasks.c **** 
3205:../freertos/tasks.c **** 			/* It is not desirable to suspend then resume the scheduler on
3206:../freertos/tasks.c **** 			each iteration of the idle task.  Therefore, a preliminary
3207:../freertos/tasks.c **** 			test of the expected idle time is performed without the
3208:../freertos/tasks.c **** 			scheduler suspended.  The result here is not necessarily
3209:../freertos/tasks.c **** 			valid. */
3210:../freertos/tasks.c **** 			xExpectedIdleTime = prvGetExpectedIdleTime();
3211:../freertos/tasks.c **** 
3212:../freertos/tasks.c **** 			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
3213:../freertos/tasks.c **** 			{
3214:../freertos/tasks.c **** 				vTaskSuspendAll();
3215:../freertos/tasks.c **** 				{
3216:../freertos/tasks.c **** 					/* Now the scheduler is suspended, the expected idle
3217:../freertos/tasks.c **** 					time can be sampled again, and this time its value can
3218:../freertos/tasks.c **** 					be used. */
3219:../freertos/tasks.c **** 					configASSERT( xNextTaskUnblockTime >= xTickCount );
3220:../freertos/tasks.c **** 					xExpectedIdleTime = prvGetExpectedIdleTime();
3221:../freertos/tasks.c **** 
3222:../freertos/tasks.c **** 					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
3223:../freertos/tasks.c **** 					{
3224:../freertos/tasks.c **** 						traceLOW_POWER_IDLE_BEGIN();
3225:../freertos/tasks.c **** 						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
3226:../freertos/tasks.c **** 						traceLOW_POWER_IDLE_END();
3227:../freertos/tasks.c **** 					}
3228:../freertos/tasks.c **** 					else
3229:../freertos/tasks.c **** 					{
3230:../freertos/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
3231:../freertos/tasks.c **** 					}
3232:../freertos/tasks.c **** 				}
3233:../freertos/tasks.c **** 				( void ) xTaskResumeAll();
3234:../freertos/tasks.c **** 			}
3235:../freertos/tasks.c **** 			else
3236:../freertos/tasks.c **** 			{
3237:../freertos/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3238:../freertos/tasks.c **** 			}
3239:../freertos/tasks.c **** 		}
3240:../freertos/tasks.c **** 		#endif /* configUSE_TICKLESS_IDLE */
3241:../freertos/tasks.c **** 	}
 3741              		.loc 1 3241 0
 3742 0018 F6E7     		b	.L299
 3743              	.L301:
 3744 001a C046     		.align	2
 3745              	.L300:
 3746 001c 00000000 		.word	pxReadyTasksLists
 3747              		.cfi_endproc
 3748              	.LFE35:
 3750              		.section	.text.vTaskSetThreadLocalStoragePointer,"ax",%progbits
 3751              		.align	2
 3752              		.global	vTaskSetThreadLocalStoragePointer
 3753              		.code	16
 3754              		.thumb_func
 3756              	vTaskSetThreadLocalStoragePointer:
 3757              	.LFB36:
3242:../freertos/tasks.c **** }
3243:../freertos/tasks.c **** /*-----------------------------------------------------------*/
3244:../freertos/tasks.c **** 
3245:../freertos/tasks.c **** #if( configUSE_TICKLESS_IDLE != 0 )
3246:../freertos/tasks.c **** 
3247:../freertos/tasks.c **** 	eSleepModeStatus eTaskConfirmSleepModeStatus( void )
3248:../freertos/tasks.c **** 	{
3249:../freertos/tasks.c **** 	/* The idle task exists in addition to the application tasks. */
3250:../freertos/tasks.c **** 	const UBaseType_t uxNonApplicationTasks = 1;
3251:../freertos/tasks.c **** 	eSleepModeStatus eReturn = eStandardSleep;
3252:../freertos/tasks.c **** 
3253:../freertos/tasks.c **** 		if( listCURRENT_LIST_LENGTH( &xPendingReadyList ) != 0 )
3254:../freertos/tasks.c **** 		{
3255:../freertos/tasks.c **** 			/* A task was made ready while the scheduler was suspended. */
3256:../freertos/tasks.c **** 			eReturn = eAbortSleep;
3257:../freertos/tasks.c **** 		}
3258:../freertos/tasks.c **** 		else if( xYieldPending != pdFALSE )
3259:../freertos/tasks.c **** 		{
3260:../freertos/tasks.c **** 			/* A yield was pended while the scheduler was suspended. */
3261:../freertos/tasks.c **** 			eReturn = eAbortSleep;
3262:../freertos/tasks.c **** 		}
3263:../freertos/tasks.c **** 		else
3264:../freertos/tasks.c **** 		{
3265:../freertos/tasks.c **** 			/* If all the tasks are in the suspended list (which might mean they
3266:../freertos/tasks.c **** 			have an infinite block time rather than actually being suspended)
3267:../freertos/tasks.c **** 			then it is safe to turn all clocks off and just wait for external
3268:../freertos/tasks.c **** 			interrupts. */
3269:../freertos/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == ( uxCurrentNumberOfTasks - uxNonApplicatio
3270:../freertos/tasks.c **** 			{
3271:../freertos/tasks.c **** 				eReturn = eNoTasksWaitingTimeout;
3272:../freertos/tasks.c **** 			}
3273:../freertos/tasks.c **** 			else
3274:../freertos/tasks.c **** 			{
3275:../freertos/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3276:../freertos/tasks.c **** 			}
3277:../freertos/tasks.c **** 		}
3278:../freertos/tasks.c **** 
3279:../freertos/tasks.c **** 		return eReturn;
3280:../freertos/tasks.c **** 	}
3281:../freertos/tasks.c **** 
3282:../freertos/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
3283:../freertos/tasks.c **** /*-----------------------------------------------------------*/
3284:../freertos/tasks.c **** 
3285:../freertos/tasks.c **** #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
3286:../freertos/tasks.c **** 
3287:../freertos/tasks.c **** 	void vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue 
3288:../freertos/tasks.c **** 	{
 3758              		.loc 1 3288 0
 3759              		.cfi_startproc
 3760 0000 80B5     		push	{r7, lr}
 3761              		.cfi_def_cfa_offset 8
 3762              		.cfi_offset 7, -8
 3763              		.cfi_offset 14, -4
 3764 0002 86B0     		sub	sp, sp, #24
 3765              		.cfi_def_cfa_offset 32
 3766 0004 00AF     		add	r7, sp, #0
 3767              		.cfi_def_cfa_register 7
 3768 0006 F860     		str	r0, [r7, #12]
 3769 0008 B960     		str	r1, [r7, #8]
 3770 000a 7A60     		str	r2, [r7, #4]
3289:../freertos/tasks.c **** 	TCB_t *pxTCB;
3290:../freertos/tasks.c **** 
3291:../freertos/tasks.c **** 		if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
 3771              		.loc 1 3291 0
 3772 000c BB68     		ldr	r3, [r7, #8]
 3773 000e 042B     		cmp	r3, #4
 3774 0010 0DDC     		bgt	.L302
3292:../freertos/tasks.c **** 		{
3293:../freertos/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToSet );
 3775              		.loc 1 3293 0
 3776 0012 FB68     		ldr	r3, [r7, #12]
 3777 0014 002B     		cmp	r3, #0
 3778 0016 02D1     		bne	.L304
 3779              		.loc 1 3293 0 is_stmt 0 discriminator 1
 3780 0018 064B     		ldr	r3, .L306
 3781 001a 1B68     		ldr	r3, [r3]
 3782 001c 00E0     		b	.L305
 3783              	.L304:
 3784              		.loc 1 3293 0 discriminator 2
 3785 001e FB68     		ldr	r3, [r7, #12]
 3786              	.L305:
 3787              		.loc 1 3293 0 discriminator 3
 3788 0020 7B61     		str	r3, [r7, #20]
3294:../freertos/tasks.c **** 			pxTCB->pvThreadLocalStoragePointers[ xIndex ] = pvValue;
 3789              		.loc 1 3294 0 is_stmt 1 discriminator 3
 3790 0022 7B69     		ldr	r3, [r7, #20]
 3791 0024 BA68     		ldr	r2, [r7, #8]
 3792 0026 1632     		add	r2, r2, #22
 3793 0028 9200     		lsl	r2, r2, #2
 3794 002a 7968     		ldr	r1, [r7, #4]
 3795 002c D150     		str	r1, [r2, r3]
 3796              	.L302:
3295:../freertos/tasks.c **** 		}
3296:../freertos/tasks.c **** 	}
 3797              		.loc 1 3296 0
 3798 002e BD46     		mov	sp, r7
 3799 0030 06B0     		add	sp, sp, #24
 3800              		@ sp needed
 3801 0032 80BD     		pop	{r7, pc}
 3802              	.L307:
 3803              		.align	2
 3804              	.L306:
 3805 0034 00000000 		.word	pxCurrentTCB
 3806              		.cfi_endproc
 3807              	.LFE36:
 3809              		.section	.text.pvTaskGetThreadLocalStoragePointer,"ax",%progbits
 3810              		.align	2
 3811              		.global	pvTaskGetThreadLocalStoragePointer
 3812              		.code	16
 3813              		.thumb_func
 3815              	pvTaskGetThreadLocalStoragePointer:
 3816              	.LFB37:
3297:../freertos/tasks.c **** 
3298:../freertos/tasks.c **** #endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
3299:../freertos/tasks.c **** /*-----------------------------------------------------------*/
3300:../freertos/tasks.c **** 
3301:../freertos/tasks.c **** #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
3302:../freertos/tasks.c **** 
3303:../freertos/tasks.c **** 	void *pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery, BaseType_t xIndex )
3304:../freertos/tasks.c **** 	{
 3817              		.loc 1 3304 0
 3818              		.cfi_startproc
 3819 0000 80B5     		push	{r7, lr}
 3820              		.cfi_def_cfa_offset 8
 3821              		.cfi_offset 7, -8
 3822              		.cfi_offset 14, -4
 3823 0002 84B0     		sub	sp, sp, #16
 3824              		.cfi_def_cfa_offset 24
 3825 0004 00AF     		add	r7, sp, #0
 3826              		.cfi_def_cfa_register 7
 3827 0006 7860     		str	r0, [r7, #4]
 3828 0008 3960     		str	r1, [r7]
3305:../freertos/tasks.c **** 	void *pvReturn = NULL;
 3829              		.loc 1 3305 0
 3830 000a 0023     		mov	r3, #0
 3831 000c FB60     		str	r3, [r7, #12]
3306:../freertos/tasks.c **** 	TCB_t *pxTCB;
3307:../freertos/tasks.c **** 
3308:../freertos/tasks.c **** 		if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
 3832              		.loc 1 3308 0
 3833 000e 3B68     		ldr	r3, [r7]
 3834 0010 042B     		cmp	r3, #4
 3835 0012 0EDC     		bgt	.L309
3309:../freertos/tasks.c **** 		{
3310:../freertos/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToQuery );
 3836              		.loc 1 3310 0
 3837 0014 7B68     		ldr	r3, [r7, #4]
 3838 0016 002B     		cmp	r3, #0
 3839 0018 02D1     		bne	.L310
 3840              		.loc 1 3310 0 is_stmt 0 discriminator 1
 3841 001a 094B     		ldr	r3, .L314
 3842 001c 1B68     		ldr	r3, [r3]
 3843 001e 00E0     		b	.L311
 3844              	.L310:
 3845              		.loc 1 3310 0 discriminator 2
 3846 0020 7B68     		ldr	r3, [r7, #4]
 3847              	.L311:
 3848              		.loc 1 3310 0 discriminator 1
 3849 0022 BB60     		str	r3, [r7, #8]
3311:../freertos/tasks.c **** 			pvReturn = pxTCB->pvThreadLocalStoragePointers[ xIndex ];
 3850              		.loc 1 3311 0 is_stmt 1 discriminator 1
 3851 0024 BB68     		ldr	r3, [r7, #8]
 3852 0026 3A68     		ldr	r2, [r7]
 3853 0028 1632     		add	r2, r2, #22
 3854 002a 9200     		lsl	r2, r2, #2
 3855 002c D358     		ldr	r3, [r2, r3]
 3856 002e FB60     		str	r3, [r7, #12]
 3857 0030 01E0     		b	.L312
 3858              	.L309:
3312:../freertos/tasks.c **** 		}
3313:../freertos/tasks.c **** 		else
3314:../freertos/tasks.c **** 		{
3315:../freertos/tasks.c **** 			pvReturn = NULL;
 3859              		.loc 1 3315 0
 3860 0032 0023     		mov	r3, #0
 3861 0034 FB60     		str	r3, [r7, #12]
 3862              	.L312:
3316:../freertos/tasks.c **** 		}
3317:../freertos/tasks.c **** 
3318:../freertos/tasks.c **** 		return pvReturn;
 3863              		.loc 1 3318 0
 3864 0036 FB68     		ldr	r3, [r7, #12]
3319:../freertos/tasks.c **** 	}
 3865              		.loc 1 3319 0
 3866 0038 181C     		mov	r0, r3
 3867 003a BD46     		mov	sp, r7
 3868 003c 04B0     		add	sp, sp, #16
 3869              		@ sp needed
 3870 003e 80BD     		pop	{r7, pc}
 3871              	.L315:
 3872              		.align	2
 3873              	.L314:
 3874 0040 00000000 		.word	pxCurrentTCB
 3875              		.cfi_endproc
 3876              	.LFE37:
 3878              		.section	.text.prvInitialiseTaskLists,"ax",%progbits
 3879              		.align	2
 3880              		.code	16
 3881              		.thumb_func
 3883              	prvInitialiseTaskLists:
 3884              	.LFB38:
3320:../freertos/tasks.c **** 
3321:../freertos/tasks.c **** #endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
3322:../freertos/tasks.c **** /*-----------------------------------------------------------*/
3323:../freertos/tasks.c **** 
3324:../freertos/tasks.c **** #if ( portUSING_MPU_WRAPPERS == 1 )
3325:../freertos/tasks.c **** 
3326:../freertos/tasks.c **** 	void vTaskAllocateMPURegions( TaskHandle_t xTaskToModify, const MemoryRegion_t * const xRegions )
3327:../freertos/tasks.c **** 	{
3328:../freertos/tasks.c **** 	TCB_t *pxTCB;
3329:../freertos/tasks.c **** 
3330:../freertos/tasks.c **** 		/* If null is passed in here then we are modifying the MPU settings of
3331:../freertos/tasks.c **** 		the calling task. */
3332:../freertos/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToModify );
3333:../freertos/tasks.c **** 
3334:../freertos/tasks.c **** 		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
3335:../freertos/tasks.c **** 	}
3336:../freertos/tasks.c **** 
3337:../freertos/tasks.c **** #endif /* portUSING_MPU_WRAPPERS */
3338:../freertos/tasks.c **** /*-----------------------------------------------------------*/
3339:../freertos/tasks.c **** 
3340:../freertos/tasks.c **** static void prvInitialiseTaskLists( void )
3341:../freertos/tasks.c **** {
 3885              		.loc 1 3341 0
 3886              		.cfi_startproc
 3887 0000 80B5     		push	{r7, lr}
 3888              		.cfi_def_cfa_offset 8
 3889              		.cfi_offset 7, -8
 3890              		.cfi_offset 14, -4
 3891 0002 82B0     		sub	sp, sp, #8
 3892              		.cfi_def_cfa_offset 16
 3893 0004 00AF     		add	r7, sp, #0
 3894              		.cfi_def_cfa_register 7
3342:../freertos/tasks.c **** UBaseType_t uxPriority;
3343:../freertos/tasks.c **** 
3344:../freertos/tasks.c **** 	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriorit
 3895              		.loc 1 3344 0
 3896 0006 0023     		mov	r3, #0
 3897 0008 7B60     		str	r3, [r7, #4]
 3898 000a 0CE0     		b	.L317
 3899              	.L318:
3345:../freertos/tasks.c **** 	{
3346:../freertos/tasks.c **** 		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 3900              		.loc 1 3346 0 discriminator 2
 3901 000c 7A68     		ldr	r2, [r7, #4]
 3902 000e 131C     		mov	r3, r2
 3903 0010 9B00     		lsl	r3, r3, #2
 3904 0012 9B18     		add	r3, r3, r2
 3905 0014 9B00     		lsl	r3, r3, #2
 3906 0016 144A     		ldr	r2, .L319
 3907 0018 9B18     		add	r3, r3, r2
 3908 001a 181C     		mov	r0, r3
 3909 001c FFF7FEFF 		bl	vListInitialise
3344:../freertos/tasks.c **** 	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriorit
 3910              		.loc 1 3344 0 discriminator 2
 3911 0020 7B68     		ldr	r3, [r7, #4]
 3912 0022 0133     		add	r3, r3, #1
 3913 0024 7B60     		str	r3, [r7, #4]
 3914              	.L317:
3344:../freertos/tasks.c **** 	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriorit
 3915              		.loc 1 3344 0 is_stmt 0 discriminator 1
 3916 0026 7B68     		ldr	r3, [r7, #4]
 3917 0028 042B     		cmp	r3, #4
 3918 002a EFD9     		bls	.L318
3347:../freertos/tasks.c **** 	}
3348:../freertos/tasks.c **** 
3349:../freertos/tasks.c **** 	vListInitialise( &xDelayedTaskList1 );
 3919              		.loc 1 3349 0 is_stmt 1
 3920 002c 0F4B     		ldr	r3, .L319+4
 3921 002e 181C     		mov	r0, r3
 3922 0030 FFF7FEFF 		bl	vListInitialise
3350:../freertos/tasks.c **** 	vListInitialise( &xDelayedTaskList2 );
 3923              		.loc 1 3350 0
 3924 0034 0E4B     		ldr	r3, .L319+8
 3925 0036 181C     		mov	r0, r3
 3926 0038 FFF7FEFF 		bl	vListInitialise
3351:../freertos/tasks.c **** 	vListInitialise( &xPendingReadyList );
 3927              		.loc 1 3351 0
 3928 003c 0D4B     		ldr	r3, .L319+12
 3929 003e 181C     		mov	r0, r3
 3930 0040 FFF7FEFF 		bl	vListInitialise
3352:../freertos/tasks.c **** 
3353:../freertos/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
3354:../freertos/tasks.c **** 	{
3355:../freertos/tasks.c **** 		vListInitialise( &xTasksWaitingTermination );
 3931              		.loc 1 3355 0
 3932 0044 0C4B     		ldr	r3, .L319+16
 3933 0046 181C     		mov	r0, r3
 3934 0048 FFF7FEFF 		bl	vListInitialise
3356:../freertos/tasks.c **** 	}
3357:../freertos/tasks.c **** 	#endif /* INCLUDE_vTaskDelete */
3358:../freertos/tasks.c **** 
3359:../freertos/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
3360:../freertos/tasks.c **** 	{
3361:../freertos/tasks.c **** 		vListInitialise( &xSuspendedTaskList );
 3935              		.loc 1 3361 0
 3936 004c 0B4B     		ldr	r3, .L319+20
 3937 004e 181C     		mov	r0, r3
 3938 0050 FFF7FEFF 		bl	vListInitialise
3362:../freertos/tasks.c **** 	}
3363:../freertos/tasks.c **** 	#endif /* INCLUDE_vTaskSuspend */
3364:../freertos/tasks.c **** 
3365:../freertos/tasks.c **** 	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
3366:../freertos/tasks.c **** 	using list2. */
3367:../freertos/tasks.c **** 	pxDelayedTaskList = &xDelayedTaskList1;
 3939              		.loc 1 3367 0
 3940 0054 0A4B     		ldr	r3, .L319+24
 3941 0056 054A     		ldr	r2, .L319+4
 3942 0058 1A60     		str	r2, [r3]
3368:../freertos/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 3943              		.loc 1 3368 0
 3944 005a 0A4B     		ldr	r3, .L319+28
 3945 005c 044A     		ldr	r2, .L319+8
 3946 005e 1A60     		str	r2, [r3]
3369:../freertos/tasks.c **** }
 3947              		.loc 1 3369 0
 3948 0060 BD46     		mov	sp, r7
 3949 0062 02B0     		add	sp, sp, #8
 3950              		@ sp needed
 3951 0064 80BD     		pop	{r7, pc}
 3952              	.L320:
 3953 0066 C046     		.align	2
 3954              	.L319:
 3955 0068 00000000 		.word	pxReadyTasksLists
 3956 006c 00000000 		.word	xDelayedTaskList1
 3957 0070 00000000 		.word	xDelayedTaskList2
 3958 0074 00000000 		.word	xPendingReadyList
 3959 0078 00000000 		.word	xTasksWaitingTermination
 3960 007c 00000000 		.word	xSuspendedTaskList
 3961 0080 00000000 		.word	pxDelayedTaskList
 3962 0084 00000000 		.word	pxOverflowDelayedTaskList
 3963              		.cfi_endproc
 3964              	.LFE38:
 3966              		.section	.text.prvCheckTasksWaitingTermination,"ax",%progbits
 3967              		.align	2
 3968              		.code	16
 3969              		.thumb_func
 3971              	prvCheckTasksWaitingTermination:
 3972              	.LFB39:
3370:../freertos/tasks.c **** /*-----------------------------------------------------------*/
3371:../freertos/tasks.c **** 
3372:../freertos/tasks.c **** static void prvCheckTasksWaitingTermination( void )
3373:../freertos/tasks.c **** {
 3973              		.loc 1 3373 0
 3974              		.cfi_startproc
 3975 0000 80B5     		push	{r7, lr}
 3976              		.cfi_def_cfa_offset 8
 3977              		.cfi_offset 7, -8
 3978              		.cfi_offset 14, -4
 3979 0002 82B0     		sub	sp, sp, #8
 3980              		.cfi_def_cfa_offset 16
 3981 0004 00AF     		add	r7, sp, #0
 3982              		.cfi_def_cfa_register 7
 3983              	.LBB10:
3374:../freertos/tasks.c **** 
3375:../freertos/tasks.c **** 	/** THIS FUNCTION IS CALLED FROM THE RTOS IDLE TASK **/
3376:../freertos/tasks.c **** 
3377:../freertos/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
3378:../freertos/tasks.c **** 	{
3379:../freertos/tasks.c **** 		BaseType_t xListIsEmpty;
3380:../freertos/tasks.c **** 
3381:../freertos/tasks.c **** 		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
3382:../freertos/tasks.c **** 		too often in the idle task. */
3383:../freertos/tasks.c **** 		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 3984              		.loc 1 3383 0
 3985 0006 27E0     		b	.L322
 3986              	.L323:
3384:../freertos/tasks.c **** 		{
3385:../freertos/tasks.c **** 			vTaskSuspendAll();
 3987              		.loc 1 3385 0
 3988 0008 FFF7FEFF 		bl	vTaskSuspendAll
3386:../freertos/tasks.c **** 			{
3387:../freertos/tasks.c **** 				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 3989              		.loc 1 3387 0
 3990 000c 164B     		ldr	r3, .L324
 3991 000e 1B68     		ldr	r3, [r3]
 3992 0010 5A42     		neg	r2, r3
 3993 0012 5341     		adc	r3, r3, r2
 3994 0014 DBB2     		uxtb	r3, r3
 3995 0016 7B60     		str	r3, [r7, #4]
3388:../freertos/tasks.c **** 			}
3389:../freertos/tasks.c **** 			( void ) xTaskResumeAll();
 3996              		.loc 1 3389 0
 3997 0018 FFF7FEFF 		bl	xTaskResumeAll
3390:../freertos/tasks.c **** 
3391:../freertos/tasks.c **** 			if( xListIsEmpty == pdFALSE )
 3998              		.loc 1 3391 0
 3999 001c 7B68     		ldr	r3, [r7, #4]
 4000 001e 002B     		cmp	r3, #0
 4001 0020 1AD1     		bne	.L322
 4002              	.LBB11:
3392:../freertos/tasks.c **** 			{
3393:../freertos/tasks.c **** 				TCB_t *pxTCB;
3394:../freertos/tasks.c **** 
3395:../freertos/tasks.c **** 				taskENTER_CRITICAL();
 4003              		.loc 1 3395 0
 4004 0022 FFF7FEFF 		bl	vPortEnterCritical
3396:../freertos/tasks.c **** 				{
3397:../freertos/tasks.c **** 					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 4005              		.loc 1 3397 0
 4006 0026 104B     		ldr	r3, .L324
 4007 0028 DB68     		ldr	r3, [r3, #12]
 4008 002a DB68     		ldr	r3, [r3, #12]
 4009 002c 3B60     		str	r3, [r7]
3398:../freertos/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 4010              		.loc 1 3398 0
 4011 002e 3B68     		ldr	r3, [r7]
 4012 0030 0433     		add	r3, r3, #4
 4013 0032 181C     		mov	r0, r3
 4014 0034 FFF7FEFF 		bl	uxListRemove
3399:../freertos/tasks.c **** 					--uxCurrentNumberOfTasks;
 4015              		.loc 1 3399 0
 4016 0038 0C4B     		ldr	r3, .L324+4
 4017 003a 1B68     		ldr	r3, [r3]
 4018 003c 5A1E     		sub	r2, r3, #1
 4019 003e 0B4B     		ldr	r3, .L324+4
 4020 0040 1A60     		str	r2, [r3]
3400:../freertos/tasks.c **** 					--uxDeletedTasksWaitingCleanUp;
 4021              		.loc 1 3400 0
 4022 0042 0B4B     		ldr	r3, .L324+8
 4023 0044 1B68     		ldr	r3, [r3]
 4024 0046 5A1E     		sub	r2, r3, #1
 4025 0048 094B     		ldr	r3, .L324+8
 4026 004a 1A60     		str	r2, [r3]
3401:../freertos/tasks.c **** 				}
3402:../freertos/tasks.c **** 				taskEXIT_CRITICAL();
 4027              		.loc 1 3402 0
 4028 004c FFF7FEFF 		bl	vPortExitCritical
3403:../freertos/tasks.c **** 
3404:../freertos/tasks.c **** 				prvDeleteTCB( pxTCB );
 4029              		.loc 1 3404 0
 4030 0050 3B68     		ldr	r3, [r7]
 4031 0052 181C     		mov	r0, r3
 4032 0054 FFF7FEFF 		bl	prvDeleteTCB
 4033              	.L322:
 4034              	.LBE11:
3383:../freertos/tasks.c **** 		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 4035              		.loc 1 3383 0 discriminator 1
 4036 0058 054B     		ldr	r3, .L324+8
 4037 005a 1B68     		ldr	r3, [r3]
 4038 005c 002B     		cmp	r3, #0
 4039 005e D3D1     		bne	.L323
 4040              	.LBE10:
3405:../freertos/tasks.c **** 			}
3406:../freertos/tasks.c **** 			else
3407:../freertos/tasks.c **** 			{
3408:../freertos/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3409:../freertos/tasks.c **** 			}
3410:../freertos/tasks.c **** 		}
3411:../freertos/tasks.c **** 	}
3412:../freertos/tasks.c **** 	#endif /* INCLUDE_vTaskDelete */
3413:../freertos/tasks.c **** }
 4041              		.loc 1 3413 0
 4042 0060 BD46     		mov	sp, r7
 4043 0062 02B0     		add	sp, sp, #8
 4044              		@ sp needed
 4045 0064 80BD     		pop	{r7, pc}
 4046              	.L325:
 4047 0066 C046     		.align	2
 4048              	.L324:
 4049 0068 00000000 		.word	xTasksWaitingTermination
 4050 006c 00000000 		.word	uxCurrentNumberOfTasks
 4051 0070 00000000 		.word	uxDeletedTasksWaitingCleanUp
 4052              		.cfi_endproc
 4053              	.LFE39:
 4055              		.section	.text.vTaskGetInfo,"ax",%progbits
 4056              		.align	2
 4057              		.global	vTaskGetInfo
 4058              		.code	16
 4059              		.thumb_func
 4061              	vTaskGetInfo:
 4062              	.LFB40:
3414:../freertos/tasks.c **** /*-----------------------------------------------------------*/
3415:../freertos/tasks.c **** 
3416:../freertos/tasks.c **** #if( configUSE_TRACE_FACILITY == 1 )
3417:../freertos/tasks.c **** 
3418:../freertos/tasks.c **** 	void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, 
3419:../freertos/tasks.c **** 	{
 4063              		.loc 1 3419 0
 4064              		.cfi_startproc
 4065 0000 80B5     		push	{r7, lr}
 4066              		.cfi_def_cfa_offset 8
 4067              		.cfi_offset 7, -8
 4068              		.cfi_offset 14, -4
 4069 0002 86B0     		sub	sp, sp, #24
 4070              		.cfi_def_cfa_offset 32
 4071 0004 00AF     		add	r7, sp, #0
 4072              		.cfi_def_cfa_register 7
 4073 0006 F860     		str	r0, [r7, #12]
 4074 0008 B960     		str	r1, [r7, #8]
 4075 000a 7A60     		str	r2, [r7, #4]
 4076 000c 1A1C     		mov	r2, r3
 4077 000e FB1C     		add	r3, r7, #3
 4078 0010 1A70     		strb	r2, [r3]
3420:../freertos/tasks.c **** 	TCB_t *pxTCB;
3421:../freertos/tasks.c **** 
3422:../freertos/tasks.c **** 		/* xTask is NULL then get the state of the calling task. */
3423:../freertos/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
 4079              		.loc 1 3423 0
 4080 0012 FB68     		ldr	r3, [r7, #12]
 4081 0014 002B     		cmp	r3, #0
 4082 0016 02D1     		bne	.L327
 4083              		.loc 1 3423 0 is_stmt 0 discriminator 1
 4084 0018 294B     		ldr	r3, .L335
 4085 001a 1B68     		ldr	r3, [r3]
 4086 001c 00E0     		b	.L328
 4087              	.L327:
 4088              		.loc 1 3423 0 discriminator 2
 4089 001e FB68     		ldr	r3, [r7, #12]
 4090              	.L328:
 4091              		.loc 1 3423 0 discriminator 3
 4092 0020 7B61     		str	r3, [r7, #20]
3424:../freertos/tasks.c **** 
3425:../freertos/tasks.c **** 		pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
 4093              		.loc 1 3425 0 is_stmt 1 discriminator 3
 4094 0022 BB68     		ldr	r3, [r7, #8]
 4095 0024 7A69     		ldr	r2, [r7, #20]
 4096 0026 1A60     		str	r2, [r3]
3426:../freertos/tasks.c **** 		pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName [ 0 ] );
 4097              		.loc 1 3426 0 discriminator 3
 4098 0028 7B69     		ldr	r3, [r7, #20]
 4099 002a 1A1C     		mov	r2, r3
 4100 002c 3432     		add	r2, r2, #52
 4101 002e BB68     		ldr	r3, [r7, #8]
 4102 0030 5A60     		str	r2, [r3, #4]
3427:../freertos/tasks.c **** 		pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
 4103              		.loc 1 3427 0 discriminator 3
 4104 0032 7B69     		ldr	r3, [r7, #20]
 4105 0034 DA6A     		ldr	r2, [r3, #44]
 4106 0036 BB68     		ldr	r3, [r7, #8]
 4107 0038 1A61     		str	r2, [r3, #16]
3428:../freertos/tasks.c **** 		pxTaskStatus->pxStackBase = pxTCB->pxStack;
 4108              		.loc 1 3428 0 discriminator 3
 4109 003a 7B69     		ldr	r3, [r7, #20]
 4110 003c 1A6B     		ldr	r2, [r3, #48]
 4111 003e BB68     		ldr	r3, [r7, #8]
 4112 0040 DA61     		str	r2, [r3, #28]
3429:../freertos/tasks.c **** 		pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
 4113              		.loc 1 3429 0 discriminator 3
 4114 0042 7B69     		ldr	r3, [r7, #20]
 4115 0044 9A6C     		ldr	r2, [r3, #72]
 4116 0046 BB68     		ldr	r3, [r7, #8]
 4117 0048 9A60     		str	r2, [r3, #8]
3430:../freertos/tasks.c **** 
3431:../freertos/tasks.c **** 		#if ( INCLUDE_vTaskSuspend == 1 )
3432:../freertos/tasks.c **** 		{
3433:../freertos/tasks.c **** 			/* If the task is in the suspended list then there is a chance it is
3434:../freertos/tasks.c **** 			actually just blocked indefinitely - so really it should be reported as
3435:../freertos/tasks.c **** 			being in the Blocked state. */
3436:../freertos/tasks.c **** 			if( pxTaskStatus->eCurrentState == eSuspended )
 4118              		.loc 1 3436 0 discriminator 3
 4119 004a BB68     		ldr	r3, [r7, #8]
 4120 004c 1B7B     		ldrb	r3, [r3, #12]
 4121 004e 032B     		cmp	r3, #3
 4122 0050 0AD1     		bne	.L329
3437:../freertos/tasks.c **** 			{
3438:../freertos/tasks.c **** 				vTaskSuspendAll();
 4123              		.loc 1 3438 0
 4124 0052 FFF7FEFF 		bl	vTaskSuspendAll
3439:../freertos/tasks.c **** 				{
3440:../freertos/tasks.c **** 					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 4125              		.loc 1 3440 0
 4126 0056 7B69     		ldr	r3, [r7, #20]
 4127 0058 9B6A     		ldr	r3, [r3, #40]
 4128 005a 002B     		cmp	r3, #0
 4129 005c 02D0     		beq	.L330
3441:../freertos/tasks.c **** 					{
3442:../freertos/tasks.c **** 						pxTaskStatus->eCurrentState = eBlocked;
 4130              		.loc 1 3442 0
 4131 005e BB68     		ldr	r3, [r7, #8]
 4132 0060 0222     		mov	r2, #2
 4133 0062 1A73     		strb	r2, [r3, #12]
 4134              	.L330:
3443:../freertos/tasks.c **** 					}
3444:../freertos/tasks.c **** 				}
3445:../freertos/tasks.c **** 				xTaskResumeAll();
 4135              		.loc 1 3445 0
 4136 0064 FFF7FEFF 		bl	xTaskResumeAll
 4137              	.L329:
3446:../freertos/tasks.c **** 			}
3447:../freertos/tasks.c **** 		}
3448:../freertos/tasks.c **** 		#endif /* INCLUDE_vTaskSuspend */
3449:../freertos/tasks.c **** 
3450:../freertos/tasks.c **** 		#if ( configUSE_MUTEXES == 1 )
3451:../freertos/tasks.c **** 		{
3452:../freertos/tasks.c **** 			pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
 4138              		.loc 1 3452 0
 4139 0068 7B69     		ldr	r3, [r7, #20]
 4140 006a 1A6D     		ldr	r2, [r3, #80]
 4141 006c BB68     		ldr	r3, [r7, #8]
 4142 006e 5A61     		str	r2, [r3, #20]
3453:../freertos/tasks.c **** 		}
3454:../freertos/tasks.c **** 		#else
3455:../freertos/tasks.c **** 		{
3456:../freertos/tasks.c **** 			pxTaskStatus->uxBasePriority = 0;
3457:../freertos/tasks.c **** 		}
3458:../freertos/tasks.c **** 		#endif
3459:../freertos/tasks.c **** 
3460:../freertos/tasks.c **** 		#if ( configGENERATE_RUN_TIME_STATS == 1 )
3461:../freertos/tasks.c **** 		{
3462:../freertos/tasks.c **** 			pxTaskStatus->ulRunTimeCounter = pxTCB->ulRunTimeCounter;
3463:../freertos/tasks.c **** 		}
3464:../freertos/tasks.c **** 		#else
3465:../freertos/tasks.c **** 		{
3466:../freertos/tasks.c **** 			pxTaskStatus->ulRunTimeCounter = 0;
 4143              		.loc 1 3466 0
 4144 0070 BB68     		ldr	r3, [r7, #8]
 4145 0072 0022     		mov	r2, #0
 4146 0074 9A61     		str	r2, [r3, #24]
3467:../freertos/tasks.c **** 		}
3468:../freertos/tasks.c **** 		#endif
3469:../freertos/tasks.c **** 
3470:../freertos/tasks.c **** 		/* Obtaining the task state is a little fiddly, so is only done if the value
3471:../freertos/tasks.c **** 		of eState passed into this function is eInvalid - otherwise the state is
3472:../freertos/tasks.c **** 		just set to whatever is passed in. */
3473:../freertos/tasks.c **** 		if( eState != eInvalid )
 4147              		.loc 1 3473 0
 4148 0076 FB1C     		add	r3, r7, #3
 4149 0078 1B78     		ldrb	r3, [r3]
 4150 007a 052B     		cmp	r3, #5
 4151 007c 04D0     		beq	.L331
3474:../freertos/tasks.c **** 		{
3475:../freertos/tasks.c **** 			pxTaskStatus->eCurrentState = eState;
 4152              		.loc 1 3475 0
 4153 007e BB68     		ldr	r3, [r7, #8]
 4154 0080 FA1C     		add	r2, r7, #3
 4155 0082 1278     		ldrb	r2, [r2]
 4156 0084 1A73     		strb	r2, [r3, #12]
 4157 0086 07E0     		b	.L332
 4158              	.L331:
3476:../freertos/tasks.c **** 		}
3477:../freertos/tasks.c **** 		else
3478:../freertos/tasks.c **** 		{
3479:../freertos/tasks.c **** 			pxTaskStatus->eCurrentState = eTaskGetState( xTask );
 4159              		.loc 1 3479 0
 4160 0088 FB68     		ldr	r3, [r7, #12]
 4161 008a 181C     		mov	r0, r3
 4162 008c FFF7FEFF 		bl	eTaskGetState
 4163 0090 031C     		mov	r3, r0
 4164 0092 1A1C     		mov	r2, r3
 4165 0094 BB68     		ldr	r3, [r7, #8]
 4166 0096 1A73     		strb	r2, [r3, #12]
 4167              	.L332:
3480:../freertos/tasks.c **** 		}
3481:../freertos/tasks.c **** 
3482:../freertos/tasks.c **** 		/* Obtaining the stack space takes some time, so the xGetFreeStackSpace
3483:../freertos/tasks.c **** 		parameter is provided to allow it to be skipped. */
3484:../freertos/tasks.c **** 		if( xGetFreeStackSpace != pdFALSE )
 4168              		.loc 1 3484 0
 4169 0098 7B68     		ldr	r3, [r7, #4]
 4170 009a 002B     		cmp	r3, #0
 4171 009c 09D0     		beq	.L333
3485:../freertos/tasks.c **** 		{
3486:../freertos/tasks.c **** 			#if ( portSTACK_GROWTH > 0 )
3487:../freertos/tasks.c **** 			{
3488:../freertos/tasks.c **** 				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxEndOfSt
3489:../freertos/tasks.c **** 			}
3490:../freertos/tasks.c **** 			#else
3491:../freertos/tasks.c **** 			{
3492:../freertos/tasks.c **** 				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxStack )
 4172              		.loc 1 3492 0
 4173 009e 7B69     		ldr	r3, [r7, #20]
 4174 00a0 1B6B     		ldr	r3, [r3, #48]
 4175 00a2 181C     		mov	r0, r3
 4176 00a4 FFF7FEFF 		bl	prvTaskCheckFreeStackSpace
 4177 00a8 031C     		mov	r3, r0
 4178 00aa 1A1C     		mov	r2, r3
 4179 00ac BB68     		ldr	r3, [r7, #8]
 4180 00ae 1A84     		strh	r2, [r3, #32]
 4181 00b0 02E0     		b	.L326
 4182              	.L333:
3493:../freertos/tasks.c **** 			}
3494:../freertos/tasks.c **** 			#endif
3495:../freertos/tasks.c **** 		}
3496:../freertos/tasks.c **** 		else
3497:../freertos/tasks.c **** 		{
3498:../freertos/tasks.c **** 			pxTaskStatus->usStackHighWaterMark = 0;
 4183              		.loc 1 3498 0
 4184 00b2 BB68     		ldr	r3, [r7, #8]
 4185 00b4 0022     		mov	r2, #0
 4186 00b6 1A84     		strh	r2, [r3, #32]
 4187              	.L326:
3499:../freertos/tasks.c **** 		}
3500:../freertos/tasks.c **** 	}
 4188              		.loc 1 3500 0
 4189 00b8 BD46     		mov	sp, r7
 4190 00ba 06B0     		add	sp, sp, #24
 4191              		@ sp needed
 4192 00bc 80BD     		pop	{r7, pc}
 4193              	.L336:
 4194 00be C046     		.align	2
 4195              	.L335:
 4196 00c0 00000000 		.word	pxCurrentTCB
 4197              		.cfi_endproc
 4198              	.LFE40:
 4200              		.section	.text.prvListTasksWithinSingleList,"ax",%progbits
 4201              		.align	2
 4202              		.code	16
 4203              		.thumb_func
 4205              	prvListTasksWithinSingleList:
 4206              	.LFB41:
3501:../freertos/tasks.c **** 
3502:../freertos/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3503:../freertos/tasks.c **** /*-----------------------------------------------------------*/
3504:../freertos/tasks.c **** 
3505:../freertos/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
3506:../freertos/tasks.c **** 
3507:../freertos/tasks.c **** 	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, 
3508:../freertos/tasks.c **** 	{
 4207              		.loc 1 3508 0
 4208              		.cfi_startproc
 4209 0000 80B5     		push	{r7, lr}
 4210              		.cfi_def_cfa_offset 8
 4211              		.cfi_offset 7, -8
 4212              		.cfi_offset 14, -4
 4213 0002 8AB0     		sub	sp, sp, #40
 4214              		.cfi_def_cfa_offset 48
 4215 0004 00AF     		add	r7, sp, #0
 4216              		.cfi_def_cfa_register 7
 4217 0006 F860     		str	r0, [r7, #12]
 4218 0008 B960     		str	r1, [r7, #8]
 4219 000a FB1D     		add	r3, r7, #7
 4220 000c 1A70     		strb	r2, [r3]
3509:../freertos/tasks.c **** 	volatile TCB_t *pxNextTCB, *pxFirstTCB;
3510:../freertos/tasks.c **** 	UBaseType_t uxTask = 0;
 4221              		.loc 1 3510 0
 4222 000e 0023     		mov	r3, #0
 4223 0010 7B62     		str	r3, [r7, #36]
3511:../freertos/tasks.c **** 
3512:../freertos/tasks.c **** 		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
 4224              		.loc 1 3512 0
 4225 0012 BB68     		ldr	r3, [r7, #8]
 4226 0014 1B68     		ldr	r3, [r3]
 4227 0016 002B     		cmp	r3, #0
 4228 0018 41D0     		beq	.L338
 4229              	.LBB12:
3513:../freertos/tasks.c **** 		{
3514:../freertos/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
 4230              		.loc 1 3514 0
 4231 001a BB68     		ldr	r3, [r7, #8]
 4232 001c 3B62     		str	r3, [r7, #32]
 4233 001e 3B6A     		ldr	r3, [r7, #32]
 4234 0020 5B68     		ldr	r3, [r3, #4]
 4235 0022 5A68     		ldr	r2, [r3, #4]
 4236 0024 3B6A     		ldr	r3, [r7, #32]
 4237 0026 5A60     		str	r2, [r3, #4]
 4238 0028 3B6A     		ldr	r3, [r7, #32]
 4239 002a 5A68     		ldr	r2, [r3, #4]
 4240 002c 3B6A     		ldr	r3, [r7, #32]
 4241 002e 0833     		add	r3, r3, #8
 4242 0030 9A42     		cmp	r2, r3
 4243 0032 04D1     		bne	.L339
 4244              		.loc 1 3514 0 is_stmt 0 discriminator 1
 4245 0034 3B6A     		ldr	r3, [r7, #32]
 4246 0036 5B68     		ldr	r3, [r3, #4]
 4247 0038 5A68     		ldr	r2, [r3, #4]
 4248 003a 3B6A     		ldr	r3, [r7, #32]
 4249 003c 5A60     		str	r2, [r3, #4]
 4250              	.L339:
 4251              		.loc 1 3514 0 discriminator 2
 4252 003e 3B6A     		ldr	r3, [r7, #32]
 4253 0040 5B68     		ldr	r3, [r3, #4]
 4254 0042 DB68     		ldr	r3, [r3, #12]
 4255 0044 FB61     		str	r3, [r7, #28]
 4256              	.L341:
 4257              	.LBE12:
 4258              	.LBB13:
3515:../freertos/tasks.c **** 
3516:../freertos/tasks.c **** 			/* Populate an TaskStatus_t structure within the
3517:../freertos/tasks.c **** 			pxTaskStatusArray array for each task that is referenced from
3518:../freertos/tasks.c **** 			pxList.  See the definition of TaskStatus_t in task.h for the
3519:../freertos/tasks.c **** 			meaning of each TaskStatus_t structure member. */
3520:../freertos/tasks.c **** 			do
3521:../freertos/tasks.c **** 			{
3522:../freertos/tasks.c **** 				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
 4259              		.loc 1 3522 0 is_stmt 1
 4260 0046 BB68     		ldr	r3, [r7, #8]
 4261 0048 BB61     		str	r3, [r7, #24]
 4262 004a BB69     		ldr	r3, [r7, #24]
 4263 004c 5B68     		ldr	r3, [r3, #4]
 4264 004e 5A68     		ldr	r2, [r3, #4]
 4265 0050 BB69     		ldr	r3, [r7, #24]
 4266 0052 5A60     		str	r2, [r3, #4]
 4267 0054 BB69     		ldr	r3, [r7, #24]
 4268 0056 5A68     		ldr	r2, [r3, #4]
 4269 0058 BB69     		ldr	r3, [r7, #24]
 4270 005a 0833     		add	r3, r3, #8
 4271 005c 9A42     		cmp	r2, r3
 4272 005e 04D1     		bne	.L340
 4273              		.loc 1 3522 0 is_stmt 0 discriminator 1
 4274 0060 BB69     		ldr	r3, [r7, #24]
 4275 0062 5B68     		ldr	r3, [r3, #4]
 4276 0064 5A68     		ldr	r2, [r3, #4]
 4277 0066 BB69     		ldr	r3, [r7, #24]
 4278 0068 5A60     		str	r2, [r3, #4]
 4279              	.L340:
 4280              		.loc 1 3522 0 discriminator 2
 4281 006a BB69     		ldr	r3, [r7, #24]
 4282 006c 5B68     		ldr	r3, [r3, #4]
 4283 006e DB68     		ldr	r3, [r3, #12]
 4284 0070 7B61     		str	r3, [r7, #20]
 4285              	.LBE13:
3523:../freertos/tasks.c **** 				vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );
 4286              		.loc 1 3523 0 is_stmt 1 discriminator 2
 4287 0072 7A6A     		ldr	r2, [r7, #36]
 4288 0074 131C     		mov	r3, r2
 4289 0076 DB00     		lsl	r3, r3, #3
 4290 0078 9B18     		add	r3, r3, r2
 4291 007a 9B00     		lsl	r3, r3, #2
 4292 007c FA68     		ldr	r2, [r7, #12]
 4293 007e D218     		add	r2, r2, r3
 4294 0080 7969     		ldr	r1, [r7, #20]
 4295 0082 FB1D     		add	r3, r7, #7
 4296 0084 1B78     		ldrb	r3, [r3]
 4297 0086 081C     		mov	r0, r1
 4298 0088 111C     		mov	r1, r2
 4299 008a 0122     		mov	r2, #1
 4300 008c FFF7FEFF 		bl	vTaskGetInfo
3524:../freertos/tasks.c **** 				uxTask++;
 4301              		.loc 1 3524 0 discriminator 2
 4302 0090 7B6A     		ldr	r3, [r7, #36]
 4303 0092 0133     		add	r3, r3, #1
 4304 0094 7B62     		str	r3, [r7, #36]
3525:../freertos/tasks.c **** 			} while( pxNextTCB != pxFirstTCB );
 4305              		.loc 1 3525 0 discriminator 2
 4306 0096 7A69     		ldr	r2, [r7, #20]
 4307 0098 FB69     		ldr	r3, [r7, #28]
 4308 009a 9A42     		cmp	r2, r3
 4309 009c D3D1     		bne	.L341
 4310              	.L338:
3526:../freertos/tasks.c **** 		}
3527:../freertos/tasks.c **** 		else
3528:../freertos/tasks.c **** 		{
3529:../freertos/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3530:../freertos/tasks.c **** 		}
3531:../freertos/tasks.c **** 
3532:../freertos/tasks.c **** 		return uxTask;
 4311              		.loc 1 3532 0
 4312 009e 7B6A     		ldr	r3, [r7, #36]
3533:../freertos/tasks.c **** 	}
 4313              		.loc 1 3533 0
 4314 00a0 181C     		mov	r0, r3
 4315 00a2 BD46     		mov	sp, r7
 4316 00a4 0AB0     		add	sp, sp, #40
 4317              		@ sp needed
 4318 00a6 80BD     		pop	{r7, pc}
 4319              		.cfi_endproc
 4320              	.LFE41:
 4322              		.section	.text.prvTaskCheckFreeStackSpace,"ax",%progbits
 4323              		.align	2
 4324              		.code	16
 4325              		.thumb_func
 4327              	prvTaskCheckFreeStackSpace:
 4328              	.LFB42:
3534:../freertos/tasks.c **** 
3535:../freertos/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3536:../freertos/tasks.c **** /*-----------------------------------------------------------*/
3537:../freertos/tasks.c **** 
3538:../freertos/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
3539:../freertos/tasks.c **** 
3540:../freertos/tasks.c **** 	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
3541:../freertos/tasks.c **** 	{
 4329              		.loc 1 3541 0
 4330              		.cfi_startproc
 4331 0000 80B5     		push	{r7, lr}
 4332              		.cfi_def_cfa_offset 8
 4333              		.cfi_offset 7, -8
 4334              		.cfi_offset 14, -4
 4335 0002 84B0     		sub	sp, sp, #16
 4336              		.cfi_def_cfa_offset 24
 4337 0004 00AF     		add	r7, sp, #0
 4338              		.cfi_def_cfa_register 7
 4339 0006 7860     		str	r0, [r7, #4]
3542:../freertos/tasks.c **** 	uint32_t ulCount = 0U;
 4340              		.loc 1 3542 0
 4341 0008 0023     		mov	r3, #0
 4342 000a FB60     		str	r3, [r7, #12]
3543:../freertos/tasks.c **** 
3544:../freertos/tasks.c **** 		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
 4343              		.loc 1 3544 0
 4344 000c 05E0     		b	.L344
 4345              	.L345:
3545:../freertos/tasks.c **** 		{
3546:../freertos/tasks.c **** 			pucStackByte -= portSTACK_GROWTH;
 4346              		.loc 1 3546 0
 4347 000e 7B68     		ldr	r3, [r7, #4]
 4348 0010 0133     		add	r3, r3, #1
 4349 0012 7B60     		str	r3, [r7, #4]
3547:../freertos/tasks.c **** 			ulCount++;
 4350              		.loc 1 3547 0
 4351 0014 FB68     		ldr	r3, [r7, #12]
 4352 0016 0133     		add	r3, r3, #1
 4353 0018 FB60     		str	r3, [r7, #12]
 4354              	.L344:
3544:../freertos/tasks.c **** 		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
 4355              		.loc 1 3544 0 discriminator 1
 4356 001a 7B68     		ldr	r3, [r7, #4]
 4357 001c 1B78     		ldrb	r3, [r3]
 4358 001e A52B     		cmp	r3, #165
 4359 0020 F5D0     		beq	.L345
3548:../freertos/tasks.c **** 		}
3549:../freertos/tasks.c **** 
3550:../freertos/tasks.c **** 		ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller a
 4360              		.loc 1 3550 0
 4361 0022 FB68     		ldr	r3, [r7, #12]
 4362 0024 9B08     		lsr	r3, r3, #2
 4363 0026 FB60     		str	r3, [r7, #12]
3551:../freertos/tasks.c **** 
3552:../freertos/tasks.c **** 		return ( uint16_t ) ulCount;
 4364              		.loc 1 3552 0
 4365 0028 FB68     		ldr	r3, [r7, #12]
 4366 002a 9BB2     		uxth	r3, r3
3553:../freertos/tasks.c **** 	}
 4367              		.loc 1 3553 0
 4368 002c 181C     		mov	r0, r3
 4369 002e BD46     		mov	sp, r7
 4370 0030 04B0     		add	sp, sp, #16
 4371              		@ sp needed
 4372 0032 80BD     		pop	{r7, pc}
 4373              		.cfi_endproc
 4374              	.LFE42:
 4376              		.section	.text.prvDeleteTCB,"ax",%progbits
 4377              		.align	2
 4378              		.code	16
 4379              		.thumb_func
 4381              	prvDeleteTCB:
 4382              	.LFB43:
3554:../freertos/tasks.c **** 
3555:../freertos/tasks.c **** #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) */
3556:../freertos/tasks.c **** /*-----------------------------------------------------------*/
3557:../freertos/tasks.c **** 
3558:../freertos/tasks.c **** #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
3559:../freertos/tasks.c **** 
3560:../freertos/tasks.c **** 	UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
3561:../freertos/tasks.c **** 	{
3562:../freertos/tasks.c **** 	TCB_t *pxTCB;
3563:../freertos/tasks.c **** 	uint8_t *pucEndOfStack;
3564:../freertos/tasks.c **** 	UBaseType_t uxReturn;
3565:../freertos/tasks.c **** 
3566:../freertos/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
3567:../freertos/tasks.c **** 
3568:../freertos/tasks.c **** 		#if portSTACK_GROWTH < 0
3569:../freertos/tasks.c **** 		{
3570:../freertos/tasks.c **** 			pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
3571:../freertos/tasks.c **** 		}
3572:../freertos/tasks.c **** 		#else
3573:../freertos/tasks.c **** 		{
3574:../freertos/tasks.c **** 			pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
3575:../freertos/tasks.c **** 		}
3576:../freertos/tasks.c **** 		#endif
3577:../freertos/tasks.c **** 
3578:../freertos/tasks.c **** 		uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
3579:../freertos/tasks.c **** 
3580:../freertos/tasks.c **** 		return uxReturn;
3581:../freertos/tasks.c **** 	}
3582:../freertos/tasks.c **** 
3583:../freertos/tasks.c **** #endif /* INCLUDE_uxTaskGetStackHighWaterMark */
3584:../freertos/tasks.c **** /*-----------------------------------------------------------*/
3585:../freertos/tasks.c **** 
3586:../freertos/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
3587:../freertos/tasks.c **** 
3588:../freertos/tasks.c **** 	static void prvDeleteTCB( TCB_t *pxTCB )
3589:../freertos/tasks.c **** 	{
 4383              		.loc 1 3589 0
 4384              		.cfi_startproc
 4385 0000 80B5     		push	{r7, lr}
 4386              		.cfi_def_cfa_offset 8
 4387              		.cfi_offset 7, -8
 4388              		.cfi_offset 14, -4
 4389 0002 82B0     		sub	sp, sp, #8
 4390              		.cfi_def_cfa_offset 16
 4391 0004 00AF     		add	r7, sp, #0
 4392              		.cfi_def_cfa_register 7
 4393 0006 7860     		str	r0, [r7, #4]
3590:../freertos/tasks.c **** 		/* This call is required specifically for the TriCore port.  It must be
3591:../freertos/tasks.c **** 		above the vPortFree() calls.  The call is also used by ports/demos that
3592:../freertos/tasks.c **** 		want to allocate and clean RAM statically. */
3593:../freertos/tasks.c **** 		portCLEAN_UP_TCB( pxTCB );
3594:../freertos/tasks.c **** 
3595:../freertos/tasks.c **** 		/* Free up the memory allocated by the scheduler for the task.  It is up
3596:../freertos/tasks.c **** 		to the task to free any memory allocated at the application level. */
3597:../freertos/tasks.c **** 		#if ( configUSE_NEWLIB_REENTRANT == 1 )
3598:../freertos/tasks.c **** 		{
3599:../freertos/tasks.c **** 			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
3600:../freertos/tasks.c **** 		}
3601:../freertos/tasks.c **** 		#endif /* configUSE_NEWLIB_REENTRANT */
3602:../freertos/tasks.c **** 
3603:../freertos/tasks.c **** 		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( p
3604:../freertos/tasks.c **** 		{
3605:../freertos/tasks.c **** 			/* The task can only have been allocated dynamically - free both
3606:../freertos/tasks.c **** 			the stack and TCB. */
3607:../freertos/tasks.c **** 			vPortFree( pxTCB->pxStack );
 4394              		.loc 1 3607 0
 4395 0008 7B68     		ldr	r3, [r7, #4]
 4396 000a 1B6B     		ldr	r3, [r3, #48]
 4397 000c 181C     		mov	r0, r3
 4398 000e FFF7FEFF 		bl	vPortFree
3608:../freertos/tasks.c **** 			vPortFree( pxTCB );
 4399              		.loc 1 3608 0
 4400 0012 7B68     		ldr	r3, [r7, #4]
 4401 0014 181C     		mov	r0, r3
 4402 0016 FFF7FEFF 		bl	vPortFree
3609:../freertos/tasks.c **** 		}
3610:../freertos/tasks.c **** 		#elif( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE == 1 )
3611:../freertos/tasks.c **** 		{
3612:../freertos/tasks.c **** 			/* The task could have been allocated statically or dynamically, so
3613:../freertos/tasks.c **** 			check what was statically allocated before trying to free the
3614:../freertos/tasks.c **** 			memory. */
3615:../freertos/tasks.c **** 			if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
3616:../freertos/tasks.c **** 			{
3617:../freertos/tasks.c **** 				/* Both the stack and TCB were allocated dynamically, so both
3618:../freertos/tasks.c **** 				must be freed. */
3619:../freertos/tasks.c **** 				vPortFree( pxTCB->pxStack );
3620:../freertos/tasks.c **** 				vPortFree( pxTCB );
3621:../freertos/tasks.c **** 			}
3622:../freertos/tasks.c **** 			else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
3623:../freertos/tasks.c **** 			{
3624:../freertos/tasks.c **** 				/* Only the stack was statically allocated, so the TCB is the
3625:../freertos/tasks.c **** 				only memory that must be freed. */
3626:../freertos/tasks.c **** 				vPortFree( pxTCB );
3627:../freertos/tasks.c **** 			}
3628:../freertos/tasks.c **** 			else
3629:../freertos/tasks.c **** 			{
3630:../freertos/tasks.c **** 				/* Neither the stack nor the TCB were allocated dynamically, so
3631:../freertos/tasks.c **** 				nothing needs to be freed. */
3632:../freertos/tasks.c **** 				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	)
3633:../freertos/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3634:../freertos/tasks.c **** 			}
3635:../freertos/tasks.c **** 		}
3636:../freertos/tasks.c **** 		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
3637:../freertos/tasks.c **** 	}
 4403              		.loc 1 3637 0
 4404 001a BD46     		mov	sp, r7
 4405 001c 02B0     		add	sp, sp, #8
 4406              		@ sp needed
 4407 001e 80BD     		pop	{r7, pc}
 4408              		.cfi_endproc
 4409              	.LFE43:
 4411              		.section	.text.prvResetNextTaskUnblockTime,"ax",%progbits
 4412              		.align	2
 4413              		.code	16
 4414              		.thumb_func
 4416              	prvResetNextTaskUnblockTime:
 4417              	.LFB44:
3638:../freertos/tasks.c **** 
3639:../freertos/tasks.c **** #endif /* INCLUDE_vTaskDelete */
3640:../freertos/tasks.c **** /*-----------------------------------------------------------*/
3641:../freertos/tasks.c **** 
3642:../freertos/tasks.c **** static void prvResetNextTaskUnblockTime( void )
3643:../freertos/tasks.c **** {
 4418              		.loc 1 3643 0
 4419              		.cfi_startproc
 4420 0000 80B5     		push	{r7, lr}
 4421              		.cfi_def_cfa_offset 8
 4422              		.cfi_offset 7, -8
 4423              		.cfi_offset 14, -4
 4424 0002 82B0     		sub	sp, sp, #8
 4425              		.cfi_def_cfa_offset 16
 4426 0004 00AF     		add	r7, sp, #0
 4427              		.cfi_def_cfa_register 7
3644:../freertos/tasks.c **** TCB_t *pxTCB;
3645:../freertos/tasks.c **** 
3646:../freertos/tasks.c **** 	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 4428              		.loc 1 3646 0
 4429 0006 0D4B     		ldr	r3, .L353
 4430 0008 1B68     		ldr	r3, [r3]
 4431 000a 1B68     		ldr	r3, [r3]
 4432 000c 002B     		cmp	r3, #0
 4433 000e 01D1     		bne	.L349
 4434              		.loc 1 3646 0 is_stmt 0 discriminator 1
 4435 0010 0123     		mov	r3, #1
 4436 0012 00E0     		b	.L350
 4437              	.L349:
 4438              		.loc 1 3646 0 discriminator 2
 4439 0014 0023     		mov	r3, #0
 4440              	.L350:
 4441              		.loc 1 3646 0 discriminator 3
 4442 0016 002B     		cmp	r3, #0
 4443 0018 04D0     		beq	.L351
3647:../freertos/tasks.c **** 	{
3648:../freertos/tasks.c **** 		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
3649:../freertos/tasks.c **** 		the maximum possible value so it is	extremely unlikely that the
3650:../freertos/tasks.c **** 		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
3651:../freertos/tasks.c **** 		there is an item in the delayed list. */
3652:../freertos/tasks.c **** 		xNextTaskUnblockTime = portMAX_DELAY;
 4444              		.loc 1 3652 0 is_stmt 1
 4445 001a 094B     		ldr	r3, .L353+4
 4446 001c 0122     		mov	r2, #1
 4447 001e 5242     		neg	r2, r2
 4448 0020 1A60     		str	r2, [r3]
 4449 0022 08E0     		b	.L348
 4450              	.L351:
3653:../freertos/tasks.c **** 	}
3654:../freertos/tasks.c **** 	else
3655:../freertos/tasks.c **** 	{
3656:../freertos/tasks.c **** 		/* The new current delayed list is not empty, get the value of
3657:../freertos/tasks.c **** 		the item at the head of the delayed list.  This is the time at
3658:../freertos/tasks.c **** 		which the task at the head of the delayed list should be removed
3659:../freertos/tasks.c **** 		from the Blocked state. */
3660:../freertos/tasks.c **** 		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 4451              		.loc 1 3660 0
 4452 0024 054B     		ldr	r3, .L353
 4453 0026 1B68     		ldr	r3, [r3]
 4454 0028 DB68     		ldr	r3, [r3, #12]
 4455 002a DB68     		ldr	r3, [r3, #12]
 4456 002c 7B60     		str	r3, [r7, #4]
3661:../freertos/tasks.c **** 		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 4457              		.loc 1 3661 0
 4458 002e 7B68     		ldr	r3, [r7, #4]
 4459 0030 5A68     		ldr	r2, [r3, #4]
 4460 0032 034B     		ldr	r3, .L353+4
 4461 0034 1A60     		str	r2, [r3]
 4462              	.L348:
3662:../freertos/tasks.c **** 	}
3663:../freertos/tasks.c **** }
 4463              		.loc 1 3663 0
 4464 0036 BD46     		mov	sp, r7
 4465 0038 02B0     		add	sp, sp, #8
 4466              		@ sp needed
 4467 003a 80BD     		pop	{r7, pc}
 4468              	.L354:
 4469              		.align	2
 4470              	.L353:
 4471 003c 00000000 		.word	pxDelayedTaskList
 4472 0040 00000000 		.word	xNextTaskUnblockTime
 4473              		.cfi_endproc
 4474              	.LFE44:
 4476              		.section	.text.xTaskGetCurrentTaskHandle,"ax",%progbits
 4477              		.align	2
 4478              		.global	xTaskGetCurrentTaskHandle
 4479              		.code	16
 4480              		.thumb_func
 4482              	xTaskGetCurrentTaskHandle:
 4483              	.LFB45:
3664:../freertos/tasks.c **** /*-----------------------------------------------------------*/
3665:../freertos/tasks.c **** 
3666:../freertos/tasks.c **** #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
3667:../freertos/tasks.c **** 
3668:../freertos/tasks.c **** 	TaskHandle_t xTaskGetCurrentTaskHandle( void )
3669:../freertos/tasks.c **** 	{
 4484              		.loc 1 3669 0
 4485              		.cfi_startproc
 4486 0000 80B5     		push	{r7, lr}
 4487              		.cfi_def_cfa_offset 8
 4488              		.cfi_offset 7, -8
 4489              		.cfi_offset 14, -4
 4490 0002 82B0     		sub	sp, sp, #8
 4491              		.cfi_def_cfa_offset 16
 4492 0004 00AF     		add	r7, sp, #0
 4493              		.cfi_def_cfa_register 7
3670:../freertos/tasks.c **** 	TaskHandle_t xReturn;
3671:../freertos/tasks.c **** 
3672:../freertos/tasks.c **** 		/* A critical section is not required as this is not called from
3673:../freertos/tasks.c **** 		an interrupt and the current TCB will always be the same for any
3674:../freertos/tasks.c **** 		individual execution thread. */
3675:../freertos/tasks.c **** 		xReturn = pxCurrentTCB;
 4494              		.loc 1 3675 0
 4495 0006 044B     		ldr	r3, .L357
 4496 0008 1B68     		ldr	r3, [r3]
 4497 000a 7B60     		str	r3, [r7, #4]
3676:../freertos/tasks.c **** 
3677:../freertos/tasks.c **** 		return xReturn;
 4498              		.loc 1 3677 0
 4499 000c 7B68     		ldr	r3, [r7, #4]
3678:../freertos/tasks.c **** 	}
 4500              		.loc 1 3678 0
 4501 000e 181C     		mov	r0, r3
 4502 0010 BD46     		mov	sp, r7
 4503 0012 02B0     		add	sp, sp, #8
 4504              		@ sp needed
 4505 0014 80BD     		pop	{r7, pc}
 4506              	.L358:
 4507 0016 C046     		.align	2
 4508              	.L357:
 4509 0018 00000000 		.word	pxCurrentTCB
 4510              		.cfi_endproc
 4511              	.LFE45:
 4513              		.section	.text.xTaskGetSchedulerState,"ax",%progbits
 4514              		.align	2
 4515              		.global	xTaskGetSchedulerState
 4516              		.code	16
 4517              		.thumb_func
 4519              	xTaskGetSchedulerState:
 4520              	.LFB46:
3679:../freertos/tasks.c **** 
3680:../freertos/tasks.c **** #endif /* ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) ) */
3681:../freertos/tasks.c **** /*-----------------------------------------------------------*/
3682:../freertos/tasks.c **** 
3683:../freertos/tasks.c **** #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
3684:../freertos/tasks.c **** 
3685:../freertos/tasks.c **** 	BaseType_t xTaskGetSchedulerState( void )
3686:../freertos/tasks.c **** 	{
 4521              		.loc 1 3686 0
 4522              		.cfi_startproc
 4523 0000 80B5     		push	{r7, lr}
 4524              		.cfi_def_cfa_offset 8
 4525              		.cfi_offset 7, -8
 4526              		.cfi_offset 14, -4
 4527 0002 82B0     		sub	sp, sp, #8
 4528              		.cfi_def_cfa_offset 16
 4529 0004 00AF     		add	r7, sp, #0
 4530              		.cfi_def_cfa_register 7
3687:../freertos/tasks.c **** 	BaseType_t xReturn;
3688:../freertos/tasks.c **** 
3689:../freertos/tasks.c **** 		if( xSchedulerRunning == pdFALSE )
 4531              		.loc 1 3689 0
 4532 0006 0A4B     		ldr	r3, .L364
 4533 0008 1B68     		ldr	r3, [r3]
 4534 000a 002B     		cmp	r3, #0
 4535 000c 02D1     		bne	.L360
3690:../freertos/tasks.c **** 		{
3691:../freertos/tasks.c **** 			xReturn = taskSCHEDULER_NOT_STARTED;
 4536              		.loc 1 3691 0
 4537 000e 0123     		mov	r3, #1
 4538 0010 7B60     		str	r3, [r7, #4]
 4539 0012 08E0     		b	.L361
 4540              	.L360:
3692:../freertos/tasks.c **** 		}
3693:../freertos/tasks.c **** 		else
3694:../freertos/tasks.c **** 		{
3695:../freertos/tasks.c **** 			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 4541              		.loc 1 3695 0
 4542 0014 074B     		ldr	r3, .L364+4
 4543 0016 1B68     		ldr	r3, [r3]
 4544 0018 002B     		cmp	r3, #0
 4545 001a 02D1     		bne	.L362
3696:../freertos/tasks.c **** 			{
3697:../freertos/tasks.c **** 				xReturn = taskSCHEDULER_RUNNING;
 4546              		.loc 1 3697 0
 4547 001c 0223     		mov	r3, #2
 4548 001e 7B60     		str	r3, [r7, #4]
 4549 0020 01E0     		b	.L361
 4550              	.L362:
3698:../freertos/tasks.c **** 			}
3699:../freertos/tasks.c **** 			else
3700:../freertos/tasks.c **** 			{
3701:../freertos/tasks.c **** 				xReturn = taskSCHEDULER_SUSPENDED;
 4551              		.loc 1 3701 0
 4552 0022 0023     		mov	r3, #0
 4553 0024 7B60     		str	r3, [r7, #4]
 4554              	.L361:
3702:../freertos/tasks.c **** 			}
3703:../freertos/tasks.c **** 		}
3704:../freertos/tasks.c **** 
3705:../freertos/tasks.c **** 		return xReturn;
 4555              		.loc 1 3705 0
 4556 0026 7B68     		ldr	r3, [r7, #4]
3706:../freertos/tasks.c **** 	}
 4557              		.loc 1 3706 0
 4558 0028 181C     		mov	r0, r3
 4559 002a BD46     		mov	sp, r7
 4560 002c 02B0     		add	sp, sp, #8
 4561              		@ sp needed
 4562 002e 80BD     		pop	{r7, pc}
 4563              	.L365:
 4564              		.align	2
 4565              	.L364:
 4566 0030 00000000 		.word	xSchedulerRunning
 4567 0034 00000000 		.word	uxSchedulerSuspended
 4568              		.cfi_endproc
 4569              	.LFE46:
 4571              		.section	.text.vTaskPriorityInherit,"ax",%progbits
 4572              		.align	2
 4573              		.global	vTaskPriorityInherit
 4574              		.code	16
 4575              		.thumb_func
 4577              	vTaskPriorityInherit:
 4578              	.LFB47:
3707:../freertos/tasks.c **** 
3708:../freertos/tasks.c **** #endif /* ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) ) */
3709:../freertos/tasks.c **** /*-----------------------------------------------------------*/
3710:../freertos/tasks.c **** 
3711:../freertos/tasks.c **** #if ( configUSE_MUTEXES == 1 )
3712:../freertos/tasks.c **** 
3713:../freertos/tasks.c **** 	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
3714:../freertos/tasks.c **** 	{
 4579              		.loc 1 3714 0
 4580              		.cfi_startproc
 4581 0000 80B5     		push	{r7, lr}
 4582              		.cfi_def_cfa_offset 8
 4583              		.cfi_offset 7, -8
 4584              		.cfi_offset 14, -4
 4585 0002 84B0     		sub	sp, sp, #16
 4586              		.cfi_def_cfa_offset 24
 4587 0004 00AF     		add	r7, sp, #0
 4588              		.cfi_def_cfa_register 7
 4589 0006 7860     		str	r0, [r7, #4]
3715:../freertos/tasks.c **** 	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
 4590              		.loc 1 3715 0
 4591 0008 7B68     		ldr	r3, [r7, #4]
 4592 000a FB60     		str	r3, [r7, #12]
3716:../freertos/tasks.c **** 
3717:../freertos/tasks.c **** 		/* If the mutex was given back by an interrupt while the queue was
3718:../freertos/tasks.c **** 		locked then the mutex holder might now be NULL. */
3719:../freertos/tasks.c **** 		if( pxMutexHolder != NULL )
 4593              		.loc 1 3719 0
 4594 000c 7B68     		ldr	r3, [r7, #4]
 4595 000e 002B     		cmp	r3, #0
 4596 0010 4AD0     		beq	.L366
3720:../freertos/tasks.c **** 		{
3721:../freertos/tasks.c **** 			/* If the holder of the mutex has a priority below the priority of
3722:../freertos/tasks.c **** 			the task attempting to obtain the mutex then it will temporarily
3723:../freertos/tasks.c **** 			inherit the priority of the task attempting to obtain the mutex. */
3724:../freertos/tasks.c **** 			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
 4597              		.loc 1 3724 0
 4598 0012 FB68     		ldr	r3, [r7, #12]
 4599 0014 DA6A     		ldr	r2, [r3, #44]
 4600 0016 264B     		ldr	r3, .L374
 4601 0018 1B68     		ldr	r3, [r3]
 4602 001a DB6A     		ldr	r3, [r3, #44]
 4603 001c 9A42     		cmp	r2, r3
 4604 001e 43D2     		bcs	.L366
3725:../freertos/tasks.c **** 			{
3726:../freertos/tasks.c **** 				/* Adjust the mutex holder state to account for its new
3727:../freertos/tasks.c **** 				priority.  Only reset the event list item value if the value is
3728:../freertos/tasks.c **** 				not	being used for anything else. */
3729:../freertos/tasks.c **** 				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE 
 4605              		.loc 1 3729 0
 4606 0020 FB68     		ldr	r3, [r7, #12]
 4607 0022 9B69     		ldr	r3, [r3, #24]
 4608 0024 002B     		cmp	r3, #0
 4609 0026 06DB     		blt	.L368
3730:../freertos/tasks.c **** 				{
3731:../freertos/tasks.c **** 					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( T
 4610              		.loc 1 3731 0
 4611 0028 214B     		ldr	r3, .L374
 4612 002a 1B68     		ldr	r3, [r3]
 4613 002c DB6A     		ldr	r3, [r3, #44]
 4614 002e 0522     		mov	r2, #5
 4615 0030 D21A     		sub	r2, r2, r3
 4616 0032 FB68     		ldr	r3, [r7, #12]
 4617 0034 9A61     		str	r2, [r3, #24]
 4618              	.L368:
3732:../freertos/tasks.c **** 				}
3733:../freertos/tasks.c **** 				else
3734:../freertos/tasks.c **** 				{
3735:../freertos/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
3736:../freertos/tasks.c **** 				}
3737:../freertos/tasks.c **** 
3738:../freertos/tasks.c **** 				/* If the task being modified is in the ready state it will need
3739:../freertos/tasks.c **** 				to be moved into a new list. */
3740:../freertos/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xStateListI
 4619              		.loc 1 3740 0
 4620 0036 FB68     		ldr	r3, [r7, #12]
 4621 0038 5969     		ldr	r1, [r3, #20]
 4622 003a FB68     		ldr	r3, [r7, #12]
 4623 003c DA6A     		ldr	r2, [r3, #44]
 4624 003e 131C     		mov	r3, r2
 4625 0040 9B00     		lsl	r3, r3, #2
 4626 0042 9B18     		add	r3, r3, r2
 4627 0044 9B00     		lsl	r3, r3, #2
 4628 0046 1B4A     		ldr	r2, .L374+4
 4629 0048 9B18     		add	r3, r3, r2
 4630 004a 9942     		cmp	r1, r3
 4631 004c 01D1     		bne	.L369
 4632              		.loc 1 3740 0 is_stmt 0 discriminator 1
 4633 004e 0123     		mov	r3, #1
 4634 0050 00E0     		b	.L370
 4635              	.L369:
 4636              		.loc 1 3740 0 discriminator 2
 4637 0052 0023     		mov	r3, #0
 4638              	.L370:
 4639              		.loc 1 3740 0 discriminator 3
 4640 0054 002B     		cmp	r3, #0
 4641 0056 22D0     		beq	.L371
3741:../freertos/tasks.c **** 				{
3742:../freertos/tasks.c **** 					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 4642              		.loc 1 3742 0 is_stmt 1
 4643 0058 FB68     		ldr	r3, [r7, #12]
 4644 005a 0433     		add	r3, r3, #4
 4645 005c 181C     		mov	r0, r3
 4646 005e FFF7FEFF 		bl	uxListRemove
3743:../freertos/tasks.c **** 					{
3744:../freertos/tasks.c **** 						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
3745:../freertos/tasks.c **** 					}
3746:../freertos/tasks.c **** 					else
3747:../freertos/tasks.c **** 					{
3748:../freertos/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
3749:../freertos/tasks.c **** 					}
3750:../freertos/tasks.c **** 
3751:../freertos/tasks.c **** 					/* Inherit the priority before being moved into the new list. */
3752:../freertos/tasks.c **** 					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 4647              		.loc 1 3752 0
 4648 0062 134B     		ldr	r3, .L374
 4649 0064 1B68     		ldr	r3, [r3]
 4650 0066 DA6A     		ldr	r2, [r3, #44]
 4651 0068 FB68     		ldr	r3, [r7, #12]
 4652 006a DA62     		str	r2, [r3, #44]
3753:../freertos/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 4653              		.loc 1 3753 0
 4654 006c FB68     		ldr	r3, [r7, #12]
 4655 006e DA6A     		ldr	r2, [r3, #44]
 4656 0070 114B     		ldr	r3, .L374+8
 4657 0072 1B68     		ldr	r3, [r3]
 4658 0074 9A42     		cmp	r2, r3
 4659 0076 03D9     		bls	.L372
 4660              		.loc 1 3753 0 is_stmt 0 discriminator 1
 4661 0078 FB68     		ldr	r3, [r7, #12]
 4662 007a DA6A     		ldr	r2, [r3, #44]
 4663 007c 0E4B     		ldr	r3, .L374+8
 4664 007e 1A60     		str	r2, [r3]
 4665              	.L372:
 4666              		.loc 1 3753 0 discriminator 2
 4667 0080 FB68     		ldr	r3, [r7, #12]
 4668 0082 DA6A     		ldr	r2, [r3, #44]
 4669 0084 131C     		mov	r3, r2
 4670 0086 9B00     		lsl	r3, r3, #2
 4671 0088 9B18     		add	r3, r3, r2
 4672 008a 9B00     		lsl	r3, r3, #2
 4673 008c 094A     		ldr	r2, .L374+4
 4674 008e 9A18     		add	r2, r3, r2
 4675 0090 FB68     		ldr	r3, [r7, #12]
 4676 0092 0433     		add	r3, r3, #4
 4677 0094 101C     		mov	r0, r2
 4678 0096 191C     		mov	r1, r3
 4679 0098 FFF7FEFF 		bl	vListInsertEnd
 4680 009c 04E0     		b	.L366
 4681              	.L371:
3754:../freertos/tasks.c **** 				}
3755:../freertos/tasks.c **** 				else
3756:../freertos/tasks.c **** 				{
3757:../freertos/tasks.c **** 					/* Just inherit the priority. */
3758:../freertos/tasks.c **** 					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 4682              		.loc 1 3758 0 is_stmt 1
 4683 009e 044B     		ldr	r3, .L374
 4684 00a0 1B68     		ldr	r3, [r3]
 4685 00a2 DA6A     		ldr	r2, [r3, #44]
 4686 00a4 FB68     		ldr	r3, [r7, #12]
 4687 00a6 DA62     		str	r2, [r3, #44]
 4688              	.L366:
3759:../freertos/tasks.c **** 				}
3760:../freertos/tasks.c **** 
3761:../freertos/tasks.c **** 				traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
3762:../freertos/tasks.c **** 			}
3763:../freertos/tasks.c **** 			else
3764:../freertos/tasks.c **** 			{
3765:../freertos/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3766:../freertos/tasks.c **** 			}
3767:../freertos/tasks.c **** 		}
3768:../freertos/tasks.c **** 		else
3769:../freertos/tasks.c **** 		{
3770:../freertos/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3771:../freertos/tasks.c **** 		}
3772:../freertos/tasks.c **** 	}
 4689              		.loc 1 3772 0
 4690 00a8 BD46     		mov	sp, r7
 4691 00aa 04B0     		add	sp, sp, #16
 4692              		@ sp needed
 4693 00ac 80BD     		pop	{r7, pc}
 4694              	.L375:
 4695 00ae C046     		.align	2
 4696              	.L374:
 4697 00b0 00000000 		.word	pxCurrentTCB
 4698 00b4 00000000 		.word	pxReadyTasksLists
 4699 00b8 00000000 		.word	uxTopReadyPriority
 4700              		.cfi_endproc
 4701              	.LFE47:
 4703              		.section	.text.xTaskPriorityDisinherit,"ax",%progbits
 4704              		.align	2
 4705              		.global	xTaskPriorityDisinherit
 4706              		.code	16
 4707              		.thumb_func
 4709              	xTaskPriorityDisinherit:
 4710              	.LFB48:
3773:../freertos/tasks.c **** 
3774:../freertos/tasks.c **** #endif /* configUSE_MUTEXES */
3775:../freertos/tasks.c **** /*-----------------------------------------------------------*/
3776:../freertos/tasks.c **** 
3777:../freertos/tasks.c **** #if ( configUSE_MUTEXES == 1 )
3778:../freertos/tasks.c **** 
3779:../freertos/tasks.c **** 	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
3780:../freertos/tasks.c **** 	{
 4711              		.loc 1 3780 0
 4712              		.cfi_startproc
 4713 0000 80B5     		push	{r7, lr}
 4714              		.cfi_def_cfa_offset 8
 4715              		.cfi_offset 7, -8
 4716              		.cfi_offset 14, -4
 4717 0002 84B0     		sub	sp, sp, #16
 4718              		.cfi_def_cfa_offset 24
 4719 0004 00AF     		add	r7, sp, #0
 4720              		.cfi_def_cfa_register 7
 4721 0006 7860     		str	r0, [r7, #4]
3781:../freertos/tasks.c **** 	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
 4722              		.loc 1 3781 0
 4723 0008 7B68     		ldr	r3, [r7, #4]
 4724 000a BB60     		str	r3, [r7, #8]
3782:../freertos/tasks.c **** 	BaseType_t xReturn = pdFALSE;
 4725              		.loc 1 3782 0
 4726 000c 0023     		mov	r3, #0
 4727 000e FB60     		str	r3, [r7, #12]
3783:../freertos/tasks.c **** 
3784:../freertos/tasks.c **** 		if( pxMutexHolder != NULL )
 4728              		.loc 1 3784 0
 4729 0010 7B68     		ldr	r3, [r7, #4]
 4730 0012 002B     		cmp	r3, #0
 4731 0014 44D0     		beq	.L377
3785:../freertos/tasks.c **** 		{
3786:../freertos/tasks.c **** 			/* A task can only have an inherited priority if it holds the mutex.
3787:../freertos/tasks.c **** 			If the mutex is held by a task then it cannot be given from an
3788:../freertos/tasks.c **** 			interrupt, and if a mutex is given by the holding task then it must
3789:../freertos/tasks.c **** 			be the running state task. */
3790:../freertos/tasks.c **** 			configASSERT( pxTCB == pxCurrentTCB );
 4732              		.loc 1 3790 0
 4733 0016 254B     		ldr	r3, .L384
 4734 0018 1B68     		ldr	r3, [r3]
 4735 001a BA68     		ldr	r2, [r7, #8]
 4736 001c 9A42     		cmp	r2, r3
 4737 001e 01D0     		beq	.L378
 4738              		.loc 1 3790 0 is_stmt 0 discriminator 1
 4739              	@ 3790 "../freertos/tasks.c" 1
 4740 0020 72B6     		 cpsid i 
 4741              	@ 0 "" 2
 4742              		.code	16
 4743              	.L379:
 4744 0022 FEE7     		b	.L379
 4745              	.L378:
3791:../freertos/tasks.c **** 
3792:../freertos/tasks.c **** 			configASSERT( pxTCB->uxMutexesHeld );
 4746              		.loc 1 3792 0 is_stmt 1
 4747 0024 BB68     		ldr	r3, [r7, #8]
 4748 0026 5B6D     		ldr	r3, [r3, #84]
 4749 0028 002B     		cmp	r3, #0
 4750 002a 01D1     		bne	.L380
 4751              		.loc 1 3792 0 is_stmt 0 discriminator 1
 4752              	@ 3792 "../freertos/tasks.c" 1
 4753 002c 72B6     		 cpsid i 
 4754              	@ 0 "" 2
 4755              		.code	16
 4756              	.L381:
 4757 002e FEE7     		b	.L381
 4758              	.L380:
3793:../freertos/tasks.c **** 			( pxTCB->uxMutexesHeld )--;
 4759              		.loc 1 3793 0 is_stmt 1
 4760 0030 BB68     		ldr	r3, [r7, #8]
 4761 0032 5B6D     		ldr	r3, [r3, #84]
 4762 0034 5A1E     		sub	r2, r3, #1
 4763 0036 BB68     		ldr	r3, [r7, #8]
 4764 0038 5A65     		str	r2, [r3, #84]
3794:../freertos/tasks.c **** 
3795:../freertos/tasks.c **** 			/* Has the holder of the mutex inherited the priority of another
3796:../freertos/tasks.c **** 			task? */
3797:../freertos/tasks.c **** 			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 4765              		.loc 1 3797 0
 4766 003a BB68     		ldr	r3, [r7, #8]
 4767 003c DA6A     		ldr	r2, [r3, #44]
 4768 003e BB68     		ldr	r3, [r7, #8]
 4769 0040 1B6D     		ldr	r3, [r3, #80]
 4770 0042 9A42     		cmp	r2, r3
 4771 0044 2CD0     		beq	.L377
3798:../freertos/tasks.c **** 			{
3799:../freertos/tasks.c **** 				/* Only disinherit if no other mutexes are held. */
3800:../freertos/tasks.c **** 				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
 4772              		.loc 1 3800 0
 4773 0046 BB68     		ldr	r3, [r7, #8]
 4774 0048 5B6D     		ldr	r3, [r3, #84]
 4775 004a 002B     		cmp	r3, #0
 4776 004c 28D1     		bne	.L377
3801:../freertos/tasks.c **** 				{
3802:../freertos/tasks.c **** 					/* A task can only have an inherited priority if it holds
3803:../freertos/tasks.c **** 					the mutex.  If the mutex is held by a task then it cannot be
3804:../freertos/tasks.c **** 					given from an interrupt, and if a mutex is given by the
3805:../freertos/tasks.c **** 					holding	task then it must be the running state task.  Remove
3806:../freertos/tasks.c **** 					the	holding task from the ready	list. */
3807:../freertos/tasks.c **** 					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 4777              		.loc 1 3807 0
 4778 004e BB68     		ldr	r3, [r7, #8]
 4779 0050 0433     		add	r3, r3, #4
 4780 0052 181C     		mov	r0, r3
 4781 0054 FFF7FEFF 		bl	uxListRemove
3808:../freertos/tasks.c **** 					{
3809:../freertos/tasks.c **** 						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
3810:../freertos/tasks.c **** 					}
3811:../freertos/tasks.c **** 					else
3812:../freertos/tasks.c **** 					{
3813:../freertos/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
3814:../freertos/tasks.c **** 					}
3815:../freertos/tasks.c **** 
3816:../freertos/tasks.c **** 					/* Disinherit the priority before adding the task into the
3817:../freertos/tasks.c **** 					new	ready list. */
3818:../freertos/tasks.c **** 					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
3819:../freertos/tasks.c **** 					pxTCB->uxPriority = pxTCB->uxBasePriority;
 4782              		.loc 1 3819 0
 4783 0058 BB68     		ldr	r3, [r7, #8]
 4784 005a 1A6D     		ldr	r2, [r3, #80]
 4785 005c BB68     		ldr	r3, [r7, #8]
 4786 005e DA62     		str	r2, [r3, #44]
3820:../freertos/tasks.c **** 
3821:../freertos/tasks.c **** 					/* Reset the event list item value.  It cannot be in use for
3822:../freertos/tasks.c **** 					any other purpose if this task is running, and it must be
3823:../freertos/tasks.c **** 					running to give back the mutex. */
3824:../freertos/tasks.c **** 					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( T
 4787              		.loc 1 3824 0
 4788 0060 BB68     		ldr	r3, [r7, #8]
 4789 0062 DB6A     		ldr	r3, [r3, #44]
 4790 0064 0522     		mov	r2, #5
 4791 0066 D21A     		sub	r2, r2, r3
 4792 0068 BB68     		ldr	r3, [r7, #8]
 4793 006a 9A61     		str	r2, [r3, #24]
3825:../freertos/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 4794              		.loc 1 3825 0
 4795 006c BB68     		ldr	r3, [r7, #8]
 4796 006e DA6A     		ldr	r2, [r3, #44]
 4797 0070 0F4B     		ldr	r3, .L384+4
 4798 0072 1B68     		ldr	r3, [r3]
 4799 0074 9A42     		cmp	r2, r3
 4800 0076 03D9     		bls	.L382
 4801              		.loc 1 3825 0 is_stmt 0 discriminator 1
 4802 0078 BB68     		ldr	r3, [r7, #8]
 4803 007a DA6A     		ldr	r2, [r3, #44]
 4804 007c 0C4B     		ldr	r3, .L384+4
 4805 007e 1A60     		str	r2, [r3]
 4806              	.L382:
 4807              		.loc 1 3825 0 discriminator 2
 4808 0080 BB68     		ldr	r3, [r7, #8]
 4809 0082 DA6A     		ldr	r2, [r3, #44]
 4810 0084 131C     		mov	r3, r2
 4811 0086 9B00     		lsl	r3, r3, #2
 4812 0088 9B18     		add	r3, r3, r2
 4813 008a 9B00     		lsl	r3, r3, #2
 4814 008c 094A     		ldr	r2, .L384+8
 4815 008e 9A18     		add	r2, r3, r2
 4816 0090 BB68     		ldr	r3, [r7, #8]
 4817 0092 0433     		add	r3, r3, #4
 4818 0094 101C     		mov	r0, r2
 4819 0096 191C     		mov	r1, r3
 4820 0098 FFF7FEFF 		bl	vListInsertEnd
3826:../freertos/tasks.c **** 
3827:../freertos/tasks.c **** 					/* Return true to indicate that a context switch is required.
3828:../freertos/tasks.c **** 					This is only actually required in the corner case whereby
3829:../freertos/tasks.c **** 					multiple mutexes were held and the mutexes were given back
3830:../freertos/tasks.c **** 					in an order different to that in which they were taken.
3831:../freertos/tasks.c **** 					If a context switch did not occur when the first mutex was
3832:../freertos/tasks.c **** 					returned, even if a task was waiting on it, then a context
3833:../freertos/tasks.c **** 					switch should occur when the last mutex is returned whether
3834:../freertos/tasks.c **** 					a task is waiting on it or not. */
3835:../freertos/tasks.c **** 					xReturn = pdTRUE;
 4821              		.loc 1 3835 0 is_stmt 1 discriminator 2
 4822 009c 0123     		mov	r3, #1
 4823 009e FB60     		str	r3, [r7, #12]
 4824              	.L377:
3836:../freertos/tasks.c **** 				}
3837:../freertos/tasks.c **** 				else
3838:../freertos/tasks.c **** 				{
3839:../freertos/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
3840:../freertos/tasks.c **** 				}
3841:../freertos/tasks.c **** 			}
3842:../freertos/tasks.c **** 			else
3843:../freertos/tasks.c **** 			{
3844:../freertos/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3845:../freertos/tasks.c **** 			}
3846:../freertos/tasks.c **** 		}
3847:../freertos/tasks.c **** 		else
3848:../freertos/tasks.c **** 		{
3849:../freertos/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3850:../freertos/tasks.c **** 		}
3851:../freertos/tasks.c **** 
3852:../freertos/tasks.c **** 		return xReturn;
 4825              		.loc 1 3852 0
 4826 00a0 FB68     		ldr	r3, [r7, #12]
3853:../freertos/tasks.c **** 	}
 4827              		.loc 1 3853 0
 4828 00a2 181C     		mov	r0, r3
 4829 00a4 BD46     		mov	sp, r7
 4830 00a6 04B0     		add	sp, sp, #16
 4831              		@ sp needed
 4832 00a8 80BD     		pop	{r7, pc}
 4833              	.L385:
 4834 00aa C046     		.align	2
 4835              	.L384:
 4836 00ac 00000000 		.word	pxCurrentTCB
 4837 00b0 00000000 		.word	uxTopReadyPriority
 4838 00b4 00000000 		.word	pxReadyTasksLists
 4839              		.cfi_endproc
 4840              	.LFE48:
 4842              		.section	.text.uxTaskResetEventItemValue,"ax",%progbits
 4843              		.align	2
 4844              		.global	uxTaskResetEventItemValue
 4845              		.code	16
 4846              		.thumb_func
 4848              	uxTaskResetEventItemValue:
 4849              	.LFB49:
3854:../freertos/tasks.c **** 
3855:../freertos/tasks.c **** #endif /* configUSE_MUTEXES */
3856:../freertos/tasks.c **** /*-----------------------------------------------------------*/
3857:../freertos/tasks.c **** 
3858:../freertos/tasks.c **** #if ( portCRITICAL_NESTING_IN_TCB == 1 )
3859:../freertos/tasks.c **** 
3860:../freertos/tasks.c **** 	void vTaskEnterCritical( void )
3861:../freertos/tasks.c **** 	{
3862:../freertos/tasks.c **** 		portDISABLE_INTERRUPTS();
3863:../freertos/tasks.c **** 
3864:../freertos/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
3865:../freertos/tasks.c **** 		{
3866:../freertos/tasks.c **** 			( pxCurrentTCB->uxCriticalNesting )++;
3867:../freertos/tasks.c **** 
3868:../freertos/tasks.c **** 			/* This is not the interrupt safe version of the enter critical
3869:../freertos/tasks.c **** 			function so	assert() if it is being called from an interrupt
3870:../freertos/tasks.c **** 			context.  Only API functions that end in "FromISR" can be used in an
3871:../freertos/tasks.c **** 			interrupt.  Only assert if the critical nesting count is 1 to
3872:../freertos/tasks.c **** 			protect against recursive calls if the assert function also uses a
3873:../freertos/tasks.c **** 			critical section. */
3874:../freertos/tasks.c **** 			if( pxCurrentTCB->uxCriticalNesting == 1 )
3875:../freertos/tasks.c **** 			{
3876:../freertos/tasks.c **** 				portASSERT_IF_IN_ISR();
3877:../freertos/tasks.c **** 			}
3878:../freertos/tasks.c **** 		}
3879:../freertos/tasks.c **** 		else
3880:../freertos/tasks.c **** 		{
3881:../freertos/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3882:../freertos/tasks.c **** 		}
3883:../freertos/tasks.c **** 	}
3884:../freertos/tasks.c **** 
3885:../freertos/tasks.c **** #endif /* portCRITICAL_NESTING_IN_TCB */
3886:../freertos/tasks.c **** /*-----------------------------------------------------------*/
3887:../freertos/tasks.c **** 
3888:../freertos/tasks.c **** #if ( portCRITICAL_NESTING_IN_TCB == 1 )
3889:../freertos/tasks.c **** 
3890:../freertos/tasks.c **** 	void vTaskExitCritical( void )
3891:../freertos/tasks.c **** 	{
3892:../freertos/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
3893:../freertos/tasks.c **** 		{
3894:../freertos/tasks.c **** 			if( pxCurrentTCB->uxCriticalNesting > 0U )
3895:../freertos/tasks.c **** 			{
3896:../freertos/tasks.c **** 				( pxCurrentTCB->uxCriticalNesting )--;
3897:../freertos/tasks.c **** 
3898:../freertos/tasks.c **** 				if( pxCurrentTCB->uxCriticalNesting == 0U )
3899:../freertos/tasks.c **** 				{
3900:../freertos/tasks.c **** 					portENABLE_INTERRUPTS();
3901:../freertos/tasks.c **** 				}
3902:../freertos/tasks.c **** 				else
3903:../freertos/tasks.c **** 				{
3904:../freertos/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
3905:../freertos/tasks.c **** 				}
3906:../freertos/tasks.c **** 			}
3907:../freertos/tasks.c **** 			else
3908:../freertos/tasks.c **** 			{
3909:../freertos/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3910:../freertos/tasks.c **** 			}
3911:../freertos/tasks.c **** 		}
3912:../freertos/tasks.c **** 		else
3913:../freertos/tasks.c **** 		{
3914:../freertos/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3915:../freertos/tasks.c **** 		}
3916:../freertos/tasks.c **** 	}
3917:../freertos/tasks.c **** 
3918:../freertos/tasks.c **** #endif /* portCRITICAL_NESTING_IN_TCB */
3919:../freertos/tasks.c **** /*-----------------------------------------------------------*/
3920:../freertos/tasks.c **** 
3921:../freertos/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
3922:../freertos/tasks.c **** 
3923:../freertos/tasks.c **** 	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName )
3924:../freertos/tasks.c **** 	{
3925:../freertos/tasks.c **** 	size_t x;
3926:../freertos/tasks.c **** 
3927:../freertos/tasks.c **** 		/* Start by copying the entire string. */
3928:../freertos/tasks.c **** 		strcpy( pcBuffer, pcTaskName );
3929:../freertos/tasks.c **** 
3930:../freertos/tasks.c **** 		/* Pad the end of the string with spaces to ensure columns line up when
3931:../freertos/tasks.c **** 		printed out. */
3932:../freertos/tasks.c **** 		for( x = strlen( pcBuffer ); x < ( size_t ) ( configMAX_TASK_NAME_LEN - 1 ); x++ )
3933:../freertos/tasks.c **** 		{
3934:../freertos/tasks.c **** 			pcBuffer[ x ] = ' ';
3935:../freertos/tasks.c **** 		}
3936:../freertos/tasks.c **** 
3937:../freertos/tasks.c **** 		/* Terminate. */
3938:../freertos/tasks.c **** 		pcBuffer[ x ] = 0x00;
3939:../freertos/tasks.c **** 
3940:../freertos/tasks.c **** 		/* Return the new end of string. */
3941:../freertos/tasks.c **** 		return &( pcBuffer[ x ] );
3942:../freertos/tasks.c **** 	}
3943:../freertos/tasks.c **** 
3944:../freertos/tasks.c **** #endif /* ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) */
3945:../freertos/tasks.c **** /*-----------------------------------------------------------*/
3946:../freertos/tasks.c **** 
3947:../freertos/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
3948:../freertos/tasks.c **** 
3949:../freertos/tasks.c **** 	void vTaskList( char * pcWriteBuffer )
3950:../freertos/tasks.c **** 	{
3951:../freertos/tasks.c **** 	TaskStatus_t *pxTaskStatusArray;
3952:../freertos/tasks.c **** 	volatile UBaseType_t uxArraySize, x;
3953:../freertos/tasks.c **** 	char cStatus;
3954:../freertos/tasks.c **** 
3955:../freertos/tasks.c **** 		/*
3956:../freertos/tasks.c **** 		 * PLEASE NOTE:
3957:../freertos/tasks.c **** 		 *
3958:../freertos/tasks.c **** 		 * This function is provided for convenience only, and is used by many
3959:../freertos/tasks.c **** 		 * of the demo applications.  Do not consider it to be part of the
3960:../freertos/tasks.c **** 		 * scheduler.
3961:../freertos/tasks.c **** 		 *
3962:../freertos/tasks.c **** 		 * vTaskList() calls uxTaskGetSystemState(), then formats part of the
3963:../freertos/tasks.c **** 		 * uxTaskGetSystemState() output into a human readable table that
3964:../freertos/tasks.c **** 		 * displays task names, states and stack usage.
3965:../freertos/tasks.c **** 		 *
3966:../freertos/tasks.c **** 		 * vTaskList() has a dependency on the sprintf() C library function that
3967:../freertos/tasks.c **** 		 * might bloat the code size, use a lot of stack, and provide different
3968:../freertos/tasks.c **** 		 * results on different platforms.  An alternative, tiny, third party,
3969:../freertos/tasks.c **** 		 * and limited functionality implementation of sprintf() is provided in
3970:../freertos/tasks.c **** 		 * many of the FreeRTOS/Demo sub-directories in a file called
3971:../freertos/tasks.c **** 		 * printf-stdarg.c (note printf-stdarg.c does not provide a full
3972:../freertos/tasks.c **** 		 * snprintf() implementation!).
3973:../freertos/tasks.c **** 		 *
3974:../freertos/tasks.c **** 		 * It is recommended that production systems call uxTaskGetSystemState()
3975:../freertos/tasks.c **** 		 * directly to get access to raw stats data, rather than indirectly
3976:../freertos/tasks.c **** 		 * through a call to vTaskList().
3977:../freertos/tasks.c **** 		 */
3978:../freertos/tasks.c **** 
3979:../freertos/tasks.c **** 
3980:../freertos/tasks.c **** 		/* Make sure the write buffer does not contain a string. */
3981:../freertos/tasks.c **** 		*pcWriteBuffer = 0x00;
3982:../freertos/tasks.c **** 
3983:../freertos/tasks.c **** 		/* Take a snapshot of the number of tasks in case it changes while this
3984:../freertos/tasks.c **** 		function is executing. */
3985:../freertos/tasks.c **** 		uxArraySize = uxCurrentNumberOfTasks;
3986:../freertos/tasks.c **** 
3987:../freertos/tasks.c **** 		/* Allocate an array index for each task.  NOTE!  if
3988:../freertos/tasks.c **** 		configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
3989:../freertos/tasks.c **** 		equate to NULL. */
3990:../freertos/tasks.c **** 		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );
3991:../freertos/tasks.c **** 
3992:../freertos/tasks.c **** 		if( pxTaskStatusArray != NULL )
3993:../freertos/tasks.c **** 		{
3994:../freertos/tasks.c **** 			/* Generate the (binary) data. */
3995:../freertos/tasks.c **** 			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );
3996:../freertos/tasks.c **** 
3997:../freertos/tasks.c **** 			/* Create a human readable table from the binary data. */
3998:../freertos/tasks.c **** 			for( x = 0; x < uxArraySize; x++ )
3999:../freertos/tasks.c **** 			{
4000:../freertos/tasks.c **** 				switch( pxTaskStatusArray[ x ].eCurrentState )
4001:../freertos/tasks.c **** 				{
4002:../freertos/tasks.c **** 					case eReady:		cStatus = tskREADY_CHAR;
4003:../freertos/tasks.c **** 										break;
4004:../freertos/tasks.c **** 
4005:../freertos/tasks.c **** 					case eBlocked:		cStatus = tskBLOCKED_CHAR;
4006:../freertos/tasks.c **** 										break;
4007:../freertos/tasks.c **** 
4008:../freertos/tasks.c **** 					case eSuspended:	cStatus = tskSUSPENDED_CHAR;
4009:../freertos/tasks.c **** 										break;
4010:../freertos/tasks.c **** 
4011:../freertos/tasks.c **** 					case eDeleted:		cStatus = tskDELETED_CHAR;
4012:../freertos/tasks.c **** 										break;
4013:../freertos/tasks.c **** 
4014:../freertos/tasks.c **** 					default:			/* Should not get here, but it is included
4015:../freertos/tasks.c **** 										to prevent static checking errors. */
4016:../freertos/tasks.c **** 										cStatus = 0x00;
4017:../freertos/tasks.c **** 										break;
4018:../freertos/tasks.c **** 				}
4019:../freertos/tasks.c **** 
4020:../freertos/tasks.c **** 				/* Write the task name to the string, padding with spaces so it
4021:../freertos/tasks.c **** 				can be printed in tabular form more easily. */
4022:../freertos/tasks.c **** 				pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
4023:../freertos/tasks.c **** 
4024:../freertos/tasks.c **** 				/* Write the rest of the string. */
4025:../freertos/tasks.c **** 				sprintf( pcWriteBuffer, "\t%c\t%u\t%u\t%u\r\n", cStatus, ( unsigned int ) pxTaskStatusArray[ x 
4026:../freertos/tasks.c **** 				pcWriteBuffer += strlen( pcWriteBuffer );
4027:../freertos/tasks.c **** 			}
4028:../freertos/tasks.c **** 
4029:../freertos/tasks.c **** 			/* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
4030:../freertos/tasks.c **** 			is 0 then vPortFree() will be #defined to nothing. */
4031:../freertos/tasks.c **** 			vPortFree( pxTaskStatusArray );
4032:../freertos/tasks.c **** 		}
4033:../freertos/tasks.c **** 		else
4034:../freertos/tasks.c **** 		{
4035:../freertos/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4036:../freertos/tasks.c **** 		}
4037:../freertos/tasks.c **** 	}
4038:../freertos/tasks.c **** 
4039:../freertos/tasks.c **** #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) */
4040:../freertos/tasks.c **** /*----------------------------------------------------------*/
4041:../freertos/tasks.c **** 
4042:../freertos/tasks.c **** #if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
4043:../freertos/tasks.c **** 
4044:../freertos/tasks.c **** 	void vTaskGetRunTimeStats( char *pcWriteBuffer )
4045:../freertos/tasks.c **** 	{
4046:../freertos/tasks.c **** 	TaskStatus_t *pxTaskStatusArray;
4047:../freertos/tasks.c **** 	volatile UBaseType_t uxArraySize, x;
4048:../freertos/tasks.c **** 	uint32_t ulTotalTime, ulStatsAsPercentage;
4049:../freertos/tasks.c **** 
4050:../freertos/tasks.c **** 		#if( configUSE_TRACE_FACILITY != 1 )
4051:../freertos/tasks.c **** 		{
4052:../freertos/tasks.c **** 			#error configUSE_TRACE_FACILITY must also be set to 1 in FreeRTOSConfig.h to use vTaskGetRunTime
4053:../freertos/tasks.c **** 		}
4054:../freertos/tasks.c **** 		#endif
4055:../freertos/tasks.c **** 
4056:../freertos/tasks.c **** 		/*
4057:../freertos/tasks.c **** 		 * PLEASE NOTE:
4058:../freertos/tasks.c **** 		 *
4059:../freertos/tasks.c **** 		 * This function is provided for convenience only, and is used by many
4060:../freertos/tasks.c **** 		 * of the demo applications.  Do not consider it to be part of the
4061:../freertos/tasks.c **** 		 * scheduler.
4062:../freertos/tasks.c **** 		 *
4063:../freertos/tasks.c **** 		 * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part
4064:../freertos/tasks.c **** 		 * of the uxTaskGetSystemState() output into a human readable table that
4065:../freertos/tasks.c **** 		 * displays the amount of time each task has spent in the Running state
4066:../freertos/tasks.c **** 		 * in both absolute and percentage terms.
4067:../freertos/tasks.c **** 		 *
4068:../freertos/tasks.c **** 		 * vTaskGetRunTimeStats() has a dependency on the sprintf() C library
4069:../freertos/tasks.c **** 		 * function that might bloat the code size, use a lot of stack, and
4070:../freertos/tasks.c **** 		 * provide different results on different platforms.  An alternative,
4071:../freertos/tasks.c **** 		 * tiny, third party, and limited functionality implementation of
4072:../freertos/tasks.c **** 		 * sprintf() is provided in many of the FreeRTOS/Demo sub-directories in
4073:../freertos/tasks.c **** 		 * a file called printf-stdarg.c (note printf-stdarg.c does not provide
4074:../freertos/tasks.c **** 		 * a full snprintf() implementation!).
4075:../freertos/tasks.c **** 		 *
4076:../freertos/tasks.c **** 		 * It is recommended that production systems call uxTaskGetSystemState()
4077:../freertos/tasks.c **** 		 * directly to get access to raw stats data, rather than indirectly
4078:../freertos/tasks.c **** 		 * through a call to vTaskGetRunTimeStats().
4079:../freertos/tasks.c **** 		 */
4080:../freertos/tasks.c **** 
4081:../freertos/tasks.c **** 		/* Make sure the write buffer does not contain a string. */
4082:../freertos/tasks.c **** 		*pcWriteBuffer = 0x00;
4083:../freertos/tasks.c **** 
4084:../freertos/tasks.c **** 		/* Take a snapshot of the number of tasks in case it changes while this
4085:../freertos/tasks.c **** 		function is executing. */
4086:../freertos/tasks.c **** 		uxArraySize = uxCurrentNumberOfTasks;
4087:../freertos/tasks.c **** 
4088:../freertos/tasks.c **** 		/* Allocate an array index for each task.  NOTE!  If
4089:../freertos/tasks.c **** 		configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
4090:../freertos/tasks.c **** 		equate to NULL. */
4091:../freertos/tasks.c **** 		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );
4092:../freertos/tasks.c **** 
4093:../freertos/tasks.c **** 		if( pxTaskStatusArray != NULL )
4094:../freertos/tasks.c **** 		{
4095:../freertos/tasks.c **** 			/* Generate the (binary) data. */
4096:../freertos/tasks.c **** 			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalTime );
4097:../freertos/tasks.c **** 
4098:../freertos/tasks.c **** 			/* For percentage calculations. */
4099:../freertos/tasks.c **** 			ulTotalTime /= 100UL;
4100:../freertos/tasks.c **** 
4101:../freertos/tasks.c **** 			/* Avoid divide by zero errors. */
4102:../freertos/tasks.c **** 			if( ulTotalTime > 0 )
4103:../freertos/tasks.c **** 			{
4104:../freertos/tasks.c **** 				/* Create a human readable table from the binary data. */
4105:../freertos/tasks.c **** 				for( x = 0; x < uxArraySize; x++ )
4106:../freertos/tasks.c **** 				{
4107:../freertos/tasks.c **** 					/* What percentage of the total run time has the task used?
4108:../freertos/tasks.c **** 					This will always be rounded down to the nearest integer.
4109:../freertos/tasks.c **** 					ulTotalRunTimeDiv100 has already been divided by 100. */
4110:../freertos/tasks.c **** 					ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalTime;
4111:../freertos/tasks.c **** 
4112:../freertos/tasks.c **** 					/* Write the task name to the string, padding with
4113:../freertos/tasks.c **** 					spaces so it can be printed in tabular form more
4114:../freertos/tasks.c **** 					easily. */
4115:../freertos/tasks.c **** 					pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
4116:../freertos/tasks.c **** 
4117:../freertos/tasks.c **** 					if( ulStatsAsPercentage > 0UL )
4118:../freertos/tasks.c **** 					{
4119:../freertos/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
4120:../freertos/tasks.c **** 						{
4121:../freertos/tasks.c **** 							sprintf( pcWriteBuffer, "\t%lu\t\t%lu%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter, ulSta
4122:../freertos/tasks.c **** 						}
4123:../freertos/tasks.c **** 						#else
4124:../freertos/tasks.c **** 						{
4125:../freertos/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
4126:../freertos/tasks.c **** 							printf() library can be used. */
4127:../freertos/tasks.c **** 							sprintf( pcWriteBuffer, "\t%u\t\t%u%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTim
4128:../freertos/tasks.c **** 						}
4129:../freertos/tasks.c **** 						#endif
4130:../freertos/tasks.c **** 					}
4131:../freertos/tasks.c **** 					else
4132:../freertos/tasks.c **** 					{
4133:../freertos/tasks.c **** 						/* If the percentage is zero here then the task has
4134:../freertos/tasks.c **** 						consumed less than 1% of the total run time. */
4135:../freertos/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
4136:../freertos/tasks.c **** 						{
4137:../freertos/tasks.c **** 							sprintf( pcWriteBuffer, "\t%lu\t\t<1%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter );
4138:../freertos/tasks.c **** 						}
4139:../freertos/tasks.c **** 						#else
4140:../freertos/tasks.c **** 						{
4141:../freertos/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
4142:../freertos/tasks.c **** 							printf() library can be used. */
4143:../freertos/tasks.c **** 							sprintf( pcWriteBuffer, "\t%u\t\t<1%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTim
4144:../freertos/tasks.c **** 						}
4145:../freertos/tasks.c **** 						#endif
4146:../freertos/tasks.c **** 					}
4147:../freertos/tasks.c **** 
4148:../freertos/tasks.c **** 					pcWriteBuffer += strlen( pcWriteBuffer );
4149:../freertos/tasks.c **** 				}
4150:../freertos/tasks.c **** 			}
4151:../freertos/tasks.c **** 			else
4152:../freertos/tasks.c **** 			{
4153:../freertos/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4154:../freertos/tasks.c **** 			}
4155:../freertos/tasks.c **** 
4156:../freertos/tasks.c **** 			/* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
4157:../freertos/tasks.c **** 			is 0 then vPortFree() will be #defined to nothing. */
4158:../freertos/tasks.c **** 			vPortFree( pxTaskStatusArray );
4159:../freertos/tasks.c **** 		}
4160:../freertos/tasks.c **** 		else
4161:../freertos/tasks.c **** 		{
4162:../freertos/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4163:../freertos/tasks.c **** 		}
4164:../freertos/tasks.c **** 	}
4165:../freertos/tasks.c **** 
4166:../freertos/tasks.c **** #endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) 
4167:../freertos/tasks.c **** /*-----------------------------------------------------------*/
4168:../freertos/tasks.c **** 
4169:../freertos/tasks.c **** TickType_t uxTaskResetEventItemValue( void )
4170:../freertos/tasks.c **** {
 4850              		.loc 1 4170 0
 4851              		.cfi_startproc
 4852 0000 80B5     		push	{r7, lr}
 4853              		.cfi_def_cfa_offset 8
 4854              		.cfi_offset 7, -8
 4855              		.cfi_offset 14, -4
 4856 0002 82B0     		sub	sp, sp, #8
 4857              		.cfi_def_cfa_offset 16
 4858 0004 00AF     		add	r7, sp, #0
 4859              		.cfi_def_cfa_register 7
4171:../freertos/tasks.c **** TickType_t uxReturn;
4172:../freertos/tasks.c **** 
4173:../freertos/tasks.c **** 	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
 4860              		.loc 1 4173 0
 4861 0006 084B     		ldr	r3, .L388
 4862 0008 1B68     		ldr	r3, [r3]
 4863 000a 9B69     		ldr	r3, [r3, #24]
 4864 000c 7B60     		str	r3, [r7, #4]
4174:../freertos/tasks.c **** 
4175:../freertos/tasks.c **** 	/* Reset the event list item to its normal value - so it can be used with
4176:../freertos/tasks.c **** 	queues and semaphores. */
4177:../freertos/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES 
 4865              		.loc 1 4177 0
 4866 000e 064B     		ldr	r3, .L388
 4867 0010 1B68     		ldr	r3, [r3]
 4868 0012 054A     		ldr	r2, .L388
 4869 0014 1268     		ldr	r2, [r2]
 4870 0016 D26A     		ldr	r2, [r2, #44]
 4871 0018 0521     		mov	r1, #5
 4872 001a 8A1A     		sub	r2, r1, r2
 4873 001c 9A61     		str	r2, [r3, #24]
4178:../freertos/tasks.c **** 
4179:../freertos/tasks.c **** 	return uxReturn;
 4874              		.loc 1 4179 0
 4875 001e 7B68     		ldr	r3, [r7, #4]
4180:../freertos/tasks.c **** }
 4876              		.loc 1 4180 0
 4877 0020 181C     		mov	r0, r3
 4878 0022 BD46     		mov	sp, r7
 4879 0024 02B0     		add	sp, sp, #8
 4880              		@ sp needed
 4881 0026 80BD     		pop	{r7, pc}
 4882              	.L389:
 4883              		.align	2
 4884              	.L388:
 4885 0028 00000000 		.word	pxCurrentTCB
 4886              		.cfi_endproc
 4887              	.LFE49:
 4889              		.section	.text.pvTaskIncrementMutexHeldCount,"ax",%progbits
 4890              		.align	2
 4891              		.global	pvTaskIncrementMutexHeldCount
 4892              		.code	16
 4893              		.thumb_func
 4895              	pvTaskIncrementMutexHeldCount:
 4896              	.LFB50:
4181:../freertos/tasks.c **** /*-----------------------------------------------------------*/
4182:../freertos/tasks.c **** 
4183:../freertos/tasks.c **** #if ( configUSE_MUTEXES == 1 )
4184:../freertos/tasks.c **** 
4185:../freertos/tasks.c **** 	void *pvTaskIncrementMutexHeldCount( void )
4186:../freertos/tasks.c **** 	{
 4897              		.loc 1 4186 0
 4898              		.cfi_startproc
 4899 0000 80B5     		push	{r7, lr}
 4900              		.cfi_def_cfa_offset 8
 4901              		.cfi_offset 7, -8
 4902              		.cfi_offset 14, -4
 4903 0002 00AF     		add	r7, sp, #0
 4904              		.cfi_def_cfa_register 7
4187:../freertos/tasks.c **** 		/* If xSemaphoreCreateMutex() is called before any tasks have been created
4188:../freertos/tasks.c **** 		then pxCurrentTCB will be NULL. */
4189:../freertos/tasks.c **** 		if( pxCurrentTCB != NULL )
 4905              		.loc 1 4189 0
 4906 0004 064B     		ldr	r3, .L393
 4907 0006 1B68     		ldr	r3, [r3]
 4908 0008 002B     		cmp	r3, #0
 4909 000a 04D0     		beq	.L391
4190:../freertos/tasks.c **** 		{
4191:../freertos/tasks.c **** 			( pxCurrentTCB->uxMutexesHeld )++;
 4910              		.loc 1 4191 0
 4911 000c 044B     		ldr	r3, .L393
 4912 000e 1B68     		ldr	r3, [r3]
 4913 0010 5A6D     		ldr	r2, [r3, #84]
 4914 0012 0132     		add	r2, r2, #1
 4915 0014 5A65     		str	r2, [r3, #84]
 4916              	.L391:
4192:../freertos/tasks.c **** 		}
4193:../freertos/tasks.c **** 
4194:../freertos/tasks.c **** 		return pxCurrentTCB;
 4917              		.loc 1 4194 0
 4918 0016 024B     		ldr	r3, .L393
 4919 0018 1B68     		ldr	r3, [r3]
4195:../freertos/tasks.c **** 	}
 4920              		.loc 1 4195 0
 4921 001a 181C     		mov	r0, r3
 4922 001c BD46     		mov	sp, r7
 4923              		@ sp needed
 4924 001e 80BD     		pop	{r7, pc}
 4925              	.L394:
 4926              		.align	2
 4927              	.L393:
 4928 0020 00000000 		.word	pxCurrentTCB
 4929              		.cfi_endproc
 4930              	.LFE50:
 4932              		.section	.text.ulTaskNotifyTake,"ax",%progbits
 4933              		.align	2
 4934              		.global	ulTaskNotifyTake
 4935              		.code	16
 4936              		.thumb_func
 4938              	ulTaskNotifyTake:
 4939              	.LFB51:
4196:../freertos/tasks.c **** 
4197:../freertos/tasks.c **** #endif /* configUSE_MUTEXES */
4198:../freertos/tasks.c **** /*-----------------------------------------------------------*/
4199:../freertos/tasks.c **** 
4200:../freertos/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4201:../freertos/tasks.c **** 
4202:../freertos/tasks.c **** 	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
4203:../freertos/tasks.c **** 	{
 4940              		.loc 1 4203 0
 4941              		.cfi_startproc
 4942 0000 80B5     		push	{r7, lr}
 4943              		.cfi_def_cfa_offset 8
 4944              		.cfi_offset 7, -8
 4945              		.cfi_offset 14, -4
 4946 0002 84B0     		sub	sp, sp, #16
 4947              		.cfi_def_cfa_offset 24
 4948 0004 00AF     		add	r7, sp, #0
 4949              		.cfi_def_cfa_register 7
 4950 0006 7860     		str	r0, [r7, #4]
 4951 0008 3960     		str	r1, [r7]
4204:../freertos/tasks.c **** 	uint32_t ulReturn;
4205:../freertos/tasks.c **** 
4206:../freertos/tasks.c **** 		taskENTER_CRITICAL();
 4952              		.loc 1 4206 0
 4953 000a FFF7FEFF 		bl	vPortEnterCritical
4207:../freertos/tasks.c **** 		{
4208:../freertos/tasks.c **** 			/* Only block if the notification count is not already non-zero. */
4209:../freertos/tasks.c **** 			if( pxCurrentTCB->ulNotifiedValue == 0UL )
 4954              		.loc 1 4209 0
 4955 000e 1C4B     		ldr	r3, .L401
 4956 0010 1B68     		ldr	r3, [r3]
 4957 0012 DB6E     		ldr	r3, [r3, #108]
 4958 0014 002B     		cmp	r3, #0
 4959 0016 0ED1     		bne	.L396
4210:../freertos/tasks.c **** 			{
4211:../freertos/tasks.c **** 				/* Mark this task as waiting for a notification. */
4212:../freertos/tasks.c **** 				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
 4960              		.loc 1 4212 0
 4961 0018 194B     		ldr	r3, .L401
 4962 001a 1A68     		ldr	r2, [r3]
 4963 001c 7023     		mov	r3, #112
 4964 001e 0121     		mov	r1, #1
 4965 0020 D154     		strb	r1, [r2, r3]
4213:../freertos/tasks.c **** 
4214:../freertos/tasks.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
 4966              		.loc 1 4214 0
 4967 0022 3B68     		ldr	r3, [r7]
 4968 0024 002B     		cmp	r3, #0
 4969 0026 06D0     		beq	.L396
4215:../freertos/tasks.c **** 				{
4216:../freertos/tasks.c **** 					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 4970              		.loc 1 4216 0
 4971 0028 3B68     		ldr	r3, [r7]
 4972 002a 181C     		mov	r0, r3
 4973 002c 0121     		mov	r1, #1
 4974 002e FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
4217:../freertos/tasks.c **** 					traceTASK_NOTIFY_TAKE_BLOCK();
4218:../freertos/tasks.c **** 
4219:../freertos/tasks.c **** 					/* All ports are written to allow a yield in a critical
4220:../freertos/tasks.c **** 					section (some will yield immediately, others wait until the
4221:../freertos/tasks.c **** 					critical section exits) - but it is not something that
4222:../freertos/tasks.c **** 					application code should ever do. */
4223:../freertos/tasks.c **** 					portYIELD_WITHIN_API();
 4975              		.loc 1 4223 0
 4976 0032 FFF7FEFF 		bl	vPortYield
 4977              	.L396:
4224:../freertos/tasks.c **** 				}
4225:../freertos/tasks.c **** 				else
4226:../freertos/tasks.c **** 				{
4227:../freertos/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4228:../freertos/tasks.c **** 				}
4229:../freertos/tasks.c **** 			}
4230:../freertos/tasks.c **** 			else
4231:../freertos/tasks.c **** 			{
4232:../freertos/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4233:../freertos/tasks.c **** 			}
4234:../freertos/tasks.c **** 		}
4235:../freertos/tasks.c **** 		taskEXIT_CRITICAL();
 4978              		.loc 1 4235 0
 4979 0036 FFF7FEFF 		bl	vPortExitCritical
4236:../freertos/tasks.c **** 
4237:../freertos/tasks.c **** 		taskENTER_CRITICAL();
 4980              		.loc 1 4237 0
 4981 003a FFF7FEFF 		bl	vPortEnterCritical
4238:../freertos/tasks.c **** 		{
4239:../freertos/tasks.c **** 			traceTASK_NOTIFY_TAKE();
4240:../freertos/tasks.c **** 			ulReturn = pxCurrentTCB->ulNotifiedValue;
 4982              		.loc 1 4240 0
 4983 003e 104B     		ldr	r3, .L401
 4984 0040 1B68     		ldr	r3, [r3]
 4985 0042 DB6E     		ldr	r3, [r3, #108]
 4986 0044 FB60     		str	r3, [r7, #12]
4241:../freertos/tasks.c **** 
4242:../freertos/tasks.c **** 			if( ulReturn != 0UL )
 4987              		.loc 1 4242 0
 4988 0046 FB68     		ldr	r3, [r7, #12]
 4989 0048 002B     		cmp	r3, #0
 4990 004a 0CD0     		beq	.L397
4243:../freertos/tasks.c **** 			{
4244:../freertos/tasks.c **** 				if( xClearCountOnExit != pdFALSE )
 4991              		.loc 1 4244 0
 4992 004c 7B68     		ldr	r3, [r7, #4]
 4993 004e 002B     		cmp	r3, #0
 4994 0050 04D0     		beq	.L398
4245:../freertos/tasks.c **** 				{
4246:../freertos/tasks.c **** 					pxCurrentTCB->ulNotifiedValue = 0UL;
 4995              		.loc 1 4246 0
 4996 0052 0B4B     		ldr	r3, .L401
 4997 0054 1B68     		ldr	r3, [r3]
 4998 0056 0022     		mov	r2, #0
 4999 0058 DA66     		str	r2, [r3, #108]
 5000 005a 04E0     		b	.L397
 5001              	.L398:
4247:../freertos/tasks.c **** 				}
4248:../freertos/tasks.c **** 				else
4249:../freertos/tasks.c **** 				{
4250:../freertos/tasks.c **** 					pxCurrentTCB->ulNotifiedValue = ulReturn - 1;
 5002              		.loc 1 4250 0
 5003 005c 084B     		ldr	r3, .L401
 5004 005e 1B68     		ldr	r3, [r3]
 5005 0060 FA68     		ldr	r2, [r7, #12]
 5006 0062 013A     		sub	r2, r2, #1
 5007 0064 DA66     		str	r2, [r3, #108]
 5008              	.L397:
4251:../freertos/tasks.c **** 				}
4252:../freertos/tasks.c **** 			}
4253:../freertos/tasks.c **** 			else
4254:../freertos/tasks.c **** 			{
4255:../freertos/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4256:../freertos/tasks.c **** 			}
4257:../freertos/tasks.c **** 
4258:../freertos/tasks.c **** 			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 5009              		.loc 1 4258 0
 5010 0066 064B     		ldr	r3, .L401
 5011 0068 1A68     		ldr	r2, [r3]
 5012 006a 7023     		mov	r3, #112
 5013 006c 0021     		mov	r1, #0
 5014 006e D154     		strb	r1, [r2, r3]
4259:../freertos/tasks.c **** 		}
4260:../freertos/tasks.c **** 		taskEXIT_CRITICAL();
 5015              		.loc 1 4260 0
 5016 0070 FFF7FEFF 		bl	vPortExitCritical
4261:../freertos/tasks.c **** 
4262:../freertos/tasks.c **** 		return ulReturn;
 5017              		.loc 1 4262 0
 5018 0074 FB68     		ldr	r3, [r7, #12]
4263:../freertos/tasks.c **** 	}
 5019              		.loc 1 4263 0
 5020 0076 181C     		mov	r0, r3
 5021 0078 BD46     		mov	sp, r7
 5022 007a 04B0     		add	sp, sp, #16
 5023              		@ sp needed
 5024 007c 80BD     		pop	{r7, pc}
 5025              	.L402:
 5026 007e C046     		.align	2
 5027              	.L401:
 5028 0080 00000000 		.word	pxCurrentTCB
 5029              		.cfi_endproc
 5030              	.LFE51:
 5032              		.section	.text.xTaskNotifyWait,"ax",%progbits
 5033              		.align	2
 5034              		.global	xTaskNotifyWait
 5035              		.code	16
 5036              		.thumb_func
 5038              	xTaskNotifyWait:
 5039              	.LFB52:
4264:../freertos/tasks.c **** 
4265:../freertos/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4266:../freertos/tasks.c **** /*-----------------------------------------------------------*/
4267:../freertos/tasks.c **** 
4268:../freertos/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4269:../freertos/tasks.c **** 
4270:../freertos/tasks.c **** 	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t 
4271:../freertos/tasks.c **** 	{
 5040              		.loc 1 4271 0
 5041              		.cfi_startproc
 5042 0000 80B5     		push	{r7, lr}
 5043              		.cfi_def_cfa_offset 8
 5044              		.cfi_offset 7, -8
 5045              		.cfi_offset 14, -4
 5046 0002 86B0     		sub	sp, sp, #24
 5047              		.cfi_def_cfa_offset 32
 5048 0004 00AF     		add	r7, sp, #0
 5049              		.cfi_def_cfa_register 7
 5050 0006 F860     		str	r0, [r7, #12]
 5051 0008 B960     		str	r1, [r7, #8]
 5052 000a 7A60     		str	r2, [r7, #4]
 5053 000c 3B60     		str	r3, [r7]
4272:../freertos/tasks.c **** 	BaseType_t xReturn;
4273:../freertos/tasks.c **** 
4274:../freertos/tasks.c **** 		taskENTER_CRITICAL();
 5054              		.loc 1 4274 0
 5055 000e FFF7FEFF 		bl	vPortEnterCritical
4275:../freertos/tasks.c **** 		{
4276:../freertos/tasks.c **** 			/* Only block if a notification is not already pending. */
4277:../freertos/tasks.c **** 			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
 5056              		.loc 1 4277 0
 5057 0012 244B     		ldr	r3, .L409
 5058 0014 1A68     		ldr	r2, [r3]
 5059 0016 7023     		mov	r3, #112
 5060 0018 D35C     		ldrb	r3, [r2, r3]
 5061 001a DBB2     		uxtb	r3, r3
 5062 001c 022B     		cmp	r3, #2
 5063 001e 15D0     		beq	.L404
4278:../freertos/tasks.c **** 			{
4279:../freertos/tasks.c **** 				/* Clear bits in the task's notification value as bits may get
4280:../freertos/tasks.c **** 				set	by the notifying task or interrupt.  This can be used to
4281:../freertos/tasks.c **** 				clear the value to zero. */
4282:../freertos/tasks.c **** 				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
 5064              		.loc 1 4282 0
 5065 0020 204B     		ldr	r3, .L409
 5066 0022 1B68     		ldr	r3, [r3]
 5067 0024 DA6E     		ldr	r2, [r3, #108]
 5068 0026 F968     		ldr	r1, [r7, #12]
 5069 0028 C943     		mvn	r1, r1
 5070 002a 0A40     		and	r2, r1
 5071 002c DA66     		str	r2, [r3, #108]
4283:../freertos/tasks.c **** 
4284:../freertos/tasks.c **** 				/* Mark this task as waiting for a notification. */
4285:../freertos/tasks.c **** 				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
 5072              		.loc 1 4285 0
 5073 002e 1D4B     		ldr	r3, .L409
 5074 0030 1A68     		ldr	r2, [r3]
 5075 0032 7023     		mov	r3, #112
 5076 0034 0121     		mov	r1, #1
 5077 0036 D154     		strb	r1, [r2, r3]
4286:../freertos/tasks.c **** 
4287:../freertos/tasks.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
 5078              		.loc 1 4287 0
 5079 0038 3B68     		ldr	r3, [r7]
 5080 003a 002B     		cmp	r3, #0
 5081 003c 06D0     		beq	.L404
4288:../freertos/tasks.c **** 				{
4289:../freertos/tasks.c **** 					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 5082              		.loc 1 4289 0
 5083 003e 3B68     		ldr	r3, [r7]
 5084 0040 181C     		mov	r0, r3
 5085 0042 0121     		mov	r1, #1
 5086 0044 FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
4290:../freertos/tasks.c **** 					traceTASK_NOTIFY_WAIT_BLOCK();
4291:../freertos/tasks.c **** 
4292:../freertos/tasks.c **** 					/* All ports are written to allow a yield in a critical
4293:../freertos/tasks.c **** 					section (some will yield immediately, others wait until the
4294:../freertos/tasks.c **** 					critical section exits) - but it is not something that
4295:../freertos/tasks.c **** 					application code should ever do. */
4296:../freertos/tasks.c **** 					portYIELD_WITHIN_API();
 5087              		.loc 1 4296 0
 5088 0048 FFF7FEFF 		bl	vPortYield
 5089              	.L404:
4297:../freertos/tasks.c **** 				}
4298:../freertos/tasks.c **** 				else
4299:../freertos/tasks.c **** 				{
4300:../freertos/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4301:../freertos/tasks.c **** 				}
4302:../freertos/tasks.c **** 			}
4303:../freertos/tasks.c **** 			else
4304:../freertos/tasks.c **** 			{
4305:../freertos/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4306:../freertos/tasks.c **** 			}
4307:../freertos/tasks.c **** 		}
4308:../freertos/tasks.c **** 		taskEXIT_CRITICAL();
 5090              		.loc 1 4308 0
 5091 004c FFF7FEFF 		bl	vPortExitCritical
4309:../freertos/tasks.c **** 
4310:../freertos/tasks.c **** 		taskENTER_CRITICAL();
 5092              		.loc 1 4310 0
 5093 0050 FFF7FEFF 		bl	vPortEnterCritical
4311:../freertos/tasks.c **** 		{
4312:../freertos/tasks.c **** 			traceTASK_NOTIFY_WAIT();
4313:../freertos/tasks.c **** 
4314:../freertos/tasks.c **** 			if( pulNotificationValue != NULL )
 5094              		.loc 1 4314 0
 5095 0054 7B68     		ldr	r3, [r7, #4]
 5096 0056 002B     		cmp	r3, #0
 5097 0058 04D0     		beq	.L405
4315:../freertos/tasks.c **** 			{
4316:../freertos/tasks.c **** 				/* Output the current notification value, which may or may not
4317:../freertos/tasks.c **** 				have changed. */
4318:../freertos/tasks.c **** 				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
 5098              		.loc 1 4318 0
 5099 005a 124B     		ldr	r3, .L409
 5100 005c 1B68     		ldr	r3, [r3]
 5101 005e DA6E     		ldr	r2, [r3, #108]
 5102 0060 7B68     		ldr	r3, [r7, #4]
 5103 0062 1A60     		str	r2, [r3]
 5104              	.L405:
4319:../freertos/tasks.c **** 			}
4320:../freertos/tasks.c **** 
4321:../freertos/tasks.c **** 			/* If ucNotifyValue is set then either the task never entered the
4322:../freertos/tasks.c **** 			blocked state (because a notification was already pending) or the
4323:../freertos/tasks.c **** 			task unblocked because of a notification.  Otherwise the task
4324:../freertos/tasks.c **** 			unblocked because of a timeout. */
4325:../freertos/tasks.c **** 			if( pxCurrentTCB->ucNotifyState == taskWAITING_NOTIFICATION )
 5105              		.loc 1 4325 0
 5106 0064 0F4B     		ldr	r3, .L409
 5107 0066 1A68     		ldr	r2, [r3]
 5108 0068 7023     		mov	r3, #112
 5109 006a D35C     		ldrb	r3, [r2, r3]
 5110 006c DBB2     		uxtb	r3, r3
 5111 006e 012B     		cmp	r3, #1
 5112 0070 02D1     		bne	.L406
4326:../freertos/tasks.c **** 			{
4327:../freertos/tasks.c **** 				/* A notification was not received. */
4328:../freertos/tasks.c **** 				xReturn = pdFALSE;
 5113              		.loc 1 4328 0
 5114 0072 0023     		mov	r3, #0
 5115 0074 7B61     		str	r3, [r7, #20]
 5116 0076 08E0     		b	.L407
 5117              	.L406:
4329:../freertos/tasks.c **** 			}
4330:../freertos/tasks.c **** 			else
4331:../freertos/tasks.c **** 			{
4332:../freertos/tasks.c **** 				/* A notification was already pending or a notification was
4333:../freertos/tasks.c **** 				received while the task was waiting. */
4334:../freertos/tasks.c **** 				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
 5118              		.loc 1 4334 0
 5119 0078 0A4B     		ldr	r3, .L409
 5120 007a 1B68     		ldr	r3, [r3]
 5121 007c DA6E     		ldr	r2, [r3, #108]
 5122 007e B968     		ldr	r1, [r7, #8]
 5123 0080 C943     		mvn	r1, r1
 5124 0082 0A40     		and	r2, r1
 5125 0084 DA66     		str	r2, [r3, #108]
4335:../freertos/tasks.c **** 				xReturn = pdTRUE;
 5126              		.loc 1 4335 0
 5127 0086 0123     		mov	r3, #1
 5128 0088 7B61     		str	r3, [r7, #20]
 5129              	.L407:
4336:../freertos/tasks.c **** 			}
4337:../freertos/tasks.c **** 
4338:../freertos/tasks.c **** 			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 5130              		.loc 1 4338 0
 5131 008a 064B     		ldr	r3, .L409
 5132 008c 1A68     		ldr	r2, [r3]
 5133 008e 7023     		mov	r3, #112
 5134 0090 0021     		mov	r1, #0
 5135 0092 D154     		strb	r1, [r2, r3]
4339:../freertos/tasks.c **** 		}
4340:../freertos/tasks.c **** 		taskEXIT_CRITICAL();
 5136              		.loc 1 4340 0
 5137 0094 FFF7FEFF 		bl	vPortExitCritical
4341:../freertos/tasks.c **** 
4342:../freertos/tasks.c **** 		return xReturn;
 5138              		.loc 1 4342 0
 5139 0098 7B69     		ldr	r3, [r7, #20]
4343:../freertos/tasks.c **** 	}
 5140              		.loc 1 4343 0
 5141 009a 181C     		mov	r0, r3
 5142 009c BD46     		mov	sp, r7
 5143 009e 06B0     		add	sp, sp, #24
 5144              		@ sp needed
 5145 00a0 80BD     		pop	{r7, pc}
 5146              	.L410:
 5147 00a2 C046     		.align	2
 5148              	.L409:
 5149 00a4 00000000 		.word	pxCurrentTCB
 5150              		.cfi_endproc
 5151              	.LFE52:
 5153              		.section	.text.xTaskGenericNotify,"ax",%progbits
 5154              		.align	2
 5155              		.global	xTaskGenericNotify
 5156              		.code	16
 5157              		.thumb_func
 5159              	xTaskGenericNotify:
 5160              	.LFB53:
4344:../freertos/tasks.c **** 
4345:../freertos/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4346:../freertos/tasks.c **** /*-----------------------------------------------------------*/
4347:../freertos/tasks.c **** 
4348:../freertos/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4349:../freertos/tasks.c **** 
4350:../freertos/tasks.c **** 	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction
4351:../freertos/tasks.c **** 	{
 5161              		.loc 1 4351 0
 5162              		.cfi_startproc
 5163 0000 80B5     		push	{r7, lr}
 5164              		.cfi_def_cfa_offset 8
 5165              		.cfi_offset 7, -8
 5166              		.cfi_offset 14, -4
 5167 0002 88B0     		sub	sp, sp, #32
 5168              		.cfi_def_cfa_offset 40
 5169 0004 00AF     		add	r7, sp, #0
 5170              		.cfi_def_cfa_register 7
 5171 0006 F860     		str	r0, [r7, #12]
 5172 0008 B960     		str	r1, [r7, #8]
 5173 000a 3B60     		str	r3, [r7]
 5174 000c FB1D     		add	r3, r7, #7
 5175 000e 1A70     		strb	r2, [r3]
4352:../freertos/tasks.c **** 	TCB_t * pxTCB;
4353:../freertos/tasks.c **** 	BaseType_t xReturn = pdPASS;
 5176              		.loc 1 4353 0
 5177 0010 0123     		mov	r3, #1
 5178 0012 FB61     		str	r3, [r7, #28]
4354:../freertos/tasks.c **** 	uint8_t ucOriginalNotifyState;
4355:../freertos/tasks.c **** 
4356:../freertos/tasks.c **** 		configASSERT( xTaskToNotify );
 5179              		.loc 1 4356 0
 5180 0014 FB68     		ldr	r3, [r7, #12]
 5181 0016 002B     		cmp	r3, #0
 5182 0018 01D1     		bne	.L412
 5183              		.loc 1 4356 0 is_stmt 0 discriminator 1
 5184              	@ 4356 "../freertos/tasks.c" 1
 5185 001a 72B6     		 cpsid i 
 5186              	@ 0 "" 2
 5187              		.code	16
 5188              	.L413:
 5189 001c FEE7     		b	.L413
 5190              	.L412:
4357:../freertos/tasks.c **** 		pxTCB = ( TCB_t * ) xTaskToNotify;
 5191              		.loc 1 4357 0 is_stmt 1
 5192 001e FB68     		ldr	r3, [r7, #12]
 5193 0020 BB61     		str	r3, [r7, #24]
4358:../freertos/tasks.c **** 
4359:../freertos/tasks.c **** 		taskENTER_CRITICAL();
 5194              		.loc 1 4359 0
 5195 0022 FFF7FEFF 		bl	vPortEnterCritical
4360:../freertos/tasks.c **** 		{
4361:../freertos/tasks.c **** 			if( pulPreviousNotificationValue != NULL )
 5196              		.loc 1 4361 0
 5197 0026 3B68     		ldr	r3, [r7]
 5198 0028 002B     		cmp	r3, #0
 5199 002a 03D0     		beq	.L414
4362:../freertos/tasks.c **** 			{
4363:../freertos/tasks.c **** 				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
 5200              		.loc 1 4363 0
 5201 002c BB69     		ldr	r3, [r7, #24]
 5202 002e DA6E     		ldr	r2, [r3, #108]
 5203 0030 3B68     		ldr	r3, [r7]
 5204 0032 1A60     		str	r2, [r3]
 5205              	.L414:
4364:../freertos/tasks.c **** 			}
4365:../freertos/tasks.c **** 
4366:../freertos/tasks.c **** 			ucOriginalNotifyState = pxTCB->ucNotifyState;
 5206              		.loc 1 4366 0
 5207 0034 3B1C     		mov	r3, r7
 5208 0036 1733     		add	r3, r3, #23
 5209 0038 B969     		ldr	r1, [r7, #24]
 5210 003a 7022     		mov	r2, #112
 5211 003c 8A5C     		ldrb	r2, [r1, r2]
 5212 003e 1A70     		strb	r2, [r3]
4367:../freertos/tasks.c **** 
4368:../freertos/tasks.c **** 			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 5213              		.loc 1 4368 0
 5214 0040 BA69     		ldr	r2, [r7, #24]
 5215 0042 7023     		mov	r3, #112
 5216 0044 0221     		mov	r1, #2
 5217 0046 D154     		strb	r1, [r2, r3]
4369:../freertos/tasks.c **** 
4370:../freertos/tasks.c **** 			switch( eAction )
 5218              		.loc 1 4370 0
 5219 0048 FB1D     		add	r3, r7, #7
 5220 004a 1B78     		ldrb	r3, [r3]
 5221 004c 042B     		cmp	r3, #4
 5222 004e 22D8     		bhi	.L415
 5223 0050 9A00     		lsl	r2, r3, #2
 5224 0052 2D4B     		ldr	r3, .L430
 5225 0054 D318     		add	r3, r2, r3
 5226 0056 1B68     		ldr	r3, [r3]
 5227 0058 9F46     		mov	pc, r3
 5228              		.section	.rodata.xTaskGenericNotify,"a",%progbits
 5229              		.align	2
 5230              	.L417:
 5231 0000 94000000 		.word	.L429
 5232 0004 5A000000 		.word	.L418
 5233 0008 68000000 		.word	.L419
 5234 000c 74000000 		.word	.L420
 5235 0010 7C000000 		.word	.L421
 5236              		.section	.text.xTaskGenericNotify
 5237              	.L418:
4371:../freertos/tasks.c **** 			{
4372:../freertos/tasks.c **** 				case eSetBits	:
4373:../freertos/tasks.c **** 					pxTCB->ulNotifiedValue |= ulValue;
 5238              		.loc 1 4373 0
 5239 005a BB69     		ldr	r3, [r7, #24]
 5240 005c DA6E     		ldr	r2, [r3, #108]
 5241 005e BB68     		ldr	r3, [r7, #8]
 5242 0060 1A43     		orr	r2, r3
 5243 0062 BB69     		ldr	r3, [r7, #24]
 5244 0064 DA66     		str	r2, [r3, #108]
4374:../freertos/tasks.c **** 					break;
 5245              		.loc 1 4374 0
 5246 0066 16E0     		b	.L415
 5247              	.L419:
4375:../freertos/tasks.c **** 
4376:../freertos/tasks.c **** 				case eIncrement	:
4377:../freertos/tasks.c **** 					( pxTCB->ulNotifiedValue )++;
 5248              		.loc 1 4377 0
 5249 0068 BB69     		ldr	r3, [r7, #24]
 5250 006a DB6E     		ldr	r3, [r3, #108]
 5251 006c 5A1C     		add	r2, r3, #1
 5252 006e BB69     		ldr	r3, [r7, #24]
 5253 0070 DA66     		str	r2, [r3, #108]
4378:../freertos/tasks.c **** 					break;
 5254              		.loc 1 4378 0
 5255 0072 10E0     		b	.L415
 5256              	.L420:
4379:../freertos/tasks.c **** 
4380:../freertos/tasks.c **** 				case eSetValueWithOverwrite	:
4381:../freertos/tasks.c **** 					pxTCB->ulNotifiedValue = ulValue;
 5257              		.loc 1 4381 0
 5258 0074 BB69     		ldr	r3, [r7, #24]
 5259 0076 BA68     		ldr	r2, [r7, #8]
 5260 0078 DA66     		str	r2, [r3, #108]
4382:../freertos/tasks.c **** 					break;
 5261              		.loc 1 4382 0
 5262 007a 0CE0     		b	.L415
 5263              	.L421:
4383:../freertos/tasks.c **** 
4384:../freertos/tasks.c **** 				case eSetValueWithoutOverwrite :
4385:../freertos/tasks.c **** 					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
 5264              		.loc 1 4385 0
 5265 007c 3B1C     		mov	r3, r7
 5266 007e 1733     		add	r3, r3, #23
 5267 0080 1B78     		ldrb	r3, [r3]
 5268 0082 022B     		cmp	r3, #2
 5269 0084 03D0     		beq	.L422
4386:../freertos/tasks.c **** 					{
4387:../freertos/tasks.c **** 						pxTCB->ulNotifiedValue = ulValue;
 5270              		.loc 1 4387 0
 5271 0086 BB69     		ldr	r3, [r7, #24]
 5272 0088 BA68     		ldr	r2, [r7, #8]
 5273 008a DA66     		str	r2, [r3, #108]
4388:../freertos/tasks.c **** 					}
4389:../freertos/tasks.c **** 					else
4390:../freertos/tasks.c **** 					{
4391:../freertos/tasks.c **** 						/* The value could not be written to the task. */
4392:../freertos/tasks.c **** 						xReturn = pdFAIL;
4393:../freertos/tasks.c **** 					}
4394:../freertos/tasks.c **** 					break;
 5274              		.loc 1 4394 0
 5275 008c 03E0     		b	.L415
 5276              	.L422:
4392:../freertos/tasks.c **** 						xReturn = pdFAIL;
 5277              		.loc 1 4392 0
 5278 008e 0023     		mov	r3, #0
 5279 0090 FB61     		str	r3, [r7, #28]
 5280              		.loc 1 4394 0
 5281 0092 00E0     		b	.L415
 5282              	.L429:
4395:../freertos/tasks.c **** 
4396:../freertos/tasks.c **** 				case eNoAction:
4397:../freertos/tasks.c **** 					/* The task is being notified without its notify value being
4398:../freertos/tasks.c **** 					updated. */
4399:../freertos/tasks.c **** 					break;
 5283              		.loc 1 4399 0
 5284 0094 C046     		mov	r8, r8
 5285              	.L415:
4400:../freertos/tasks.c **** 			}
4401:../freertos/tasks.c **** 
4402:../freertos/tasks.c **** 			traceTASK_NOTIFY();
4403:../freertos/tasks.c **** 
4404:../freertos/tasks.c **** 			/* If the task is in the blocked state specifically to wait for a
4405:../freertos/tasks.c **** 			notification then unblock it now. */
4406:../freertos/tasks.c **** 			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 5286              		.loc 1 4406 0
 5287 0096 3B1C     		mov	r3, r7
 5288 0098 1733     		add	r3, r3, #23
 5289 009a 1B78     		ldrb	r3, [r3]
 5290 009c 012B     		cmp	r3, #1
 5291 009e 2BD1     		bne	.L424
4407:../freertos/tasks.c **** 			{
4408:../freertos/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 5292              		.loc 1 4408 0
 5293 00a0 BB69     		ldr	r3, [r7, #24]
 5294 00a2 0433     		add	r3, r3, #4
 5295 00a4 181C     		mov	r0, r3
 5296 00a6 FFF7FEFF 		bl	uxListRemove
4409:../freertos/tasks.c **** 				prvAddTaskToReadyList( pxTCB );
 5297              		.loc 1 4409 0
 5298 00aa BB69     		ldr	r3, [r7, #24]
 5299 00ac DA6A     		ldr	r2, [r3, #44]
 5300 00ae 174B     		ldr	r3, .L430+4
 5301 00b0 1B68     		ldr	r3, [r3]
 5302 00b2 9A42     		cmp	r2, r3
 5303 00b4 03D9     		bls	.L425
 5304              		.loc 1 4409 0 is_stmt 0 discriminator 1
 5305 00b6 BB69     		ldr	r3, [r7, #24]
 5306 00b8 DA6A     		ldr	r2, [r3, #44]
 5307 00ba 144B     		ldr	r3, .L430+4
 5308 00bc 1A60     		str	r2, [r3]
 5309              	.L425:
 5310              		.loc 1 4409 0 discriminator 2
 5311 00be BB69     		ldr	r3, [r7, #24]
 5312 00c0 DA6A     		ldr	r2, [r3, #44]
 5313 00c2 131C     		mov	r3, r2
 5314 00c4 9B00     		lsl	r3, r3, #2
 5315 00c6 9B18     		add	r3, r3, r2
 5316 00c8 9B00     		lsl	r3, r3, #2
 5317 00ca 114A     		ldr	r2, .L430+8
 5318 00cc 9A18     		add	r2, r3, r2
 5319 00ce BB69     		ldr	r3, [r7, #24]
 5320 00d0 0433     		add	r3, r3, #4
 5321 00d2 101C     		mov	r0, r2
 5322 00d4 191C     		mov	r1, r3
 5323 00d6 FFF7FEFF 		bl	vListInsertEnd
4410:../freertos/tasks.c **** 
4411:../freertos/tasks.c **** 				/* The task should not have been on an event list. */
4412:../freertos/tasks.c **** 				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
 5324              		.loc 1 4412 0 is_stmt 1 discriminator 2
 5325 00da BB69     		ldr	r3, [r7, #24]
 5326 00dc 9B6A     		ldr	r3, [r3, #40]
 5327 00de 002B     		cmp	r3, #0
 5328 00e0 01D0     		beq	.L426
 5329              		.loc 1 4412 0 is_stmt 0 discriminator 1
 5330              	@ 4412 "../freertos/tasks.c" 1
 5331 00e2 72B6     		 cpsid i 
 5332              	@ 0 "" 2
 5333              		.code	16
 5334              	.L427:
 5335 00e4 FEE7     		b	.L427
 5336              	.L426:
4413:../freertos/tasks.c **** 
4414:../freertos/tasks.c **** 				#if( configUSE_TICKLESS_IDLE != 0 )
4415:../freertos/tasks.c **** 				{
4416:../freertos/tasks.c **** 					/* If a task is blocked waiting for a notification then
4417:../freertos/tasks.c **** 					xNextTaskUnblockTime might be set to the blocked task's time
4418:../freertos/tasks.c **** 					out time.  If the task is unblocked for a reason other than
4419:../freertos/tasks.c **** 					a timeout xNextTaskUnblockTime is normally left unchanged,
4420:../freertos/tasks.c **** 					because it will automatically get reset to a new value when
4421:../freertos/tasks.c **** 					the tick count equals xNextTaskUnblockTime.  However if
4422:../freertos/tasks.c **** 					tickless idling is used it might be more important to enter
4423:../freertos/tasks.c **** 					sleep mode at the earliest possible time - so reset
4424:../freertos/tasks.c **** 					xNextTaskUnblockTime here to ensure it is updated at the
4425:../freertos/tasks.c **** 					earliest possible time. */
4426:../freertos/tasks.c **** 					prvResetNextTaskUnblockTime();
4427:../freertos/tasks.c **** 				}
4428:../freertos/tasks.c **** 				#endif
4429:../freertos/tasks.c **** 
4430:../freertos/tasks.c **** 				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 5337              		.loc 1 4430 0 is_stmt 1
 5338 00e6 BB69     		ldr	r3, [r7, #24]
 5339 00e8 DA6A     		ldr	r2, [r3, #44]
 5340 00ea 0A4B     		ldr	r3, .L430+12
 5341 00ec 1B68     		ldr	r3, [r3]
 5342 00ee DB6A     		ldr	r3, [r3, #44]
 5343 00f0 9A42     		cmp	r2, r3
 5344 00f2 01D9     		bls	.L424
4431:../freertos/tasks.c **** 				{
4432:../freertos/tasks.c **** 					/* The notified task has a priority above the currently
4433:../freertos/tasks.c **** 					executing task so a yield is required. */
4434:../freertos/tasks.c **** 					taskYIELD_IF_USING_PREEMPTION();
 5345              		.loc 1 4434 0
 5346 00f4 FFF7FEFF 		bl	vPortYield
 5347              	.L424:
4435:../freertos/tasks.c **** 				}
4436:../freertos/tasks.c **** 				else
4437:../freertos/tasks.c **** 				{
4438:../freertos/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4439:../freertos/tasks.c **** 				}
4440:../freertos/tasks.c **** 			}
4441:../freertos/tasks.c **** 			else
4442:../freertos/tasks.c **** 			{
4443:../freertos/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4444:../freertos/tasks.c **** 			}
4445:../freertos/tasks.c **** 		}
4446:../freertos/tasks.c **** 		taskEXIT_CRITICAL();
 5348              		.loc 1 4446 0
 5349 00f8 FFF7FEFF 		bl	vPortExitCritical
4447:../freertos/tasks.c **** 
4448:../freertos/tasks.c **** 		return xReturn;
 5350              		.loc 1 4448 0
 5351 00fc FB69     		ldr	r3, [r7, #28]
4449:../freertos/tasks.c **** 	}
 5352              		.loc 1 4449 0
 5353 00fe 181C     		mov	r0, r3
 5354 0100 BD46     		mov	sp, r7
 5355 0102 08B0     		add	sp, sp, #32
 5356              		@ sp needed
 5357 0104 80BD     		pop	{r7, pc}
 5358              	.L431:
 5359 0106 C046     		.align	2
 5360              	.L430:
 5361 0108 00000000 		.word	.L417
 5362 010c 00000000 		.word	uxTopReadyPriority
 5363 0110 00000000 		.word	pxReadyTasksLists
 5364 0114 00000000 		.word	pxCurrentTCB
 5365              		.cfi_endproc
 5366              	.LFE53:
 5368              		.section	.text.xTaskGenericNotifyFromISR,"ax",%progbits
 5369              		.align	2
 5370              		.global	xTaskGenericNotifyFromISR
 5371              		.code	16
 5372              		.thumb_func
 5374              	xTaskGenericNotifyFromISR:
 5375              	.LFB54:
4450:../freertos/tasks.c **** 
4451:../freertos/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4452:../freertos/tasks.c **** /*-----------------------------------------------------------*/
4453:../freertos/tasks.c **** 
4454:../freertos/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4455:../freertos/tasks.c **** 
4456:../freertos/tasks.c **** 	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction 
4457:../freertos/tasks.c **** 	{
 5376              		.loc 1 4457 0
 5377              		.cfi_startproc
 5378 0000 80B5     		push	{r7, lr}
 5379              		.cfi_def_cfa_offset 8
 5380              		.cfi_offset 7, -8
 5381              		.cfi_offset 14, -4
 5382 0002 88B0     		sub	sp, sp, #32
 5383              		.cfi_def_cfa_offset 40
 5384 0004 00AF     		add	r7, sp, #0
 5385              		.cfi_def_cfa_register 7
 5386 0006 F860     		str	r0, [r7, #12]
 5387 0008 B960     		str	r1, [r7, #8]
 5388 000a 3B60     		str	r3, [r7]
 5389 000c FB1D     		add	r3, r7, #7
 5390 000e 1A70     		strb	r2, [r3]
4458:../freertos/tasks.c **** 	TCB_t * pxTCB;
4459:../freertos/tasks.c **** 	uint8_t ucOriginalNotifyState;
4460:../freertos/tasks.c **** 	BaseType_t xReturn = pdPASS;
 5391              		.loc 1 4460 0
 5392 0010 0123     		mov	r3, #1
 5393 0012 FB61     		str	r3, [r7, #28]
4461:../freertos/tasks.c **** 	UBaseType_t uxSavedInterruptStatus;
4462:../freertos/tasks.c **** 
4463:../freertos/tasks.c **** 		configASSERT( xTaskToNotify );
 5394              		.loc 1 4463 0
 5395 0014 FB68     		ldr	r3, [r7, #12]
 5396 0016 002B     		cmp	r3, #0
 5397 0018 01D1     		bne	.L433
 5398              		.loc 1 4463 0 is_stmt 0 discriminator 1
 5399              	@ 4463 "../freertos/tasks.c" 1
 5400 001a 72B6     		 cpsid i 
 5401              	@ 0 "" 2
 5402              		.code	16
 5403              	.L434:
 5404 001c FEE7     		b	.L434
 5405              	.L433:
4464:../freertos/tasks.c **** 
4465:../freertos/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
4466:../freertos/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
4467:../freertos/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
4468:../freertos/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
4469:../freertos/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
4470:../freertos/tasks.c **** 		is defined in FreeRTOSConfig.h then
4471:../freertos/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
4472:../freertos/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
4473:../freertos/tasks.c **** 		been assigned a priority above the configured maximum system call
4474:../freertos/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
4475:../freertos/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
4476:../freertos/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
4477:../freertos/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
4478:../freertos/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
4479:../freertos/tasks.c **** 		provided on the following link:
4480:../freertos/tasks.c **** 		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
4481:../freertos/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
4482:../freertos/tasks.c **** 
4483:../freertos/tasks.c **** 		pxTCB = ( TCB_t * ) xTaskToNotify;
 5406              		.loc 1 4483 0 is_stmt 1
 5407 001e FB68     		ldr	r3, [r7, #12]
 5408 0020 BB61     		str	r3, [r7, #24]
4484:../freertos/tasks.c **** 
4485:../freertos/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 5409              		.loc 1 4485 0
 5410 0022 FFF7FEFF 		bl	ulSetInterruptMaskFromISR
 5411 0026 031C     		mov	r3, r0
 5412 0028 7B61     		str	r3, [r7, #20]
4486:../freertos/tasks.c **** 		{
4487:../freertos/tasks.c **** 			if( pulPreviousNotificationValue != NULL )
 5413              		.loc 1 4487 0
 5414 002a 3B68     		ldr	r3, [r7]
 5415 002c 002B     		cmp	r3, #0
 5416 002e 03D0     		beq	.L435
4488:../freertos/tasks.c **** 			{
4489:../freertos/tasks.c **** 				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
 5417              		.loc 1 4489 0
 5418 0030 BB69     		ldr	r3, [r7, #24]
 5419 0032 DA6E     		ldr	r2, [r3, #108]
 5420 0034 3B68     		ldr	r3, [r7]
 5421 0036 1A60     		str	r2, [r3]
 5422              	.L435:
4490:../freertos/tasks.c **** 			}
4491:../freertos/tasks.c **** 
4492:../freertos/tasks.c **** 			ucOriginalNotifyState = pxTCB->ucNotifyState;
 5423              		.loc 1 4492 0
 5424 0038 3B1C     		mov	r3, r7
 5425 003a 1333     		add	r3, r3, #19
 5426 003c B969     		ldr	r1, [r7, #24]
 5427 003e 7022     		mov	r2, #112
 5428 0040 8A5C     		ldrb	r2, [r1, r2]
 5429 0042 1A70     		strb	r2, [r3]
4493:../freertos/tasks.c **** 			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 5430              		.loc 1 4493 0
 5431 0044 BA69     		ldr	r2, [r7, #24]
 5432 0046 7023     		mov	r3, #112
 5433 0048 0221     		mov	r1, #2
 5434 004a D154     		strb	r1, [r2, r3]
4494:../freertos/tasks.c **** 
4495:../freertos/tasks.c **** 			switch( eAction )
 5435              		.loc 1 4495 0
 5436 004c FB1D     		add	r3, r7, #7
 5437 004e 1B78     		ldrb	r3, [r3]
 5438 0050 042B     		cmp	r3, #4
 5439 0052 22D8     		bhi	.L436
 5440 0054 9A00     		lsl	r2, r3, #2
 5441 0056 384B     		ldr	r3, .L455
 5442 0058 D318     		add	r3, r2, r3
 5443 005a 1B68     		ldr	r3, [r3]
 5444 005c 9F46     		mov	pc, r3
 5445              		.section	.rodata.xTaskGenericNotifyFromISR,"a",%progbits
 5446              		.align	2
 5447              	.L438:
 5448 0000 98000000 		.word	.L454
 5449 0004 5E000000 		.word	.L439
 5450 0008 6C000000 		.word	.L440
 5451 000c 78000000 		.word	.L441
 5452 0010 80000000 		.word	.L442
 5453              		.section	.text.xTaskGenericNotifyFromISR
 5454              	.L439:
4496:../freertos/tasks.c **** 			{
4497:../freertos/tasks.c **** 				case eSetBits	:
4498:../freertos/tasks.c **** 					pxTCB->ulNotifiedValue |= ulValue;
 5455              		.loc 1 4498 0
 5456 005e BB69     		ldr	r3, [r7, #24]
 5457 0060 DA6E     		ldr	r2, [r3, #108]
 5458 0062 BB68     		ldr	r3, [r7, #8]
 5459 0064 1A43     		orr	r2, r3
 5460 0066 BB69     		ldr	r3, [r7, #24]
 5461 0068 DA66     		str	r2, [r3, #108]
4499:../freertos/tasks.c **** 					break;
 5462              		.loc 1 4499 0
 5463 006a 16E0     		b	.L436
 5464              	.L440:
4500:../freertos/tasks.c **** 
4501:../freertos/tasks.c **** 				case eIncrement	:
4502:../freertos/tasks.c **** 					( pxTCB->ulNotifiedValue )++;
 5465              		.loc 1 4502 0
 5466 006c BB69     		ldr	r3, [r7, #24]
 5467 006e DB6E     		ldr	r3, [r3, #108]
 5468 0070 5A1C     		add	r2, r3, #1
 5469 0072 BB69     		ldr	r3, [r7, #24]
 5470 0074 DA66     		str	r2, [r3, #108]
4503:../freertos/tasks.c **** 					break;
 5471              		.loc 1 4503 0
 5472 0076 10E0     		b	.L436
 5473              	.L441:
4504:../freertos/tasks.c **** 
4505:../freertos/tasks.c **** 				case eSetValueWithOverwrite	:
4506:../freertos/tasks.c **** 					pxTCB->ulNotifiedValue = ulValue;
 5474              		.loc 1 4506 0
 5475 0078 BB69     		ldr	r3, [r7, #24]
 5476 007a BA68     		ldr	r2, [r7, #8]
 5477 007c DA66     		str	r2, [r3, #108]
4507:../freertos/tasks.c **** 					break;
 5478              		.loc 1 4507 0
 5479 007e 0CE0     		b	.L436
 5480              	.L442:
4508:../freertos/tasks.c **** 
4509:../freertos/tasks.c **** 				case eSetValueWithoutOverwrite :
4510:../freertos/tasks.c **** 					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
 5481              		.loc 1 4510 0
 5482 0080 3B1C     		mov	r3, r7
 5483 0082 1333     		add	r3, r3, #19
 5484 0084 1B78     		ldrb	r3, [r3]
 5485 0086 022B     		cmp	r3, #2
 5486 0088 03D0     		beq	.L443
4511:../freertos/tasks.c **** 					{
4512:../freertos/tasks.c **** 						pxTCB->ulNotifiedValue = ulValue;
 5487              		.loc 1 4512 0
 5488 008a BB69     		ldr	r3, [r7, #24]
 5489 008c BA68     		ldr	r2, [r7, #8]
 5490 008e DA66     		str	r2, [r3, #108]
4513:../freertos/tasks.c **** 					}
4514:../freertos/tasks.c **** 					else
4515:../freertos/tasks.c **** 					{
4516:../freertos/tasks.c **** 						/* The value could not be written to the task. */
4517:../freertos/tasks.c **** 						xReturn = pdFAIL;
4518:../freertos/tasks.c **** 					}
4519:../freertos/tasks.c **** 					break;
 5491              		.loc 1 4519 0
 5492 0090 03E0     		b	.L436
 5493              	.L443:
4517:../freertos/tasks.c **** 						xReturn = pdFAIL;
 5494              		.loc 1 4517 0
 5495 0092 0023     		mov	r3, #0
 5496 0094 FB61     		str	r3, [r7, #28]
 5497              		.loc 1 4519 0
 5498 0096 00E0     		b	.L436
 5499              	.L454:
4520:../freertos/tasks.c **** 
4521:../freertos/tasks.c **** 				case eNoAction :
4522:../freertos/tasks.c **** 					/* The task is being notified without its notify value being
4523:../freertos/tasks.c **** 					updated. */
4524:../freertos/tasks.c **** 					break;
 5500              		.loc 1 4524 0
 5501 0098 C046     		mov	r8, r8
 5502              	.L436:
4525:../freertos/tasks.c **** 			}
4526:../freertos/tasks.c **** 
4527:../freertos/tasks.c **** 			traceTASK_NOTIFY_FROM_ISR();
4528:../freertos/tasks.c **** 
4529:../freertos/tasks.c **** 			/* If the task is in the blocked state specifically to wait for a
4530:../freertos/tasks.c **** 			notification then unblock it now. */
4531:../freertos/tasks.c **** 			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 5503              		.loc 1 4531 0
 5504 009a 3B1C     		mov	r3, r7
 5505 009c 1333     		add	r3, r3, #19
 5506 009e 1B78     		ldrb	r3, [r3]
 5507 00a0 012B     		cmp	r3, #1
 5508 00a2 3FD1     		bne	.L445
4532:../freertos/tasks.c **** 			{
4533:../freertos/tasks.c **** 				/* The task should not have been on an event list. */
4534:../freertos/tasks.c **** 				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
 5509              		.loc 1 4534 0
 5510 00a4 BB69     		ldr	r3, [r7, #24]
 5511 00a6 9B6A     		ldr	r3, [r3, #40]
 5512 00a8 002B     		cmp	r3, #0
 5513 00aa 01D0     		beq	.L446
 5514              		.loc 1 4534 0 is_stmt 0 discriminator 1
 5515              	@ 4534 "../freertos/tasks.c" 1
 5516 00ac 72B6     		 cpsid i 
 5517              	@ 0 "" 2
 5518              		.code	16
 5519              	.L447:
 5520 00ae FEE7     		b	.L447
 5521              	.L446:
4535:../freertos/tasks.c **** 
4536:../freertos/tasks.c **** 				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 5522              		.loc 1 4536 0 is_stmt 1
 5523 00b0 224B     		ldr	r3, .L455+4
 5524 00b2 1B68     		ldr	r3, [r3]
 5525 00b4 002B     		cmp	r3, #0
 5526 00b6 1DD1     		bne	.L448
4537:../freertos/tasks.c **** 				{
4538:../freertos/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 5527              		.loc 1 4538 0
 5528 00b8 BB69     		ldr	r3, [r7, #24]
 5529 00ba 0433     		add	r3, r3, #4
 5530 00bc 181C     		mov	r0, r3
 5531 00be FFF7FEFF 		bl	uxListRemove
4539:../freertos/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 5532              		.loc 1 4539 0
 5533 00c2 BB69     		ldr	r3, [r7, #24]
 5534 00c4 DA6A     		ldr	r2, [r3, #44]
 5535 00c6 1E4B     		ldr	r3, .L455+8
 5536 00c8 1B68     		ldr	r3, [r3]
 5537 00ca 9A42     		cmp	r2, r3
 5538 00cc 03D9     		bls	.L449
 5539              		.loc 1 4539 0 is_stmt 0 discriminator 1
 5540 00ce BB69     		ldr	r3, [r7, #24]
 5541 00d0 DA6A     		ldr	r2, [r3, #44]
 5542 00d2 1B4B     		ldr	r3, .L455+8
 5543 00d4 1A60     		str	r2, [r3]
 5544              	.L449:
 5545              		.loc 1 4539 0 discriminator 2
 5546 00d6 BB69     		ldr	r3, [r7, #24]
 5547 00d8 DA6A     		ldr	r2, [r3, #44]
 5548 00da 131C     		mov	r3, r2
 5549 00dc 9B00     		lsl	r3, r3, #2
 5550 00de 9B18     		add	r3, r3, r2
 5551 00e0 9B00     		lsl	r3, r3, #2
 5552 00e2 184A     		ldr	r2, .L455+12
 5553 00e4 9A18     		add	r2, r3, r2
 5554 00e6 BB69     		ldr	r3, [r7, #24]
 5555 00e8 0433     		add	r3, r3, #4
 5556 00ea 101C     		mov	r0, r2
 5557 00ec 191C     		mov	r1, r3
 5558 00ee FFF7FEFF 		bl	vListInsertEnd
 5559 00f2 06E0     		b	.L450
 5560              	.L448:
4540:../freertos/tasks.c **** 				}
4541:../freertos/tasks.c **** 				else
4542:../freertos/tasks.c **** 				{
4543:../freertos/tasks.c **** 					/* The delayed and ready lists cannot be accessed, so hold
4544:../freertos/tasks.c **** 					this task pending until the scheduler is resumed. */
4545:../freertos/tasks.c **** 					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 5561              		.loc 1 4545 0 is_stmt 1
 5562 00f4 BB69     		ldr	r3, [r7, #24]
 5563 00f6 1833     		add	r3, r3, #24
 5564 00f8 134A     		ldr	r2, .L455+16
 5565 00fa 101C     		mov	r0, r2
 5566 00fc 191C     		mov	r1, r3
 5567 00fe FFF7FEFF 		bl	vListInsertEnd
 5568              	.L450:
4546:../freertos/tasks.c **** 				}
4547:../freertos/tasks.c **** 
4548:../freertos/tasks.c **** 				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 5569              		.loc 1 4548 0
 5570 0102 BB69     		ldr	r3, [r7, #24]
 5571 0104 DA6A     		ldr	r2, [r3, #44]
 5572 0106 114B     		ldr	r3, .L455+20
 5573 0108 1B68     		ldr	r3, [r3]
 5574 010a DB6A     		ldr	r3, [r3, #44]
 5575 010c 9A42     		cmp	r2, r3
 5576 010e 09D9     		bls	.L445
4549:../freertos/tasks.c **** 				{
4550:../freertos/tasks.c **** 					/* The notified task has a priority above the currently
4551:../freertos/tasks.c **** 					executing task so a yield is required. */
4552:../freertos/tasks.c **** 					if( pxHigherPriorityTaskWoken != NULL )
 5577              		.loc 1 4552 0
 5578 0110 BB6A     		ldr	r3, [r7, #40]
 5579 0112 002B     		cmp	r3, #0
 5580 0114 03D0     		beq	.L451
4553:../freertos/tasks.c **** 					{
4554:../freertos/tasks.c **** 						*pxHigherPriorityTaskWoken = pdTRUE;
 5581              		.loc 1 4554 0
 5582 0116 BB6A     		ldr	r3, [r7, #40]
 5583 0118 0122     		mov	r2, #1
 5584 011a 1A60     		str	r2, [r3]
 5585 011c 02E0     		b	.L445
 5586              	.L451:
4555:../freertos/tasks.c **** 					}
4556:../freertos/tasks.c **** 					else
4557:../freertos/tasks.c **** 					{
4558:../freertos/tasks.c **** 						/* Mark that a yield is pending in case the user is not
4559:../freertos/tasks.c **** 						using the "xHigherPriorityTaskWoken" parameter to an ISR
4560:../freertos/tasks.c **** 						safe FreeRTOS function. */
4561:../freertos/tasks.c **** 						xYieldPending = pdTRUE;
 5587              		.loc 1 4561 0
 5588 011e 0C4B     		ldr	r3, .L455+24
 5589 0120 0122     		mov	r2, #1
 5590 0122 1A60     		str	r2, [r3]
 5591              	.L445:
4562:../freertos/tasks.c **** 					}
4563:../freertos/tasks.c **** 				}
4564:../freertos/tasks.c **** 				else
4565:../freertos/tasks.c **** 				{
4566:../freertos/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4567:../freertos/tasks.c **** 				}
4568:../freertos/tasks.c **** 			}
4569:../freertos/tasks.c **** 		}
4570:../freertos/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 5592              		.loc 1 4570 0
 5593 0124 7B69     		ldr	r3, [r7, #20]
 5594 0126 181C     		mov	r0, r3
 5595 0128 FFF7FEFF 		bl	vClearInterruptMaskFromISR
4571:../freertos/tasks.c **** 
4572:../freertos/tasks.c **** 		return xReturn;
 5596              		.loc 1 4572 0
 5597 012c FB69     		ldr	r3, [r7, #28]
4573:../freertos/tasks.c **** 	}
 5598              		.loc 1 4573 0
 5599 012e 181C     		mov	r0, r3
 5600 0130 BD46     		mov	sp, r7
 5601 0132 08B0     		add	sp, sp, #32
 5602              		@ sp needed
 5603 0134 80BD     		pop	{r7, pc}
 5604              	.L456:
 5605 0136 C046     		.align	2
 5606              	.L455:
 5607 0138 00000000 		.word	.L438
 5608 013c 00000000 		.word	uxSchedulerSuspended
 5609 0140 00000000 		.word	uxTopReadyPriority
 5610 0144 00000000 		.word	pxReadyTasksLists
 5611 0148 00000000 		.word	xPendingReadyList
 5612 014c 00000000 		.word	pxCurrentTCB
 5613 0150 00000000 		.word	xYieldPending
 5614              		.cfi_endproc
 5615              	.LFE54:
 5617              		.section	.text.vTaskNotifyGiveFromISR,"ax",%progbits
 5618              		.align	2
 5619              		.global	vTaskNotifyGiveFromISR
 5620              		.code	16
 5621              		.thumb_func
 5623              	vTaskNotifyGiveFromISR:
 5624              	.LFB55:
4574:../freertos/tasks.c **** 
4575:../freertos/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4576:../freertos/tasks.c **** /*-----------------------------------------------------------*/
4577:../freertos/tasks.c **** 
4578:../freertos/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4579:../freertos/tasks.c **** 
4580:../freertos/tasks.c **** 	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
4581:../freertos/tasks.c **** 	{
 5625              		.loc 1 4581 0
 5626              		.cfi_startproc
 5627 0000 80B5     		push	{r7, lr}
 5628              		.cfi_def_cfa_offset 8
 5629              		.cfi_offset 7, -8
 5630              		.cfi_offset 14, -4
 5631 0002 86B0     		sub	sp, sp, #24
 5632              		.cfi_def_cfa_offset 32
 5633 0004 00AF     		add	r7, sp, #0
 5634              		.cfi_def_cfa_register 7
 5635 0006 7860     		str	r0, [r7, #4]
 5636 0008 3960     		str	r1, [r7]
4582:../freertos/tasks.c **** 	TCB_t * pxTCB;
4583:../freertos/tasks.c **** 	uint8_t ucOriginalNotifyState;
4584:../freertos/tasks.c **** 	UBaseType_t uxSavedInterruptStatus;
4585:../freertos/tasks.c **** 
4586:../freertos/tasks.c **** 		configASSERT( xTaskToNotify );
 5637              		.loc 1 4586 0
 5638 000a 7B68     		ldr	r3, [r7, #4]
 5639 000c 002B     		cmp	r3, #0
 5640 000e 01D1     		bne	.L458
 5641              		.loc 1 4586 0 is_stmt 0 discriminator 1
 5642              	@ 4586 "../freertos/tasks.c" 1
 5643 0010 72B6     		 cpsid i 
 5644              	@ 0 "" 2
 5645              		.code	16
 5646              	.L459:
 5647 0012 FEE7     		b	.L459
 5648              	.L458:
4587:../freertos/tasks.c **** 
4588:../freertos/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
4589:../freertos/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
4590:../freertos/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
4591:../freertos/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
4592:../freertos/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
4593:../freertos/tasks.c **** 		is defined in FreeRTOSConfig.h then
4594:../freertos/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
4595:../freertos/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
4596:../freertos/tasks.c **** 		been assigned a priority above the configured maximum system call
4597:../freertos/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
4598:../freertos/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
4599:../freertos/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
4600:../freertos/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
4601:../freertos/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
4602:../freertos/tasks.c **** 		provided on the following link:
4603:../freertos/tasks.c **** 		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
4604:../freertos/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
4605:../freertos/tasks.c **** 
4606:../freertos/tasks.c **** 		pxTCB = ( TCB_t * ) xTaskToNotify;
 5649              		.loc 1 4606 0 is_stmt 1
 5650 0014 7B68     		ldr	r3, [r7, #4]
 5651 0016 7B61     		str	r3, [r7, #20]
4607:../freertos/tasks.c **** 
4608:../freertos/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 5652              		.loc 1 4608 0
 5653 0018 FFF7FEFF 		bl	ulSetInterruptMaskFromISR
 5654 001c 031C     		mov	r3, r0
 5655 001e 3B61     		str	r3, [r7, #16]
4609:../freertos/tasks.c **** 		{
4610:../freertos/tasks.c **** 			ucOriginalNotifyState = pxTCB->ucNotifyState;
 5656              		.loc 1 4610 0
 5657 0020 3B1C     		mov	r3, r7
 5658 0022 0F33     		add	r3, r3, #15
 5659 0024 7969     		ldr	r1, [r7, #20]
 5660 0026 7022     		mov	r2, #112
 5661 0028 8A5C     		ldrb	r2, [r1, r2]
 5662 002a 1A70     		strb	r2, [r3]
4611:../freertos/tasks.c **** 			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 5663              		.loc 1 4611 0
 5664 002c 7A69     		ldr	r2, [r7, #20]
 5665 002e 7023     		mov	r3, #112
 5666 0030 0221     		mov	r1, #2
 5667 0032 D154     		strb	r1, [r2, r3]
4612:../freertos/tasks.c **** 
4613:../freertos/tasks.c **** 			/* 'Giving' is equivalent to incrementing a count in a counting
4614:../freertos/tasks.c **** 			semaphore. */
4615:../freertos/tasks.c **** 			( pxTCB->ulNotifiedValue )++;
 5668              		.loc 1 4615 0
 5669 0034 7B69     		ldr	r3, [r7, #20]
 5670 0036 DB6E     		ldr	r3, [r3, #108]
 5671 0038 5A1C     		add	r2, r3, #1
 5672 003a 7B69     		ldr	r3, [r7, #20]
 5673 003c DA66     		str	r2, [r3, #108]
4616:../freertos/tasks.c **** 
4617:../freertos/tasks.c **** 			traceTASK_NOTIFY_GIVE_FROM_ISR();
4618:../freertos/tasks.c **** 
4619:../freertos/tasks.c **** 			/* If the task is in the blocked state specifically to wait for a
4620:../freertos/tasks.c **** 			notification then unblock it now. */
4621:../freertos/tasks.c **** 			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 5674              		.loc 1 4621 0
 5675 003e 3B1C     		mov	r3, r7
 5676 0040 0F33     		add	r3, r3, #15
 5677 0042 1B78     		ldrb	r3, [r3]
 5678 0044 012B     		cmp	r3, #1
 5679 0046 3FD1     		bne	.L460
4622:../freertos/tasks.c **** 			{
4623:../freertos/tasks.c **** 				/* The task should not have been on an event list. */
4624:../freertos/tasks.c **** 				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
 5680              		.loc 1 4624 0
 5681 0048 7B69     		ldr	r3, [r7, #20]
 5682 004a 9B6A     		ldr	r3, [r3, #40]
 5683 004c 002B     		cmp	r3, #0
 5684 004e 01D0     		beq	.L461
 5685              		.loc 1 4624 0 is_stmt 0 discriminator 1
 5686              	@ 4624 "../freertos/tasks.c" 1
 5687 0050 72B6     		 cpsid i 
 5688              	@ 0 "" 2
 5689              		.code	16
 5690              	.L462:
 5691 0052 FEE7     		b	.L462
 5692              	.L461:
4625:../freertos/tasks.c **** 
4626:../freertos/tasks.c **** 				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 5693              		.loc 1 4626 0 is_stmt 1
 5694 0054 204B     		ldr	r3, .L468
 5695 0056 1B68     		ldr	r3, [r3]
 5696 0058 002B     		cmp	r3, #0
 5697 005a 1DD1     		bne	.L463
4627:../freertos/tasks.c **** 				{
4628:../freertos/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 5698              		.loc 1 4628 0
 5699 005c 7B69     		ldr	r3, [r7, #20]
 5700 005e 0433     		add	r3, r3, #4
 5701 0060 181C     		mov	r0, r3
 5702 0062 FFF7FEFF 		bl	uxListRemove
4629:../freertos/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 5703              		.loc 1 4629 0
 5704 0066 7B69     		ldr	r3, [r7, #20]
 5705 0068 DA6A     		ldr	r2, [r3, #44]
 5706 006a 1C4B     		ldr	r3, .L468+4
 5707 006c 1B68     		ldr	r3, [r3]
 5708 006e 9A42     		cmp	r2, r3
 5709 0070 03D9     		bls	.L464
 5710              		.loc 1 4629 0 is_stmt 0 discriminator 1
 5711 0072 7B69     		ldr	r3, [r7, #20]
 5712 0074 DA6A     		ldr	r2, [r3, #44]
 5713 0076 194B     		ldr	r3, .L468+4
 5714 0078 1A60     		str	r2, [r3]
 5715              	.L464:
 5716              		.loc 1 4629 0 discriminator 2
 5717 007a 7B69     		ldr	r3, [r7, #20]
 5718 007c DA6A     		ldr	r2, [r3, #44]
 5719 007e 131C     		mov	r3, r2
 5720 0080 9B00     		lsl	r3, r3, #2
 5721 0082 9B18     		add	r3, r3, r2
 5722 0084 9B00     		lsl	r3, r3, #2
 5723 0086 164A     		ldr	r2, .L468+8
 5724 0088 9A18     		add	r2, r3, r2
 5725 008a 7B69     		ldr	r3, [r7, #20]
 5726 008c 0433     		add	r3, r3, #4
 5727 008e 101C     		mov	r0, r2
 5728 0090 191C     		mov	r1, r3
 5729 0092 FFF7FEFF 		bl	vListInsertEnd
 5730 0096 06E0     		b	.L465
 5731              	.L463:
4630:../freertos/tasks.c **** 				}
4631:../freertos/tasks.c **** 				else
4632:../freertos/tasks.c **** 				{
4633:../freertos/tasks.c **** 					/* The delayed and ready lists cannot be accessed, so hold
4634:../freertos/tasks.c **** 					this task pending until the scheduler is resumed. */
4635:../freertos/tasks.c **** 					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 5732              		.loc 1 4635 0 is_stmt 1
 5733 0098 7B69     		ldr	r3, [r7, #20]
 5734 009a 1833     		add	r3, r3, #24
 5735 009c 114A     		ldr	r2, .L468+12
 5736 009e 101C     		mov	r0, r2
 5737 00a0 191C     		mov	r1, r3
 5738 00a2 FFF7FEFF 		bl	vListInsertEnd
 5739              	.L465:
4636:../freertos/tasks.c **** 				}
4637:../freertos/tasks.c **** 
4638:../freertos/tasks.c **** 				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 5740              		.loc 1 4638 0
 5741 00a6 7B69     		ldr	r3, [r7, #20]
 5742 00a8 DA6A     		ldr	r2, [r3, #44]
 5743 00aa 0F4B     		ldr	r3, .L468+16
 5744 00ac 1B68     		ldr	r3, [r3]
 5745 00ae DB6A     		ldr	r3, [r3, #44]
 5746 00b0 9A42     		cmp	r2, r3
 5747 00b2 09D9     		bls	.L460
4639:../freertos/tasks.c **** 				{
4640:../freertos/tasks.c **** 					/* The notified task has a priority above the currently
4641:../freertos/tasks.c **** 					executing task so a yield is required. */
4642:../freertos/tasks.c **** 					if( pxHigherPriorityTaskWoken != NULL )
 5748              		.loc 1 4642 0
 5749 00b4 3B68     		ldr	r3, [r7]
 5750 00b6 002B     		cmp	r3, #0
 5751 00b8 03D0     		beq	.L466
4643:../freertos/tasks.c **** 					{
4644:../freertos/tasks.c **** 						*pxHigherPriorityTaskWoken = pdTRUE;
 5752              		.loc 1 4644 0
 5753 00ba 3B68     		ldr	r3, [r7]
 5754 00bc 0122     		mov	r2, #1
 5755 00be 1A60     		str	r2, [r3]
 5756 00c0 02E0     		b	.L460
 5757              	.L466:
4645:../freertos/tasks.c **** 					}
4646:../freertos/tasks.c **** 					else
4647:../freertos/tasks.c **** 					{
4648:../freertos/tasks.c **** 						/* Mark that a yield is pending in case the user is not
4649:../freertos/tasks.c **** 						using the "xHigherPriorityTaskWoken" parameter in an ISR
4650:../freertos/tasks.c **** 						safe FreeRTOS function. */
4651:../freertos/tasks.c **** 						xYieldPending = pdTRUE;
 5758              		.loc 1 4651 0
 5759 00c2 0A4B     		ldr	r3, .L468+20
 5760 00c4 0122     		mov	r2, #1
 5761 00c6 1A60     		str	r2, [r3]
 5762              	.L460:
4652:../freertos/tasks.c **** 					}
4653:../freertos/tasks.c **** 				}
4654:../freertos/tasks.c **** 				else
4655:../freertos/tasks.c **** 				{
4656:../freertos/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4657:../freertos/tasks.c **** 				}
4658:../freertos/tasks.c **** 			}
4659:../freertos/tasks.c **** 		}
4660:../freertos/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 5763              		.loc 1 4660 0
 5764 00c8 3B69     		ldr	r3, [r7, #16]
 5765 00ca 181C     		mov	r0, r3
 5766 00cc FFF7FEFF 		bl	vClearInterruptMaskFromISR
4661:../freertos/tasks.c **** 	}
 5767              		.loc 1 4661 0
 5768 00d0 BD46     		mov	sp, r7
 5769 00d2 06B0     		add	sp, sp, #24
 5770              		@ sp needed
 5771 00d4 80BD     		pop	{r7, pc}
 5772              	.L469:
 5773 00d6 C046     		.align	2
 5774              	.L468:
 5775 00d8 00000000 		.word	uxSchedulerSuspended
 5776 00dc 00000000 		.word	uxTopReadyPriority
 5777 00e0 00000000 		.word	pxReadyTasksLists
 5778 00e4 00000000 		.word	xPendingReadyList
 5779 00e8 00000000 		.word	pxCurrentTCB
 5780 00ec 00000000 		.word	xYieldPending
 5781              		.cfi_endproc
 5782              	.LFE55:
 5784              		.section	.text.xTaskNotifyStateClear,"ax",%progbits
 5785              		.align	2
 5786              		.global	xTaskNotifyStateClear
 5787              		.code	16
 5788              		.thumb_func
 5790              	xTaskNotifyStateClear:
 5791              	.LFB56:
4662:../freertos/tasks.c **** 
4663:../freertos/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4664:../freertos/tasks.c **** 
4665:../freertos/tasks.c **** /*-----------------------------------------------------------*/
4666:../freertos/tasks.c **** 
4667:../freertos/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4668:../freertos/tasks.c **** 
4669:../freertos/tasks.c **** 	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
4670:../freertos/tasks.c **** 	{
 5792              		.loc 1 4670 0
 5793              		.cfi_startproc
 5794 0000 80B5     		push	{r7, lr}
 5795              		.cfi_def_cfa_offset 8
 5796              		.cfi_offset 7, -8
 5797              		.cfi_offset 14, -4
 5798 0002 84B0     		sub	sp, sp, #16
 5799              		.cfi_def_cfa_offset 24
 5800 0004 00AF     		add	r7, sp, #0
 5801              		.cfi_def_cfa_register 7
 5802 0006 7860     		str	r0, [r7, #4]
4671:../freertos/tasks.c **** 	TCB_t *pxTCB;
4672:../freertos/tasks.c **** 	BaseType_t xReturn;
4673:../freertos/tasks.c **** 
4674:../freertos/tasks.c **** 		/* If null is passed in here then it is the calling task that is having
4675:../freertos/tasks.c **** 		its notification state cleared. */
4676:../freertos/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
 5803              		.loc 1 4676 0
 5804 0008 7B68     		ldr	r3, [r7, #4]
 5805 000a 002B     		cmp	r3, #0
 5806 000c 02D1     		bne	.L471
 5807              		.loc 1 4676 0 is_stmt 0 discriminator 1
 5808 000e 0E4B     		ldr	r3, .L476
 5809 0010 1B68     		ldr	r3, [r3]
 5810 0012 00E0     		b	.L472
 5811              	.L471:
 5812              		.loc 1 4676 0 discriminator 2
 5813 0014 7B68     		ldr	r3, [r7, #4]
 5814              	.L472:
 5815              		.loc 1 4676 0 discriminator 3
 5816 0016 BB60     		str	r3, [r7, #8]
4677:../freertos/tasks.c **** 
4678:../freertos/tasks.c **** 		taskENTER_CRITICAL();
 5817              		.loc 1 4678 0 is_stmt 1 discriminator 3
 5818 0018 FFF7FEFF 		bl	vPortEnterCritical
4679:../freertos/tasks.c **** 		{
4680:../freertos/tasks.c **** 			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
 5819              		.loc 1 4680 0 discriminator 3
 5820 001c BA68     		ldr	r2, [r7, #8]
 5821 001e 7023     		mov	r3, #112
 5822 0020 D35C     		ldrb	r3, [r2, r3]
 5823 0022 DBB2     		uxtb	r3, r3
 5824 0024 022B     		cmp	r3, #2
 5825 0026 06D1     		bne	.L473
4681:../freertos/tasks.c **** 			{
4682:../freertos/tasks.c **** 				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 5826              		.loc 1 4682 0
 5827 0028 BA68     		ldr	r2, [r7, #8]
 5828 002a 7023     		mov	r3, #112
 5829 002c 0021     		mov	r1, #0
 5830 002e D154     		strb	r1, [r2, r3]
4683:../freertos/tasks.c **** 				xReturn = pdPASS;
 5831              		.loc 1 4683 0
 5832 0030 0123     		mov	r3, #1
 5833 0032 FB60     		str	r3, [r7, #12]
 5834 0034 01E0     		b	.L474
 5835              	.L473:
4684:../freertos/tasks.c **** 			}
4685:../freertos/tasks.c **** 			else
4686:../freertos/tasks.c **** 			{
4687:../freertos/tasks.c **** 				xReturn = pdFAIL;
 5836              		.loc 1 4687 0
 5837 0036 0023     		mov	r3, #0
 5838 0038 FB60     		str	r3, [r7, #12]
 5839              	.L474:
4688:../freertos/tasks.c **** 			}
4689:../freertos/tasks.c **** 		}
4690:../freertos/tasks.c **** 		taskEXIT_CRITICAL();
 5840              		.loc 1 4690 0
 5841 003a FFF7FEFF 		bl	vPortExitCritical
4691:../freertos/tasks.c **** 
4692:../freertos/tasks.c **** 		return xReturn;
 5842              		.loc 1 4692 0
 5843 003e FB68     		ldr	r3, [r7, #12]
4693:../freertos/tasks.c **** 	}
 5844              		.loc 1 4693 0
 5845 0040 181C     		mov	r0, r3
 5846 0042 BD46     		mov	sp, r7
 5847 0044 04B0     		add	sp, sp, #16
 5848              		@ sp needed
 5849 0046 80BD     		pop	{r7, pc}
 5850              	.L477:
 5851              		.align	2
 5852              	.L476:
 5853 0048 00000000 		.word	pxCurrentTCB
 5854              		.cfi_endproc
 5855              	.LFE56:
 5857              		.section	.text.prvAddCurrentTaskToDelayedList,"ax",%progbits
 5858              		.align	2
 5859              		.code	16
 5860              		.thumb_func
 5862              	prvAddCurrentTaskToDelayedList:
 5863              	.LFB57:
4694:../freertos/tasks.c **** 
4695:../freertos/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4696:../freertos/tasks.c **** /*-----------------------------------------------------------*/
4697:../freertos/tasks.c **** 
4698:../freertos/tasks.c **** 
4699:../freertos/tasks.c **** static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockInde
4700:../freertos/tasks.c **** {
 5864              		.loc 1 4700 0
 5865              		.cfi_startproc
 5866 0000 80B5     		push	{r7, lr}
 5867              		.cfi_def_cfa_offset 8
 5868              		.cfi_offset 7, -8
 5869              		.cfi_offset 14, -4
 5870 0002 84B0     		sub	sp, sp, #16
 5871              		.cfi_def_cfa_offset 24
 5872 0004 00AF     		add	r7, sp, #0
 5873              		.cfi_def_cfa_register 7
 5874 0006 7860     		str	r0, [r7, #4]
 5875 0008 3960     		str	r1, [r7]
4701:../freertos/tasks.c **** TickType_t xTimeToWake;
4702:../freertos/tasks.c **** const TickType_t xConstTickCount = xTickCount;
 5876              		.loc 1 4702 0
 5877 000a 214B     		ldr	r3, .L482
 5878 000c 1B68     		ldr	r3, [r3]
 5879 000e FB60     		str	r3, [r7, #12]
4703:../freertos/tasks.c **** 
4704:../freertos/tasks.c **** 	#if( INCLUDE_xTaskAbortDelay == 1 )
4705:../freertos/tasks.c **** 	{
4706:../freertos/tasks.c **** 		/* About to enter a delayed list, so ensure the ucDelayAborted flag is
4707:../freertos/tasks.c **** 		reset to pdFALSE so it can be detected as having been set to pdTRUE
4708:../freertos/tasks.c **** 		when the task leaves the Blocked state. */
4709:../freertos/tasks.c **** 		pxCurrentTCB->ucDelayAborted = pdFALSE;
4710:../freertos/tasks.c **** 	}
4711:../freertos/tasks.c **** 	#endif
4712:../freertos/tasks.c **** 
4713:../freertos/tasks.c **** 	/* Remove the task from the ready list before adding it to the blocked list
4714:../freertos/tasks.c **** 	as the same list item is used for both lists. */
4715:../freertos/tasks.c **** 	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 5880              		.loc 1 4715 0
 5881 0010 204B     		ldr	r3, .L482+4
 5882 0012 1B68     		ldr	r3, [r3]
 5883 0014 0433     		add	r3, r3, #4
 5884 0016 181C     		mov	r0, r3
 5885 0018 FFF7FEFF 		bl	uxListRemove
4716:../freertos/tasks.c **** 	{
4717:../freertos/tasks.c **** 		/* The current task must be in a ready list, so there is no need to
4718:../freertos/tasks.c **** 		check, and the port reset macro can be called directly. */
4719:../freertos/tasks.c **** 		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
4720:../freertos/tasks.c **** 	}
4721:../freertos/tasks.c **** 	else
4722:../freertos/tasks.c **** 	{
4723:../freertos/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
4724:../freertos/tasks.c **** 	}
4725:../freertos/tasks.c **** 
4726:../freertos/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
4727:../freertos/tasks.c **** 	{
4728:../freertos/tasks.c **** 		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 5886              		.loc 1 4728 0
 5887 001c 7B68     		ldr	r3, [r7, #4]
 5888 001e 0133     		add	r3, r3, #1
 5889 0020 0BD1     		bne	.L479
 5890              		.loc 1 4728 0 is_stmt 0 discriminator 1
 5891 0022 3B68     		ldr	r3, [r7]
 5892 0024 002B     		cmp	r3, #0
 5893 0026 08D0     		beq	.L479
4729:../freertos/tasks.c **** 		{
4730:../freertos/tasks.c **** 			/* Add the task to the suspended task list instead of a delayed task
4731:../freertos/tasks.c **** 			list to ensure it is not woken by a timing event.  It will block
4732:../freertos/tasks.c **** 			indefinitely. */
4733:../freertos/tasks.c **** 			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 5894              		.loc 1 4733 0 is_stmt 1
 5895 0028 1A4B     		ldr	r3, .L482+4
 5896 002a 1B68     		ldr	r3, [r3]
 5897 002c 0433     		add	r3, r3, #4
 5898 002e 1A4A     		ldr	r2, .L482+8
 5899 0030 101C     		mov	r0, r2
 5900 0032 191C     		mov	r1, r3
 5901 0034 FFF7FEFF 		bl	vListInsertEnd
 5902 0038 26E0     		b	.L478
 5903              	.L479:
4734:../freertos/tasks.c **** 		}
4735:../freertos/tasks.c **** 		else
4736:../freertos/tasks.c **** 		{
4737:../freertos/tasks.c **** 			/* Calculate the time at which the task should be woken if the event
4738:../freertos/tasks.c **** 			does not occur.  This may overflow but this doesn't matter, the
4739:../freertos/tasks.c **** 			kernel will manage it correctly. */
4740:../freertos/tasks.c **** 			xTimeToWake = xConstTickCount + xTicksToWait;
 5904              		.loc 1 4740 0
 5905 003a FA68     		ldr	r2, [r7, #12]
 5906 003c 7B68     		ldr	r3, [r7, #4]
 5907 003e D318     		add	r3, r2, r3
 5908 0040 BB60     		str	r3, [r7, #8]
4741:../freertos/tasks.c **** 
4742:../freertos/tasks.c **** 			/* The list item will be inserted in wake time order. */
4743:../freertos/tasks.c **** 			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 5909              		.loc 1 4743 0
 5910 0042 144B     		ldr	r3, .L482+4
 5911 0044 1B68     		ldr	r3, [r3]
 5912 0046 BA68     		ldr	r2, [r7, #8]
 5913 0048 5A60     		str	r2, [r3, #4]
4744:../freertos/tasks.c **** 
4745:../freertos/tasks.c **** 			if( xTimeToWake < xConstTickCount )
 5914              		.loc 1 4745 0
 5915 004a BA68     		ldr	r2, [r7, #8]
 5916 004c FB68     		ldr	r3, [r7, #12]
 5917 004e 9A42     		cmp	r2, r3
 5918 0050 09D2     		bcs	.L481
4746:../freertos/tasks.c **** 			{
4747:../freertos/tasks.c **** 				/* Wake time has overflowed.  Place this item in the overflow
4748:../freertos/tasks.c **** 				list. */
4749:../freertos/tasks.c **** 				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 5919              		.loc 1 4749 0
 5920 0052 124B     		ldr	r3, .L482+12
 5921 0054 1A68     		ldr	r2, [r3]
 5922 0056 0F4B     		ldr	r3, .L482+4
 5923 0058 1B68     		ldr	r3, [r3]
 5924 005a 0433     		add	r3, r3, #4
 5925 005c 101C     		mov	r0, r2
 5926 005e 191C     		mov	r1, r3
 5927 0060 FFF7FEFF 		bl	vListInsert
 5928 0064 10E0     		b	.L478
 5929              	.L481:
4750:../freertos/tasks.c **** 			}
4751:../freertos/tasks.c **** 			else
4752:../freertos/tasks.c **** 			{
4753:../freertos/tasks.c **** 				/* The wake time has not overflowed, so the current block list
4754:../freertos/tasks.c **** 				is used. */
4755:../freertos/tasks.c **** 				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 5930              		.loc 1 4755 0
 5931 0066 0E4B     		ldr	r3, .L482+16
 5932 0068 1A68     		ldr	r2, [r3]
 5933 006a 0A4B     		ldr	r3, .L482+4
 5934 006c 1B68     		ldr	r3, [r3]
 5935 006e 0433     		add	r3, r3, #4
 5936 0070 101C     		mov	r0, r2
 5937 0072 191C     		mov	r1, r3
 5938 0074 FFF7FEFF 		bl	vListInsert
4756:../freertos/tasks.c **** 
4757:../freertos/tasks.c **** 				/* If the task entering the blocked state was placed at the
4758:../freertos/tasks.c **** 				head of the list of blocked tasks then xNextTaskUnblockTime
4759:../freertos/tasks.c **** 				needs to be updated too. */
4760:../freertos/tasks.c **** 				if( xTimeToWake < xNextTaskUnblockTime )
 5939              		.loc 1 4760 0
 5940 0078 0A4B     		ldr	r3, .L482+20
 5941 007a 1B68     		ldr	r3, [r3]
 5942 007c BA68     		ldr	r2, [r7, #8]
 5943 007e 9A42     		cmp	r2, r3
 5944 0080 02D2     		bcs	.L478
4761:../freertos/tasks.c **** 				{
4762:../freertos/tasks.c **** 					xNextTaskUnblockTime = xTimeToWake;
 5945              		.loc 1 4762 0
 5946 0082 084B     		ldr	r3, .L482+20
 5947 0084 BA68     		ldr	r2, [r7, #8]
 5948 0086 1A60     		str	r2, [r3]
 5949              	.L478:
4763:../freertos/tasks.c **** 				}
4764:../freertos/tasks.c **** 				else
4765:../freertos/tasks.c **** 				{
4766:../freertos/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4767:../freertos/tasks.c **** 				}
4768:../freertos/tasks.c **** 			}
4769:../freertos/tasks.c **** 		}
4770:../freertos/tasks.c **** 	}
4771:../freertos/tasks.c **** 	#else /* INCLUDE_vTaskSuspend */
4772:../freertos/tasks.c **** 	{
4773:../freertos/tasks.c **** 		/* Calculate the time at which the task should be woken if the event
4774:../freertos/tasks.c **** 		does not occur.  This may overflow but this doesn't matter, the kernel
4775:../freertos/tasks.c **** 		will manage it correctly. */
4776:../freertos/tasks.c **** 		xTimeToWake = xConstTickCount + xTicksToWait;
4777:../freertos/tasks.c **** 
4778:../freertos/tasks.c **** 		/* The list item will be inserted in wake time order. */
4779:../freertos/tasks.c **** 		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
4780:../freertos/tasks.c **** 
4781:../freertos/tasks.c **** 		if( xTimeToWake < xConstTickCount )
4782:../freertos/tasks.c **** 		{
4783:../freertos/tasks.c **** 			/* Wake time has overflowed.  Place this item in the overflow list. */
4784:../freertos/tasks.c **** 			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
4785:../freertos/tasks.c **** 		}
4786:../freertos/tasks.c **** 		else
4787:../freertos/tasks.c **** 		{
4788:../freertos/tasks.c **** 			/* The wake time has not overflowed, so the current block list is used. */
4789:../freertos/tasks.c **** 			vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
4790:../freertos/tasks.c **** 
4791:../freertos/tasks.c **** 			/* If the task entering the blocked state was placed at the head of the
4792:../freertos/tasks.c **** 			list of blocked tasks then xNextTaskUnblockTime needs to be updated
4793:../freertos/tasks.c **** 			too. */
4794:../freertos/tasks.c **** 			if( xTimeToWake < xNextTaskUnblockTime )
4795:../freertos/tasks.c **** 			{
4796:../freertos/tasks.c **** 				xNextTaskUnblockTime = xTimeToWake;
4797:../freertos/tasks.c **** 			}
4798:../freertos/tasks.c **** 			else
4799:../freertos/tasks.c **** 			{
4800:../freertos/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4801:../freertos/tasks.c **** 			}
4802:../freertos/tasks.c **** 		}
4803:../freertos/tasks.c **** 
4804:../freertos/tasks.c **** 		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
4805:../freertos/tasks.c **** 		( void ) xCanBlockIndefinitely;
4806:../freertos/tasks.c **** 	}
4807:../freertos/tasks.c **** 	#endif /* INCLUDE_vTaskSuspend */
4808:../freertos/tasks.c **** }
 5950              		.loc 1 4808 0
 5951 0088 BD46     		mov	sp, r7
 5952 008a 04B0     		add	sp, sp, #16
 5953              		@ sp needed
 5954 008c 80BD     		pop	{r7, pc}
 5955              	.L483:
 5956 008e C046     		.align	2
 5957              	.L482:
 5958 0090 00000000 		.word	xTickCount
 5959 0094 00000000 		.word	pxCurrentTCB
 5960 0098 00000000 		.word	xSuspendedTaskList
 5961 009c 00000000 		.word	pxOverflowDelayedTaskList
 5962 00a0 00000000 		.word	pxDelayedTaskList
 5963 00a4 00000000 		.word	xNextTaskUnblockTime
 5964              		.cfi_endproc
 5965              	.LFE57:
 5967              		.text
 5968              	.Letext0:
 5969              		.file 2 "c:\\freescale\\kds_v3\\toolchain\\lib\\gcc\\arm-none-eabi\\4.8.4\\include\\stddef.h"
 5970              		.file 3 "c:\\freescale\\kds_v3\\toolchain\\arm-none-eabi\\include\\machine\\_default_types.h"
 5971              		.file 4 "c:\\freescale\\kds_v3\\toolchain\\arm-none-eabi\\include\\stdint.h"
 5972              		.file 5 "../freertos/projdefs.h"
 5973              		.file 6 "../freertos/portmacro.h"
 5974              		.file 7 "../freertos/list.h"
 5975              		.file 8 "../freertos/task.h"
DEFINED SYMBOLS
                            *ABS*:00000000 tasks.c
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:22     .bss.pxCurrentTCB:00000000 pxCurrentTCB
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:19     .bss.pxCurrentTCB:00000000 $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:25     .bss.pxReadyTasksLists:00000000 $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:28     .bss.pxReadyTasksLists:00000000 pxReadyTasksLists
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:31     .bss.xDelayedTaskList1:00000000 $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:34     .bss.xDelayedTaskList1:00000000 xDelayedTaskList1
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:37     .bss.xDelayedTaskList2:00000000 $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:40     .bss.xDelayedTaskList2:00000000 xDelayedTaskList2
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:43     .bss.pxDelayedTaskList:00000000 $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:46     .bss.pxDelayedTaskList:00000000 pxDelayedTaskList
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:49     .bss.pxOverflowDelayedTaskList:00000000 $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:52     .bss.pxOverflowDelayedTaskList:00000000 pxOverflowDelayedTaskList
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:55     .bss.xPendingReadyList:00000000 $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:58     .bss.xPendingReadyList:00000000 xPendingReadyList
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:61     .bss.xTasksWaitingTermination:00000000 $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:64     .bss.xTasksWaitingTermination:00000000 xTasksWaitingTermination
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:67     .bss.uxDeletedTasksWaitingCleanUp:00000000 $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:70     .bss.uxDeletedTasksWaitingCleanUp:00000000 uxDeletedTasksWaitingCleanUp
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:73     .bss.xSuspendedTaskList:00000000 $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:76     .bss.xSuspendedTaskList:00000000 xSuspendedTaskList
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:79     .bss.uxCurrentNumberOfTasks:00000000 $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:82     .bss.uxCurrentNumberOfTasks:00000000 uxCurrentNumberOfTasks
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:85     .bss.xTickCount:00000000 $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:88     .bss.xTickCount:00000000 xTickCount
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:91     .bss.uxTopReadyPriority:00000000 $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:94     .bss.uxTopReadyPriority:00000000 uxTopReadyPriority
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:97     .bss.xSchedulerRunning:00000000 $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:100    .bss.xSchedulerRunning:00000000 xSchedulerRunning
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:103    .bss.uxPendedTicks:00000000 $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:106    .bss.uxPendedTicks:00000000 uxPendedTicks
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:109    .bss.xYieldPending:00000000 $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:112    .bss.xYieldPending:00000000 xYieldPending
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:115    .bss.xNumOfOverflows:00000000 $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:118    .bss.xNumOfOverflows:00000000 xNumOfOverflows
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:121    .bss.uxTaskNumber:00000000 $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:124    .bss.uxTaskNumber:00000000 uxTaskNumber
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:127    .bss.xNextTaskUnblockTime:00000000 $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:130    .bss.xNextTaskUnblockTime:00000000 xNextTaskUnblockTime
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:133    .bss.xIdleTaskHandle:00000000 $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:136    .bss.xIdleTaskHandle:00000000 xIdleTaskHandle
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:139    .bss.uxSchedulerSuspended:00000000 $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:142    .bss.uxSchedulerSuspended:00000000 uxSchedulerSuspended
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:145    .text.xTaskCreate:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:150    .text.xTaskCreate:00000000 xTaskCreate
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:257    .text.prvInitialiseNewTask:00000000 prvInitialiseNewTask
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:461    .text.prvAddNewTaskToReadyList:00000000 prvAddNewTaskToReadyList
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:253    .text.prvInitialiseNewTask:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:452    .text.prvInitialiseNewTask:0000011c $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:457    .text.prvAddNewTaskToReadyList:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:3883   .text.prvInitialiseTaskLists:00000000 prvInitialiseTaskLists
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:582    .text.prvAddNewTaskToReadyList:000000b4 $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:592    .text.vTaskDelete:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:597    .text.vTaskDelete:00000000 vTaskDelete
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:4381   .text.prvDeleteTCB:00000000 prvDeleteTCB
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:4416   .text.prvResetNextTaskUnblockTime:00000000 prvResetNextTaskUnblockTime
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:719    .text.vTaskDelete:000000a8 $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:730    .text.vTaskDelayUntil:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:735    .text.vTaskDelayUntil:00000000 vTaskDelayUntil
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:2033   .text.vTaskSuspendAll:00000000 vTaskSuspendAll
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:5862   .text.prvAddCurrentTaskToDelayedList:00000000 prvAddCurrentTaskToDelayedList
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:2066   .text.xTaskResumeAll:00000000 xTaskResumeAll
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:876    .text.vTaskDelayUntil:000000ac $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:882    .text.vTaskDelay:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:887    .text.vTaskDelay:00000000 vTaskDelay
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:947    .text.vTaskDelay:00000044 $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:952    .text.eTaskGetState:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:957    .text.eTaskGetState:00000000 eTaskGetState
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:1086   .text.eTaskGetState:000000a8 $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:1095   .text.uxTaskPriorityGet:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:1100   .text.uxTaskPriorityGet:00000000 uxTaskPriorityGet
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:1146   .text.uxTaskPriorityGet:00000030 $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:1151   .text.uxTaskPriorityGetFromISR:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:1156   .text.uxTaskPriorityGetFromISR:00000000 uxTaskPriorityGetFromISR
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:1206   .text.uxTaskPriorityGetFromISR:00000038 $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:1211   .text.vTaskPrioritySet:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:1216   .text.vTaskPrioritySet:00000000 vTaskPrioritySet
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:1415   .text.vTaskPrioritySet:00000114 $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:1422   .text.vTaskSuspend:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:1427   .text.vTaskSuspend:00000000 vTaskSuspend
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:2827   .text.vTaskSwitchContext:00000000 vTaskSwitchContext
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:1545   .text.vTaskSuspend:000000a0 $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:1554   .text.prvTaskIsTaskSuspended:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:1558   .text.prvTaskIsTaskSuspended:00000000 prvTaskIsTaskSuspended
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:1641   .text.prvTaskIsTaskSuspended:00000058 $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:1647   .text.vTaskResume:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:1652   .text.vTaskResume:00000000 vTaskResume
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:1753   .text.vTaskResume:00000090 $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:1760   .text.xTaskResumeFromISR:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:1765   .text.xTaskResumeFromISR:00000000 xTaskResumeFromISR
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:1881   .text.xTaskResumeFromISR:000000a8 $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:1890   .rodata:00000000 $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:1894   .text.vTaskStartScheduler:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:1899   .text.vTaskStartScheduler:00000000 vTaskStartScheduler
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:1980   .text.vTaskStartScheduler:00000064 $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:3717   .text.prvIdleTask:00000000 prvIdleTask
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:1990   .text.vTaskEndScheduler:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:1995   .text.vTaskEndScheduler:00000000 vTaskEndScheduler
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:2023   .text.vTaskEndScheduler:00000014 $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:2028   .text.vTaskSuspendAll:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:2056   .text.vTaskSuspendAll:00000014 $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:2061   .text.xTaskResumeAll:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:2596   .text.xTaskIncrementTick:00000000 xTaskIncrementTick
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:2243   .text.xTaskResumeAll:000000f8 $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:2255   .text.xTaskGetTickCount:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:2260   .text.xTaskGetTickCount:00000000 xTaskGetTickCount
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:2287   .text.xTaskGetTickCount:00000018 $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:2292   .text.xTaskGetTickCountFromISR:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:2297   .text.xTaskGetTickCountFromISR:00000000 xTaskGetTickCountFromISR
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:2327   .text.xTaskGetTickCountFromISR:0000001c $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:2332   .text.uxTaskGetNumberOfTasks:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:2337   .text.uxTaskGetNumberOfTasks:00000000 uxTaskGetNumberOfTasks
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:2358   .text.uxTaskGetNumberOfTasks:00000010 $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:2363   .text.pcTaskGetName:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:2368   .text.pcTaskGetName:00000000 pcTaskGetName
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:2419   .text.pcTaskGetName:00000030 $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:2424   .text.uxTaskGetSystemState:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:2429   .text.uxTaskGetSystemState:00000000 uxTaskGetSystemState
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:4205   .text.prvListTasksWithinSingleList:00000000 prvListTasksWithinSingleList
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:2581   .text.uxTaskGetSystemState:00000104 $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:2591   .text.xTaskIncrementTick:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:2807   .text.xTaskIncrementTick:00000124 $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:2822   .text.vTaskSwitchContext:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:2936   .text.vTaskSwitchContext:0000008c $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:2945   .text.vTaskPlaceOnEventList:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:2950   .text.vTaskPlaceOnEventList:00000000 vTaskPlaceOnEventList
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:2997   .text.vTaskPlaceOnEventList:00000034 $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:3002   .text.vTaskPlaceOnUnorderedEventList:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:3007   .text.vTaskPlaceOnUnorderedEventList:00000000 vTaskPlaceOnUnorderedEventList
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:3076   .text.vTaskPlaceOnUnorderedEventList:00000050 $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:3082   .text.vTaskPlaceOnEventListRestricted:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:3087   .text.vTaskPlaceOnEventListRestricted:00000000 vTaskPlaceOnEventListRestricted
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:3145   .text.vTaskPlaceOnEventListRestricted:00000044 $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:3150   .text.xTaskRemoveFromEventList:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:3155   .text.xTaskRemoveFromEventList:00000000 xTaskRemoveFromEventList
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:3269   .text.xTaskRemoveFromEventList:000000a0 $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:3279   .text.xTaskRemoveFromUnorderedEventList:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:3284   .text.xTaskRemoveFromUnorderedEventList:00000000 xTaskRemoveFromUnorderedEventList
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:3402   .text.xTaskRemoveFromUnorderedEventList:0000009c $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:3411   .text.vTaskSetTimeOutState:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:3416   .text.vTaskSetTimeOutState:00000000 vTaskSetTimeOutState
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:3459   .text.vTaskSetTimeOutState:00000028 $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:3465   .text.xTaskCheckForTimeOut:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:3470   .text.xTaskCheckForTimeOut:00000000 xTaskCheckForTimeOut
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:3589   .text.xTaskCheckForTimeOut:00000094 $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:3595   .text.vTaskMissedYield:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:3600   .text.vTaskMissedYield:00000000 vTaskMissedYield
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:3621   .text.vTaskMissedYield:00000010 $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:3626   .text.uxTaskGetTaskNumber:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:3631   .text.uxTaskGetTaskNumber:00000000 uxTaskGetTaskNumber
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:3673   .text.vTaskSetTaskNumber:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:3678   .text.vTaskSetTaskNumber:00000000 vTaskSetTaskNumber
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:3713   .text.prvIdleTask:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:3971   .text.prvCheckTasksWaitingTermination:00000000 prvCheckTasksWaitingTermination
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:3746   .text.prvIdleTask:0000001c $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:3751   .text.vTaskSetThreadLocalStoragePointer:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:3756   .text.vTaskSetThreadLocalStoragePointer:00000000 vTaskSetThreadLocalStoragePointer
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:3805   .text.vTaskSetThreadLocalStoragePointer:00000034 $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:3810   .text.pvTaskGetThreadLocalStoragePointer:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:3815   .text.pvTaskGetThreadLocalStoragePointer:00000000 pvTaskGetThreadLocalStoragePointer
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:3874   .text.pvTaskGetThreadLocalStoragePointer:00000040 $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:3879   .text.prvInitialiseTaskLists:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:3955   .text.prvInitialiseTaskLists:00000068 $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:3967   .text.prvCheckTasksWaitingTermination:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:4049   .text.prvCheckTasksWaitingTermination:00000068 $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:4056   .text.vTaskGetInfo:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:4061   .text.vTaskGetInfo:00000000 vTaskGetInfo
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:4327   .text.prvTaskCheckFreeStackSpace:00000000 prvTaskCheckFreeStackSpace
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:4196   .text.vTaskGetInfo:000000c0 $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:4201   .text.prvListTasksWithinSingleList:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:4323   .text.prvTaskCheckFreeStackSpace:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:4377   .text.prvDeleteTCB:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:4412   .text.prvResetNextTaskUnblockTime:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:4471   .text.prvResetNextTaskUnblockTime:0000003c $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:4477   .text.xTaskGetCurrentTaskHandle:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:4482   .text.xTaskGetCurrentTaskHandle:00000000 xTaskGetCurrentTaskHandle
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:4509   .text.xTaskGetCurrentTaskHandle:00000018 $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:4514   .text.xTaskGetSchedulerState:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:4519   .text.xTaskGetSchedulerState:00000000 xTaskGetSchedulerState
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:4566   .text.xTaskGetSchedulerState:00000030 $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:4572   .text.vTaskPriorityInherit:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:4577   .text.vTaskPriorityInherit:00000000 vTaskPriorityInherit
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:4697   .text.vTaskPriorityInherit:000000b0 $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:4704   .text.xTaskPriorityDisinherit:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:4709   .text.xTaskPriorityDisinherit:00000000 xTaskPriorityDisinherit
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:4836   .text.xTaskPriorityDisinherit:000000ac $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:4843   .text.uxTaskResetEventItemValue:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:4848   .text.uxTaskResetEventItemValue:00000000 uxTaskResetEventItemValue
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:4885   .text.uxTaskResetEventItemValue:00000028 $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:4890   .text.pvTaskIncrementMutexHeldCount:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:4895   .text.pvTaskIncrementMutexHeldCount:00000000 pvTaskIncrementMutexHeldCount
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:4928   .text.pvTaskIncrementMutexHeldCount:00000020 $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:4933   .text.ulTaskNotifyTake:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:4938   .text.ulTaskNotifyTake:00000000 ulTaskNotifyTake
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:5028   .text.ulTaskNotifyTake:00000080 $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:5033   .text.xTaskNotifyWait:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:5038   .text.xTaskNotifyWait:00000000 xTaskNotifyWait
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:5149   .text.xTaskNotifyWait:000000a4 $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:5154   .text.xTaskGenericNotify:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:5159   .text.xTaskGenericNotify:00000000 xTaskGenericNotify
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:5229   .rodata.xTaskGenericNotify:00000000 $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:5361   .text.xTaskGenericNotify:00000108 $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:5369   .text.xTaskGenericNotifyFromISR:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:5374   .text.xTaskGenericNotifyFromISR:00000000 xTaskGenericNotifyFromISR
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:5446   .rodata.xTaskGenericNotifyFromISR:00000000 $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:5607   .text.xTaskGenericNotifyFromISR:00000138 $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:5618   .text.vTaskNotifyGiveFromISR:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:5623   .text.vTaskNotifyGiveFromISR:00000000 vTaskNotifyGiveFromISR
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:5775   .text.vTaskNotifyGiveFromISR:000000d8 $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:5785   .text.xTaskNotifyStateClear:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:5790   .text.xTaskNotifyStateClear:00000000 xTaskNotifyStateClear
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:5853   .text.xTaskNotifyStateClear:00000048 $d
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:5858   .text.prvAddCurrentTaskToDelayedList:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccV6t7G7.s:5958   .text.prvAddCurrentTaskToDelayedList:00000090 $d
                     .debug_frame:00000010 $d
                           .group:00000000 wm4.0.e19fef13b9966be9a9a0df56dde4c190
                           .group:00000000 wm4.newlib.h.8.fec018e441fee7bfa1923812ad010f97
                           .group:00000000 wm4.features.h.22.6a4ca7cd053637cc1d0db6c16f39b2d7
                           .group:00000000 wm4.config.h.212.4163ef2871a828c674038d036b081cfd
                           .group:00000000 wm4._ansi.h.23.2147fde150631f5584b9dc29b914d1b8
                           .group:00000000 wm4.stdlib.h.13.4ed386f5c1a80d71e72172885d946ef2
                           .group:00000000 wm4.stddef.h.184.aa65fb7281d578229bbad41b91862635
                           .group:00000000 wm4.stddef.h.39.d0197034aa5fd947cae140b9289e6734
                           .group:00000000 wm4._default_types.h.6.9e4229723f5523536bc8f574589d6a99
                           .group:00000000 wm4.lock.h.2.9bc98482741e5e2a9450b12934a684ea
                           .group:00000000 wm4._types.h.54.d3d34a3b7f3cc230cd159baf022b4b08
                           .group:00000000 wm4.stddef.h.158.61317cdbfb4026324507d123a50b0fd6
                           .group:00000000 wm4.reent.h.17.8bd9e4098e0428508c282cad794fae43
                           .group:00000000 wm4.stdlib.h.53.a73f7e963d962393b7f9086194931e4a
                           .group:00000000 wm4.cdefs.h.56.a2d04de9d47039852021e66fca39bb58
                           .group:00000000 wm4.string.h.15.dab3980bf35408a4c507182805e2de3a
                           .group:00000000 wm4.stddef.h.158.a7efb00f6cbc6f43213b50e183c9830c
                           .group:00000000 wm4.stdint.h.10.d0f8e374834fcfc2e296d5d5fe82f02a
                           .group:00000000 wm4.FreeRTOSConfig.h.71.9ce5dd93bb084cb2714008d9030c087d
                           .group:00000000 wm4.projdefs.h.71.6ed2b4e07820ea275c61d78138cfae10
                           .group:00000000 wm4.portmacro.h.72.32efb3512b0394b29d8211ba7ab279d9
                           .group:00000000 wm4.portable.h.106.61ffdda1afafb5a5e1f7197ade95b43a
                           .group:00000000 wm4.mpu_wrappers.h.71.c0872672d360e197b5a999335351843d
                           .group:00000000 wm4.FreeRTOS.h.186.2e14eee2d995e9702d028b4adcebc296
                           .group:00000000 wm4.list.h.103.6a12b7b9a7a136c3cca0ee53675c5498
                           .group:00000000 wm4.task.h.88.c21feabc7be8ca1396f9c7c7a7eaee9b
                           .group:00000000 wm4.timers.h.72.0dcea34c14180ef23637dc91dfd6a310
                           .group:00000000 wm4.StackMacros.h.71.f4b392b8a8ca858f54a8e6627398533d

UNDEFINED SYMBOLS
pvPortMalloc
vPortFree
memset
vListInitialiseItem
pxPortInitialiseStack
vPortEnterCritical
vListInsertEnd
vPortExitCritical
vPortYield
uxListRemove
ulSetInterruptMaskFromISR
vClearInterruptMaskFromISR
xTimerCreateTimerTask
xPortStartScheduler
vPortEndScheduler
vListInsert
vListInitialise
