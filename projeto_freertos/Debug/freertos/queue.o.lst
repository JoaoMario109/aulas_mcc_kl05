   1              		.cpu cortex-m0plus
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"queue.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.comm	xQueueRegistry,64,4
  18              		.section	.text.xQueueGenericReset,"ax",%progbits
  19              		.align	2
  20              		.global	xQueueGenericReset
  21              		.code	16
  22              		.thumb_func
  24              	xQueueGenericReset:
  25              	.LFB0:
  26              		.file 1 "../freertos/queue.c"
   1:../freertos/queue.c **** /*
   2:../freertos/queue.c ****     FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
   3:../freertos/queue.c ****     All rights reserved
   4:../freertos/queue.c **** 
   5:../freertos/queue.c ****     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
   6:../freertos/queue.c **** 
   7:../freertos/queue.c ****     This file is part of the FreeRTOS distribution.
   8:../freertos/queue.c **** 
   9:../freertos/queue.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  10:../freertos/queue.c ****     the terms of the GNU General Public License (version 2) as published by the
  11:../freertos/queue.c ****     Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
  12:../freertos/queue.c **** 
  13:../freertos/queue.c ****     ***************************************************************************
  14:../freertos/queue.c ****     >>!   NOTE: The modification to the GPL is included to allow you to     !<<
  15:../freertos/queue.c ****     >>!   distribute a combined work that includes FreeRTOS without being   !<<
  16:../freertos/queue.c ****     >>!   obliged to provide the source code for proprietary components     !<<
  17:../freertos/queue.c ****     >>!   outside of the FreeRTOS kernel.                                   !<<
  18:../freertos/queue.c ****     ***************************************************************************
  19:../freertos/queue.c **** 
  20:../freertos/queue.c ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
  21:../freertos/queue.c ****     WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  22:../freertos/queue.c ****     FOR A PARTICULAR PURPOSE.  Full license text is available on the following
  23:../freertos/queue.c ****     link: http://www.freertos.org/a00114.html
  24:../freertos/queue.c **** 
  25:../freertos/queue.c ****     ***************************************************************************
  26:../freertos/queue.c ****      *                                                                       *
  27:../freertos/queue.c ****      *    FreeRTOS provides completely free yet professionally developed,    *
  28:../freertos/queue.c ****      *    robust, strictly quality controlled, supported, and cross          *
  29:../freertos/queue.c ****      *    platform software that is more than just the market leader, it     *
  30:../freertos/queue.c ****      *    is the industry's de facto standard.                               *
  31:../freertos/queue.c ****      *                                                                       *
  32:../freertos/queue.c ****      *    Help yourself get started quickly while simultaneously helping     *
  33:../freertos/queue.c ****      *    to support the FreeRTOS project by purchasing a FreeRTOS           *
  34:../freertos/queue.c ****      *    tutorial book, reference manual, or both:                          *
  35:../freertos/queue.c ****      *    http://www.FreeRTOS.org/Documentation                              *
  36:../freertos/queue.c ****      *                                                                       *
  37:../freertos/queue.c ****     ***************************************************************************
  38:../freertos/queue.c **** 
  39:../freertos/queue.c ****     http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
  40:../freertos/queue.c ****     the FAQ page "My application does not run, what could be wrong?".  Have you
  41:../freertos/queue.c ****     defined configASSERT()?
  42:../freertos/queue.c **** 
  43:../freertos/queue.c ****     http://www.FreeRTOS.org/support - In return for receiving this top quality
  44:../freertos/queue.c ****     embedded software for free we request you assist our global community by
  45:../freertos/queue.c ****     participating in the support forum.
  46:../freertos/queue.c **** 
  47:../freertos/queue.c ****     http://www.FreeRTOS.org/training - Investing in training allows your team to
  48:../freertos/queue.c ****     be as productive as possible as early as possible.  Now you can receive
  49:../freertos/queue.c ****     FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
  50:../freertos/queue.c ****     Ltd, and the world's leading authority on the world's leading RTOS.
  51:../freertos/queue.c **** 
  52:../freertos/queue.c ****     http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
  53:../freertos/queue.c ****     including FreeRTOS+Trace - an indispensable productivity tool, a DOS
  54:../freertos/queue.c ****     compatible FAT file system, and our tiny thread aware UDP/IP stack.
  55:../freertos/queue.c **** 
  56:../freertos/queue.c ****     http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
  57:../freertos/queue.c ****     Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
  58:../freertos/queue.c **** 
  59:../freertos/queue.c ****     http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
  60:../freertos/queue.c ****     Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
  61:../freertos/queue.c ****     licenses offer ticketed support, indemnification and commercial middleware.
  62:../freertos/queue.c **** 
  63:../freertos/queue.c ****     http://www.SafeRTOS.com - High Integrity Systems also provide a safety
  64:../freertos/queue.c ****     engineered and independently SIL3 certified version for use in safety and
  65:../freertos/queue.c ****     mission critical applications that require provable dependability.
  66:../freertos/queue.c **** 
  67:../freertos/queue.c ****     1 tab == 4 spaces!
  68:../freertos/queue.c **** */
  69:../freertos/queue.c **** 
  70:../freertos/queue.c **** #include <stdlib.h>
  71:../freertos/queue.c **** #include <string.h>
  72:../freertos/queue.c **** 
  73:../freertos/queue.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  74:../freertos/queue.c **** all the API functions to use the MPU wrappers.  That should only be done when
  75:../freertos/queue.c **** task.h is included from an application file. */
  76:../freertos/queue.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  77:../freertos/queue.c **** 
  78:../freertos/queue.c **** #include "FreeRTOS.h"
  79:../freertos/queue.c **** #include "task.h"
  80:../freertos/queue.c **** #include "queue.h"
  81:../freertos/queue.c **** 
  82:../freertos/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
  83:../freertos/queue.c **** 	#include "croutine.h"
  84:../freertos/queue.c **** #endif
  85:../freertos/queue.c **** 
  86:../freertos/queue.c **** /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
  87:../freertos/queue.c **** MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
  88:../freertos/queue.c **** header files above, but not in this file, in order to generate the correct
  89:../freertos/queue.c **** privileged Vs unprivileged linkage and placement. */
  90:../freertos/queue.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
  91:../freertos/queue.c **** 
  92:../freertos/queue.c **** 
  93:../freertos/queue.c **** /* Constants used with the cRxLock and cTxLock structure members. */
  94:../freertos/queue.c **** #define queueUNLOCKED					( ( int8_t ) -1 )
  95:../freertos/queue.c **** #define queueLOCKED_UNMODIFIED			( ( int8_t ) 0 )
  96:../freertos/queue.c **** 
  97:../freertos/queue.c **** /* When the Queue_t structure is used to represent a base queue its pcHead and
  98:../freertos/queue.c **** pcTail members are used as pointers into the queue storage area.  When the
  99:../freertos/queue.c **** Queue_t structure is used to represent a mutex pcHead and pcTail pointers are
 100:../freertos/queue.c **** not necessary, and the pcHead pointer is set to NULL to indicate that the
 101:../freertos/queue.c **** pcTail pointer actually points to the mutex holder (if any).  Map alternative
 102:../freertos/queue.c **** names to the pcHead and pcTail structure members to ensure the readability of
 103:../freertos/queue.c **** the code is maintained despite this dual use of two structure members.  An
 104:../freertos/queue.c **** alternative implementation would be to use a union, but use of a union is
 105:../freertos/queue.c **** against the coding standard (although an exception to the standard has been
 106:../freertos/queue.c **** permitted where the dual use also significantly changes the type of the
 107:../freertos/queue.c **** structure member). */
 108:../freertos/queue.c **** #define pxMutexHolder					pcTail
 109:../freertos/queue.c **** #define uxQueueType						pcHead
 110:../freertos/queue.c **** #define queueQUEUE_IS_MUTEX				NULL
 111:../freertos/queue.c **** 
 112:../freertos/queue.c **** /* Semaphores do not actually store or copy data, so have an item size of
 113:../freertos/queue.c **** zero. */
 114:../freertos/queue.c **** #define queueSEMAPHORE_QUEUE_ITEM_LENGTH ( ( UBaseType_t ) 0 )
 115:../freertos/queue.c **** #define queueMUTEX_GIVE_BLOCK_TIME		 ( ( TickType_t ) 0U )
 116:../freertos/queue.c **** 
 117:../freertos/queue.c **** #if( configUSE_PREEMPTION == 0 )
 118:../freertos/queue.c **** 	/* If the cooperative scheduler is being used then a yield should not be
 119:../freertos/queue.c **** 	performed just because a higher priority task has been woken. */
 120:../freertos/queue.c **** 	#define queueYIELD_IF_USING_PREEMPTION()
 121:../freertos/queue.c **** #else
 122:../freertos/queue.c **** 	#define queueYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
 123:../freertos/queue.c **** #endif
 124:../freertos/queue.c **** 
 125:../freertos/queue.c **** /*
 126:../freertos/queue.c ****  * Definition of the queue used by the scheduler.
 127:../freertos/queue.c ****  * Items are queued by copy, not reference.  See the following link for the
 128:../freertos/queue.c ****  * rationale: http://www.freertos.org/Embedded-RTOS-Queues.html
 129:../freertos/queue.c ****  */
 130:../freertos/queue.c **** typedef struct QueueDefinition
 131:../freertos/queue.c **** {
 132:../freertos/queue.c **** 	int8_t *pcHead;					/*< Points to the beginning of the queue storage area. */
 133:../freertos/queue.c **** 	int8_t *pcTail;					/*< Points to the byte at the end of the queue storage area.  Once more byte i
 134:../freertos/queue.c **** 	int8_t *pcWriteTo;				/*< Points to the free next place in the storage area. */
 135:../freertos/queue.c **** 
 136:../freertos/queue.c **** 	union							/* Use of a union is an exception to the coding standard to ensure two mutually exclus
 137:../freertos/queue.c **** 	{
 138:../freertos/queue.c **** 		int8_t *pcReadFrom;			/*< Points to the last place that a queued item was read from when the stru
 139:../freertos/queue.c **** 		UBaseType_t uxRecursiveCallCount;/*< Maintains a count of the number of times a recursive mutex h
 140:../freertos/queue.c **** 	} u;
 141:../freertos/queue.c **** 
 142:../freertos/queue.c **** 	List_t xTasksWaitingToSend;		/*< List of tasks that are blocked waiting to post onto this queue.  
 143:../freertos/queue.c **** 	List_t xTasksWaitingToReceive;	/*< List of tasks that are blocked waiting to read from this queue.
 144:../freertos/queue.c **** 
 145:../freertos/queue.c **** 	volatile UBaseType_t uxMessagesWaiting;/*< The number of items currently in the queue. */
 146:../freertos/queue.c **** 	UBaseType_t uxLength;			/*< The length of the queue defined as the number of items it will hold, n
 147:../freertos/queue.c **** 	UBaseType_t uxItemSize;			/*< The size of each items that the queue will hold. */
 148:../freertos/queue.c **** 
 149:../freertos/queue.c **** 	volatile int8_t cRxLock;		/*< Stores the number of items received from the queue (removed from the
 150:../freertos/queue.c **** 	volatile int8_t cTxLock;		/*< Stores the number of items transmitted to the queue (added to the qu
 151:../freertos/queue.c **** 
 152:../freertos/queue.c **** 	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 153:../freertos/queue.c **** 		uint8_t ucStaticallyAllocated;	/*< Set to pdTRUE if the memory used by the queue was statically a
 154:../freertos/queue.c **** 	#endif
 155:../freertos/queue.c **** 
 156:../freertos/queue.c **** 	#if ( configUSE_QUEUE_SETS == 1 )
 157:../freertos/queue.c **** 		struct QueueDefinition *pxQueueSetContainer;
 158:../freertos/queue.c **** 	#endif
 159:../freertos/queue.c **** 
 160:../freertos/queue.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 161:../freertos/queue.c **** 		UBaseType_t uxQueueNumber;
 162:../freertos/queue.c **** 		uint8_t ucQueueType;
 163:../freertos/queue.c **** 	#endif
 164:../freertos/queue.c **** 
 165:../freertos/queue.c **** } xQUEUE;
 166:../freertos/queue.c **** 
 167:../freertos/queue.c **** /* The old xQUEUE name is maintained above then typedefed to the new Queue_t
 168:../freertos/queue.c **** name below to enable the use of older kernel aware debuggers. */
 169:../freertos/queue.c **** typedef xQUEUE Queue_t;
 170:../freertos/queue.c **** 
 171:../freertos/queue.c **** /*-----------------------------------------------------------*/
 172:../freertos/queue.c **** 
 173:../freertos/queue.c **** /*
 174:../freertos/queue.c ****  * The queue registry is just a means for kernel aware debuggers to locate
 175:../freertos/queue.c ****  * queue structures.  It has no other purpose so is an optional component.
 176:../freertos/queue.c ****  */
 177:../freertos/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
 178:../freertos/queue.c **** 
 179:../freertos/queue.c **** 	/* The type stored within the queue registry array.  This allows a name
 180:../freertos/queue.c **** 	to be assigned to each queue making kernel aware debugging a little
 181:../freertos/queue.c **** 	more user friendly. */
 182:../freertos/queue.c **** 	typedef struct QUEUE_REGISTRY_ITEM
 183:../freertos/queue.c **** 	{
 184:../freertos/queue.c **** 		const char *pcQueueName; /*lint !e971 Unqualified char types are allowed for strings and single c
 185:../freertos/queue.c **** 		QueueHandle_t xHandle;
 186:../freertos/queue.c **** 	} xQueueRegistryItem;
 187:../freertos/queue.c **** 
 188:../freertos/queue.c **** 	/* The old xQueueRegistryItem name is maintained above then typedefed to the
 189:../freertos/queue.c **** 	new xQueueRegistryItem name below to enable the use of older kernel aware
 190:../freertos/queue.c **** 	debuggers. */
 191:../freertos/queue.c **** 	typedef xQueueRegistryItem QueueRegistryItem_t;
 192:../freertos/queue.c **** 
 193:../freertos/queue.c **** 	/* The queue registry is simply an array of QueueRegistryItem_t structures.
 194:../freertos/queue.c **** 	The pcQueueName member of a structure being NULL is indicative of the
 195:../freertos/queue.c **** 	array position being vacant. */
 196:../freertos/queue.c **** 	PRIVILEGED_DATA QueueRegistryItem_t xQueueRegistry[ configQUEUE_REGISTRY_SIZE ];
 197:../freertos/queue.c **** 
 198:../freertos/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
 199:../freertos/queue.c **** 
 200:../freertos/queue.c **** /*
 201:../freertos/queue.c ****  * Unlocks a queue locked by a call to prvLockQueue.  Locking a queue does not
 202:../freertos/queue.c ****  * prevent an ISR from adding or removing items to the queue, but does prevent
 203:../freertos/queue.c ****  * an ISR from removing tasks from the queue event lists.  If an ISR finds a
 204:../freertos/queue.c ****  * queue is locked it will instead increment the appropriate queue lock count
 205:../freertos/queue.c ****  * to indicate that a task may require unblocking.  When the queue in unlocked
 206:../freertos/queue.c ****  * these lock counts are inspected, and the appropriate action taken.
 207:../freertos/queue.c ****  */
 208:../freertos/queue.c **** static void prvUnlockQueue( Queue_t * const pxQueue ) PRIVILEGED_FUNCTION;
 209:../freertos/queue.c **** 
 210:../freertos/queue.c **** /*
 211:../freertos/queue.c ****  * Uses a critical section to determine if there is any data in a queue.
 212:../freertos/queue.c ****  *
 213:../freertos/queue.c ****  * @return pdTRUE if the queue contains no items, otherwise pdFALSE.
 214:../freertos/queue.c ****  */
 215:../freertos/queue.c **** static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;
 216:../freertos/queue.c **** 
 217:../freertos/queue.c **** /*
 218:../freertos/queue.c ****  * Uses a critical section to determine if there is any space in a queue.
 219:../freertos/queue.c ****  *
 220:../freertos/queue.c ****  * @return pdTRUE if there is no space, otherwise pdFALSE;
 221:../freertos/queue.c ****  */
 222:../freertos/queue.c **** static BaseType_t prvIsQueueFull( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;
 223:../freertos/queue.c **** 
 224:../freertos/queue.c **** /*
 225:../freertos/queue.c ****  * Copies an item into the queue, either at the front of the queue or the
 226:../freertos/queue.c ****  * back of the queue.
 227:../freertos/queue.c ****  */
 228:../freertos/queue.c **** static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const Bas
 229:../freertos/queue.c **** 
 230:../freertos/queue.c **** /*
 231:../freertos/queue.c ****  * Copies an item out of a queue.
 232:../freertos/queue.c ****  */
 233:../freertos/queue.c **** static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer ) PRIVILEGED_FUNCT
 234:../freertos/queue.c **** 
 235:../freertos/queue.c **** #if ( configUSE_QUEUE_SETS == 1 )
 236:../freertos/queue.c **** 	/*
 237:../freertos/queue.c **** 	 * Checks to see if a queue is a member of a queue set, and if so, notifies
 238:../freertos/queue.c **** 	 * the queue set that the queue contains data.
 239:../freertos/queue.c **** 	 */
 240:../freertos/queue.c **** 	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue, const BaseType_t xCop
 241:../freertos/queue.c **** #endif
 242:../freertos/queue.c **** 
 243:../freertos/queue.c **** /*
 244:../freertos/queue.c ****  * Called after a Queue_t structure has been allocated either statically or
 245:../freertos/queue.c ****  * dynamically to fill in the structure's members.
 246:../freertos/queue.c ****  */
 247:../freertos/queue.c **** static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, u
 248:../freertos/queue.c **** 
 249:../freertos/queue.c **** /*
 250:../freertos/queue.c ****  * Mutexes are a special type of queue.  When a mutex is created, first the
 251:../freertos/queue.c ****  * queue is created, then prvInitialiseMutex() is called to configure the queue
 252:../freertos/queue.c ****  * as a mutex.
 253:../freertos/queue.c ****  */
 254:../freertos/queue.c **** #if( configUSE_MUTEXES == 1 )
 255:../freertos/queue.c **** 	static void prvInitialiseMutex( Queue_t *pxNewQueue ) PRIVILEGED_FUNCTION;
 256:../freertos/queue.c **** #endif
 257:../freertos/queue.c **** 
 258:../freertos/queue.c **** /*-----------------------------------------------------------*/
 259:../freertos/queue.c **** 
 260:../freertos/queue.c **** /*
 261:../freertos/queue.c ****  * Macro to mark a queue as locked.  Locking a queue prevents an ISR from
 262:../freertos/queue.c ****  * accessing the queue event lists.
 263:../freertos/queue.c ****  */
 264:../freertos/queue.c **** #define prvLockQueue( pxQueue )								\
 265:../freertos/queue.c **** 	taskENTER_CRITICAL();									\
 266:../freertos/queue.c **** 	{														\
 267:../freertos/queue.c **** 		if( ( pxQueue )->cRxLock == queueUNLOCKED )			\
 268:../freertos/queue.c **** 		{													\
 269:../freertos/queue.c **** 			( pxQueue )->cRxLock = queueLOCKED_UNMODIFIED;	\
 270:../freertos/queue.c **** 		}													\
 271:../freertos/queue.c **** 		if( ( pxQueue )->cTxLock == queueUNLOCKED )			\
 272:../freertos/queue.c **** 		{													\
 273:../freertos/queue.c **** 			( pxQueue )->cTxLock = queueLOCKED_UNMODIFIED;	\
 274:../freertos/queue.c **** 		}													\
 275:../freertos/queue.c **** 	}														\
 276:../freertos/queue.c **** 	taskEXIT_CRITICAL()
 277:../freertos/queue.c **** /*-----------------------------------------------------------*/
 278:../freertos/queue.c **** 
 279:../freertos/queue.c **** BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
 280:../freertos/queue.c **** {
  27              		.loc 1 280 0
  28              		.cfi_startproc
  29 0000 80B5     		push	{r7, lr}
  30              		.cfi_def_cfa_offset 8
  31              		.cfi_offset 7, -8
  32              		.cfi_offset 14, -4
  33 0002 84B0     		sub	sp, sp, #16
  34              		.cfi_def_cfa_offset 24
  35 0004 00AF     		add	r7, sp, #0
  36              		.cfi_def_cfa_register 7
  37 0006 7860     		str	r0, [r7, #4]
  38 0008 3960     		str	r1, [r7]
 281:../freertos/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
  39              		.loc 1 281 0
  40 000a 7B68     		ldr	r3, [r7, #4]
  41 000c FB60     		str	r3, [r7, #12]
 282:../freertos/queue.c **** 
 283:../freertos/queue.c **** 	configASSERT( pxQueue );
  42              		.loc 1 283 0
  43 000e FB68     		ldr	r3, [r7, #12]
  44 0010 002B     		cmp	r3, #0
  45 0012 01D1     		bne	.L2
  46              		.loc 1 283 0 is_stmt 0 discriminator 1
  47              	@ 283 "../freertos/queue.c" 1
  48 0014 72B6     		 cpsid i 
  49              	@ 0 "" 2
  50              		.code	16
  51              	.L3:
  52 0016 FEE7     		b	.L3
  53              	.L2:
 284:../freertos/queue.c **** 
 285:../freertos/queue.c **** 	taskENTER_CRITICAL();
  54              		.loc 1 285 0 is_stmt 1
  55 0018 FFF7FEFF 		bl	vPortEnterCritical
 286:../freertos/queue.c **** 	{
 287:../freertos/queue.c **** 		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
  56              		.loc 1 287 0
  57 001c FB68     		ldr	r3, [r7, #12]
  58 001e 1A68     		ldr	r2, [r3]
  59 0020 FB68     		ldr	r3, [r7, #12]
  60 0022 D96B     		ldr	r1, [r3, #60]
  61 0024 FB68     		ldr	r3, [r7, #12]
  62 0026 1B6C     		ldr	r3, [r3, #64]
  63 0028 4B43     		mul	r3, r1
  64 002a D218     		add	r2, r2, r3
  65 002c FB68     		ldr	r3, [r7, #12]
  66 002e 5A60     		str	r2, [r3, #4]
 288:../freertos/queue.c **** 		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
  67              		.loc 1 288 0
  68 0030 FB68     		ldr	r3, [r7, #12]
  69 0032 0022     		mov	r2, #0
  70 0034 9A63     		str	r2, [r3, #56]
 289:../freertos/queue.c **** 		pxQueue->pcWriteTo = pxQueue->pcHead;
  71              		.loc 1 289 0
  72 0036 FB68     		ldr	r3, [r7, #12]
  73 0038 1A68     		ldr	r2, [r3]
  74 003a FB68     		ldr	r3, [r7, #12]
  75 003c 9A60     		str	r2, [r3, #8]
 290:../freertos/queue.c **** 		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue-
  76              		.loc 1 290 0
  77 003e FB68     		ldr	r3, [r7, #12]
  78 0040 1A68     		ldr	r2, [r3]
  79 0042 FB68     		ldr	r3, [r7, #12]
  80 0044 DB6B     		ldr	r3, [r3, #60]
  81 0046 591E     		sub	r1, r3, #1
  82 0048 FB68     		ldr	r3, [r7, #12]
  83 004a 1B6C     		ldr	r3, [r3, #64]
  84 004c 4B43     		mul	r3, r1
  85 004e D218     		add	r2, r2, r3
  86 0050 FB68     		ldr	r3, [r7, #12]
  87 0052 DA60     		str	r2, [r3, #12]
 291:../freertos/queue.c **** 		pxQueue->cRxLock = queueUNLOCKED;
  88              		.loc 1 291 0
  89 0054 FA68     		ldr	r2, [r7, #12]
  90 0056 4423     		mov	r3, #68
  91 0058 FF21     		mov	r1, #255
  92 005a D154     		strb	r1, [r2, r3]
 292:../freertos/queue.c **** 		pxQueue->cTxLock = queueUNLOCKED;
  93              		.loc 1 292 0
  94 005c FA68     		ldr	r2, [r7, #12]
  95 005e 4523     		mov	r3, #69
  96 0060 FF21     		mov	r1, #255
  97 0062 D154     		strb	r1, [r2, r3]
 293:../freertos/queue.c **** 
 294:../freertos/queue.c **** 		if( xNewQueue == pdFALSE )
  98              		.loc 1 294 0
  99 0064 3B68     		ldr	r3, [r7]
 100 0066 002B     		cmp	r3, #0
 101 0068 0ED1     		bne	.L4
 295:../freertos/queue.c **** 		{
 296:../freertos/queue.c **** 			/* If there are tasks blocked waiting to read from the queue, then
 297:../freertos/queue.c **** 			the tasks will remain blocked as after this function exits the queue
 298:../freertos/queue.c **** 			will still be empty.  If there are tasks blocked waiting to write to
 299:../freertos/queue.c **** 			the queue, then one should be unblocked as after this function exits
 300:../freertos/queue.c **** 			it will be possible to write to it. */
 301:../freertos/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 102              		.loc 1 301 0
 103 006a FB68     		ldr	r3, [r7, #12]
 104 006c 1B69     		ldr	r3, [r3, #16]
 105 006e 002B     		cmp	r3, #0
 106 0070 14D0     		beq	.L5
 302:../freertos/queue.c **** 			{
 303:../freertos/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 107              		.loc 1 303 0
 108 0072 FB68     		ldr	r3, [r7, #12]
 109 0074 1033     		add	r3, r3, #16
 110 0076 181C     		mov	r0, r3
 111 0078 FFF7FEFF 		bl	xTaskRemoveFromEventList
 112 007c 031C     		mov	r3, r0
 113 007e 002B     		cmp	r3, #0
 114 0080 0CD0     		beq	.L5
 304:../freertos/queue.c **** 				{
 305:../freertos/queue.c **** 					queueYIELD_IF_USING_PREEMPTION();
 115              		.loc 1 305 0
 116 0082 FFF7FEFF 		bl	vPortYield
 117 0086 09E0     		b	.L5
 118              	.L4:
 306:../freertos/queue.c **** 				}
 307:../freertos/queue.c **** 				else
 308:../freertos/queue.c **** 				{
 309:../freertos/queue.c **** 					mtCOVERAGE_TEST_MARKER();
 310:../freertos/queue.c **** 				}
 311:../freertos/queue.c **** 			}
 312:../freertos/queue.c **** 			else
 313:../freertos/queue.c **** 			{
 314:../freertos/queue.c **** 				mtCOVERAGE_TEST_MARKER();
 315:../freertos/queue.c **** 			}
 316:../freertos/queue.c **** 		}
 317:../freertos/queue.c **** 		else
 318:../freertos/queue.c **** 		{
 319:../freertos/queue.c **** 			/* Ensure the event queues start in the correct state. */
 320:../freertos/queue.c **** 			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 119              		.loc 1 320 0
 120 0088 FB68     		ldr	r3, [r7, #12]
 121 008a 1033     		add	r3, r3, #16
 122 008c 181C     		mov	r0, r3
 123 008e FFF7FEFF 		bl	vListInitialise
 321:../freertos/queue.c **** 			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 124              		.loc 1 321 0
 125 0092 FB68     		ldr	r3, [r7, #12]
 126 0094 2433     		add	r3, r3, #36
 127 0096 181C     		mov	r0, r3
 128 0098 FFF7FEFF 		bl	vListInitialise
 129              	.L5:
 322:../freertos/queue.c **** 		}
 323:../freertos/queue.c **** 	}
 324:../freertos/queue.c **** 	taskEXIT_CRITICAL();
 130              		.loc 1 324 0
 131 009c FFF7FEFF 		bl	vPortExitCritical
 325:../freertos/queue.c **** 
 326:../freertos/queue.c **** 	/* A value is returned for calling semantic consistency with previous
 327:../freertos/queue.c **** 	versions. */
 328:../freertos/queue.c **** 	return pdPASS;
 132              		.loc 1 328 0
 133 00a0 0123     		mov	r3, #1
 329:../freertos/queue.c **** }
 134              		.loc 1 329 0
 135 00a2 181C     		mov	r0, r3
 136 00a4 BD46     		mov	sp, r7
 137 00a6 04B0     		add	sp, sp, #16
 138              		@ sp needed
 139 00a8 80BD     		pop	{r7, pc}
 140              		.cfi_endproc
 141              	.LFE0:
 143 00aa C046     		.section	.text.xQueueGenericCreate,"ax",%progbits
 144              		.align	2
 145              		.global	xQueueGenericCreate
 146              		.code	16
 147              		.thumb_func
 149              	xQueueGenericCreate:
 150              	.LFB1:
 330:../freertos/queue.c **** /*-----------------------------------------------------------*/
 331:../freertos/queue.c **** 
 332:../freertos/queue.c **** #if( configSUPPORT_STATIC_ALLOCATION == 1 )
 333:../freertos/queue.c **** 
 334:../freertos/queue.c **** 	QueueHandle_t xQueueGenericCreateStatic( const UBaseType_t uxQueueLength, const UBaseType_t uxItem
 335:../freertos/queue.c **** 	{
 336:../freertos/queue.c **** 	Queue_t *pxNewQueue;
 337:../freertos/queue.c **** 
 338:../freertos/queue.c **** 		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 339:../freertos/queue.c **** 
 340:../freertos/queue.c **** 		/* The StaticQueue_t structure and the queue storage area must be
 341:../freertos/queue.c **** 		supplied. */
 342:../freertos/queue.c **** 		configASSERT( pxStaticQueue != NULL );
 343:../freertos/queue.c **** 
 344:../freertos/queue.c **** 		/* A queue storage area should be provided if the item size is not 0, and
 345:../freertos/queue.c **** 		should not be provided if the item size is 0. */
 346:../freertos/queue.c **** 		configASSERT( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0 ) ) );
 347:../freertos/queue.c **** 		configASSERT( !( ( pucQueueStorage == NULL ) && ( uxItemSize != 0 ) ) );
 348:../freertos/queue.c **** 
 349:../freertos/queue.c **** 		#if( configASSERT_DEFINED == 1 )
 350:../freertos/queue.c **** 		{
 351:../freertos/queue.c **** 			/* Sanity check that the size of the structure used to declare a
 352:../freertos/queue.c **** 			variable of type StaticQueue_t or StaticSemaphore_t equals the size of
 353:../freertos/queue.c **** 			the real queue and semaphore structures. */
 354:../freertos/queue.c **** 			volatile size_t xSize = sizeof( StaticQueue_t );
 355:../freertos/queue.c **** 			configASSERT( xSize == sizeof( Queue_t ) );
 356:../freertos/queue.c **** 		}
 357:../freertos/queue.c **** 		#endif /* configASSERT_DEFINED */
 358:../freertos/queue.c **** 
 359:../freertos/queue.c **** 		/* The address of a statically allocated queue was passed in, use it.
 360:../freertos/queue.c **** 		The address of a statically allocated storage area was also passed in
 361:../freertos/queue.c **** 		but is already set. */
 362:../freertos/queue.c **** 		pxNewQueue = ( Queue_t * ) pxStaticQueue; /*lint !e740 Unusual cast is ok as the structures are d
 363:../freertos/queue.c **** 
 364:../freertos/queue.c **** 		if( pxNewQueue != NULL )
 365:../freertos/queue.c **** 		{
 366:../freertos/queue.c **** 			#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
 367:../freertos/queue.c **** 			{
 368:../freertos/queue.c **** 				/* Queues can be allocated wither statically or dynamically, so
 369:../freertos/queue.c **** 				note this queue was allocated statically in case the queue is
 370:../freertos/queue.c **** 				later deleted. */
 371:../freertos/queue.c **** 				pxNewQueue->ucStaticallyAllocated = pdTRUE;
 372:../freertos/queue.c **** 			}
 373:../freertos/queue.c **** 			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
 374:../freertos/queue.c **** 
 375:../freertos/queue.c **** 			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
 376:../freertos/queue.c **** 		}
 377:../freertos/queue.c **** 
 378:../freertos/queue.c **** 		return pxNewQueue;
 379:../freertos/queue.c **** 	}
 380:../freertos/queue.c **** 
 381:../freertos/queue.c **** #endif /* configSUPPORT_STATIC_ALLOCATION */
 382:../freertos/queue.c **** /*-----------------------------------------------------------*/
 383:../freertos/queue.c **** 
 384:../freertos/queue.c **** #if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
 385:../freertos/queue.c **** 
 386:../freertos/queue.c **** 	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, 
 387:../freertos/queue.c **** 	{
 151              		.loc 1 387 0
 152              		.cfi_startproc
 153 0000 90B5     		push	{r4, r7, lr}
 154              		.cfi_def_cfa_offset 12
 155              		.cfi_offset 4, -12
 156              		.cfi_offset 7, -8
 157              		.cfi_offset 14, -4
 158 0002 8BB0     		sub	sp, sp, #44
 159              		.cfi_def_cfa_offset 56
 160 0004 02AF     		add	r7, sp, #8
 161              		.cfi_def_cfa 7, 48
 162 0006 F860     		str	r0, [r7, #12]
 163 0008 B960     		str	r1, [r7, #8]
 164 000a FB1D     		add	r3, r7, #7
 165 000c 1A70     		strb	r2, [r3]
 388:../freertos/queue.c **** 	Queue_t *pxNewQueue;
 389:../freertos/queue.c **** 	size_t xQueueSizeInBytes;
 390:../freertos/queue.c **** 	uint8_t *pucQueueStorage;
 391:../freertos/queue.c **** 
 392:../freertos/queue.c **** 		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 166              		.loc 1 392 0
 167 000e FB68     		ldr	r3, [r7, #12]
 168 0010 002B     		cmp	r3, #0
 169 0012 01D1     		bne	.L8
 170              		.loc 1 392 0 is_stmt 0 discriminator 1
 171              	@ 392 "../freertos/queue.c" 1
 172 0014 72B6     		 cpsid i 
 173              	@ 0 "" 2
 174              		.code	16
 175              	.L9:
 176 0016 FEE7     		b	.L9
 177              	.L8:
 393:../freertos/queue.c **** 
 394:../freertos/queue.c **** 		if( uxItemSize == ( UBaseType_t ) 0 )
 178              		.loc 1 394 0 is_stmt 1
 179 0018 BB68     		ldr	r3, [r7, #8]
 180 001a 002B     		cmp	r3, #0
 181 001c 02D1     		bne	.L10
 395:../freertos/queue.c **** 		{
 396:../freertos/queue.c **** 			/* There is not going to be a queue storage area. */
 397:../freertos/queue.c **** 			xQueueSizeInBytes = ( size_t ) 0;
 182              		.loc 1 397 0
 183 001e 0023     		mov	r3, #0
 184 0020 FB61     		str	r3, [r7, #28]
 185 0022 03E0     		b	.L11
 186              	.L10:
 398:../freertos/queue.c **** 		}
 399:../freertos/queue.c **** 		else
 400:../freertos/queue.c **** 		{
 401:../freertos/queue.c **** 			/* Allocate enough space to hold the maximum number of items that
 402:../freertos/queue.c **** 			can be in the queue at any time. */
 403:../freertos/queue.c **** 			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as t
 187              		.loc 1 403 0
 188 0024 FB68     		ldr	r3, [r7, #12]
 189 0026 BA68     		ldr	r2, [r7, #8]
 190 0028 5343     		mul	r3, r2
 191 002a FB61     		str	r3, [r7, #28]
 192              	.L11:
 404:../freertos/queue.c **** 		}
 405:../freertos/queue.c **** 
 406:../freertos/queue.c **** 		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
 193              		.loc 1 406 0
 194 002c FB69     		ldr	r3, [r7, #28]
 195 002e 5033     		add	r3, r3, #80
 196 0030 181C     		mov	r0, r3
 197 0032 FFF7FEFF 		bl	pvPortMalloc
 198 0036 031C     		mov	r3, r0
 199 0038 BB61     		str	r3, [r7, #24]
 407:../freertos/queue.c **** 
 408:../freertos/queue.c **** 		if( pxNewQueue != NULL )
 200              		.loc 1 408 0
 201 003a BB69     		ldr	r3, [r7, #24]
 202 003c 002B     		cmp	r3, #0
 203 003e 0BD0     		beq	.L12
 409:../freertos/queue.c **** 		{
 410:../freertos/queue.c **** 			/* Jump past the queue structure to find the location of the queue
 411:../freertos/queue.c **** 			storage area. */
 412:../freertos/queue.c **** 			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
 204              		.loc 1 412 0
 205 0040 BB69     		ldr	r3, [r7, #24]
 206 0042 5033     		add	r3, r3, #80
 207 0044 7B61     		str	r3, [r7, #20]
 413:../freertos/queue.c **** 
 414:../freertos/queue.c **** 			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
 415:../freertos/queue.c **** 			{
 416:../freertos/queue.c **** 				/* Queues can be created either statically or dynamically, so
 417:../freertos/queue.c **** 				note this task was created dynamically in case it is later
 418:../freertos/queue.c **** 				deleted. */
 419:../freertos/queue.c **** 				pxNewQueue->ucStaticallyAllocated = pdFALSE;
 420:../freertos/queue.c **** 			}
 421:../freertos/queue.c **** 			#endif /* configSUPPORT_STATIC_ALLOCATION */
 422:../freertos/queue.c **** 
 423:../freertos/queue.c **** 			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
 208              		.loc 1 423 0
 209 0046 F868     		ldr	r0, [r7, #12]
 210 0048 B968     		ldr	r1, [r7, #8]
 211 004a 7A69     		ldr	r2, [r7, #20]
 212 004c FB1D     		add	r3, r7, #7
 213 004e 1B78     		ldrb	r3, [r3]
 214 0050 BC69     		ldr	r4, [r7, #24]
 215 0052 0094     		str	r4, [sp]
 216 0054 FFF7FEFF 		bl	prvInitialiseNewQueue
 217              	.L12:
 424:../freertos/queue.c **** 		}
 425:../freertos/queue.c **** 
 426:../freertos/queue.c **** 		return pxNewQueue;
 218              		.loc 1 426 0
 219 0058 BB69     		ldr	r3, [r7, #24]
 427:../freertos/queue.c **** 	}
 220              		.loc 1 427 0
 221 005a 181C     		mov	r0, r3
 222 005c BD46     		mov	sp, r7
 223 005e 09B0     		add	sp, sp, #36
 224              		@ sp needed
 225 0060 90BD     		pop	{r4, r7, pc}
 226              		.cfi_endproc
 227              	.LFE1:
 229 0062 C046     		.section	.text.prvInitialiseNewQueue,"ax",%progbits
 230              		.align	2
 231              		.code	16
 232              		.thumb_func
 234              	prvInitialiseNewQueue:
 235              	.LFB2:
 428:../freertos/queue.c **** 
 429:../freertos/queue.c **** #endif /* configSUPPORT_STATIC_ALLOCATION */
 430:../freertos/queue.c **** /*-----------------------------------------------------------*/
 431:../freertos/queue.c **** 
 432:../freertos/queue.c **** static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, u
 433:../freertos/queue.c **** {
 236              		.loc 1 433 0
 237              		.cfi_startproc
 238 0000 80B5     		push	{r7, lr}
 239              		.cfi_def_cfa_offset 8
 240              		.cfi_offset 7, -8
 241              		.cfi_offset 14, -4
 242 0002 84B0     		sub	sp, sp, #16
 243              		.cfi_def_cfa_offset 24
 244 0004 00AF     		add	r7, sp, #0
 245              		.cfi_def_cfa_register 7
 246 0006 F860     		str	r0, [r7, #12]
 247 0008 B960     		str	r1, [r7, #8]
 248 000a 7A60     		str	r2, [r7, #4]
 249 000c 1A1C     		mov	r2, r3
 250 000e FB1C     		add	r3, r7, #3
 251 0010 1A70     		strb	r2, [r3]
 434:../freertos/queue.c **** 	/* Remove compiler warnings about unused parameters should
 435:../freertos/queue.c **** 	configUSE_TRACE_FACILITY not be set to 1. */
 436:../freertos/queue.c **** 	( void ) ucQueueType;
 437:../freertos/queue.c **** 
 438:../freertos/queue.c **** 	if( uxItemSize == ( UBaseType_t ) 0 )
 252              		.loc 1 438 0
 253 0012 BB68     		ldr	r3, [r7, #8]
 254 0014 002B     		cmp	r3, #0
 255 0016 03D1     		bne	.L15
 439:../freertos/queue.c **** 	{
 440:../freertos/queue.c **** 		/* No RAM was allocated for the queue storage area, but PC head cannot
 441:../freertos/queue.c **** 		be set to NULL because NULL is used as a key to say the queue is used as
 442:../freertos/queue.c **** 		a mutex.  Therefore just set pcHead to point to the queue as a benign
 443:../freertos/queue.c **** 		value that is known to be within the memory map. */
 444:../freertos/queue.c **** 		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 256              		.loc 1 444 0
 257 0018 BB69     		ldr	r3, [r7, #24]
 258 001a BA69     		ldr	r2, [r7, #24]
 259 001c 1A60     		str	r2, [r3]
 260 001e 02E0     		b	.L16
 261              	.L15:
 445:../freertos/queue.c **** 	}
 446:../freertos/queue.c **** 	else
 447:../freertos/queue.c **** 	{
 448:../freertos/queue.c **** 		/* Set the head to the start of the queue storage area. */
 449:../freertos/queue.c **** 		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 262              		.loc 1 449 0
 263 0020 BB69     		ldr	r3, [r7, #24]
 264 0022 7A68     		ldr	r2, [r7, #4]
 265 0024 1A60     		str	r2, [r3]
 266              	.L16:
 450:../freertos/queue.c **** 	}
 451:../freertos/queue.c **** 
 452:../freertos/queue.c **** 	/* Initialise the queue members as described where the queue type is
 453:../freertos/queue.c **** 	defined. */
 454:../freertos/queue.c **** 	pxNewQueue->uxLength = uxQueueLength;
 267              		.loc 1 454 0
 268 0026 BB69     		ldr	r3, [r7, #24]
 269 0028 FA68     		ldr	r2, [r7, #12]
 270 002a DA63     		str	r2, [r3, #60]
 455:../freertos/queue.c **** 	pxNewQueue->uxItemSize = uxItemSize;
 271              		.loc 1 455 0
 272 002c BB69     		ldr	r3, [r7, #24]
 273 002e BA68     		ldr	r2, [r7, #8]
 274 0030 1A64     		str	r2, [r3, #64]
 456:../freertos/queue.c **** 	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 275              		.loc 1 456 0
 276 0032 BB69     		ldr	r3, [r7, #24]
 277 0034 181C     		mov	r0, r3
 278 0036 0121     		mov	r1, #1
 279 0038 FFF7FEFF 		bl	xQueueGenericReset
 457:../freertos/queue.c **** 
 458:../freertos/queue.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 459:../freertos/queue.c **** 	{
 460:../freertos/queue.c **** 		pxNewQueue->ucQueueType = ucQueueType;
 280              		.loc 1 460 0
 281 003c BA69     		ldr	r2, [r7, #24]
 282 003e F91C     		add	r1, r7, #3
 283 0040 4C23     		mov	r3, #76
 284 0042 0978     		ldrb	r1, [r1]
 285 0044 D154     		strb	r1, [r2, r3]
 461:../freertos/queue.c **** 	}
 462:../freertos/queue.c **** 	#endif /* configUSE_TRACE_FACILITY */
 463:../freertos/queue.c **** 
 464:../freertos/queue.c **** 	#if( configUSE_QUEUE_SETS == 1 )
 465:../freertos/queue.c **** 	{
 466:../freertos/queue.c **** 		pxNewQueue->pxQueueSetContainer = NULL;
 467:../freertos/queue.c **** 	}
 468:../freertos/queue.c **** 	#endif /* configUSE_QUEUE_SETS */
 469:../freertos/queue.c **** 
 470:../freertos/queue.c **** 	traceQUEUE_CREATE( pxNewQueue );
 471:../freertos/queue.c **** }
 286              		.loc 1 471 0
 287 0046 BD46     		mov	sp, r7
 288 0048 04B0     		add	sp, sp, #16
 289              		@ sp needed
 290 004a 80BD     		pop	{r7, pc}
 291              		.cfi_endproc
 292              	.LFE2:
 294              		.section	.text.prvInitialiseMutex,"ax",%progbits
 295              		.align	2
 296              		.code	16
 297              		.thumb_func
 299              	prvInitialiseMutex:
 300              	.LFB3:
 472:../freertos/queue.c **** /*-----------------------------------------------------------*/
 473:../freertos/queue.c **** 
 474:../freertos/queue.c **** #if( configUSE_MUTEXES == 1 )
 475:../freertos/queue.c **** 
 476:../freertos/queue.c **** 	static void prvInitialiseMutex( Queue_t *pxNewQueue )
 477:../freertos/queue.c **** 	{
 301              		.loc 1 477 0
 302              		.cfi_startproc
 303 0000 80B5     		push	{r7, lr}
 304              		.cfi_def_cfa_offset 8
 305              		.cfi_offset 7, -8
 306              		.cfi_offset 14, -4
 307 0002 82B0     		sub	sp, sp, #8
 308              		.cfi_def_cfa_offset 16
 309 0004 00AF     		add	r7, sp, #0
 310              		.cfi_def_cfa_register 7
 311 0006 7860     		str	r0, [r7, #4]
 478:../freertos/queue.c **** 		if( pxNewQueue != NULL )
 312              		.loc 1 478 0
 313 0008 7B68     		ldr	r3, [r7, #4]
 314 000a 002B     		cmp	r3, #0
 315 000c 0FD0     		beq	.L17
 479:../freertos/queue.c **** 		{
 480:../freertos/queue.c **** 			/* The queue create function will set all the queue structure members
 481:../freertos/queue.c **** 			correctly for a generic queue, but this function is creating a
 482:../freertos/queue.c **** 			mutex.  Overwrite those members that need to be set differently -
 483:../freertos/queue.c **** 			in particular the information required for priority inheritance. */
 484:../freertos/queue.c **** 			pxNewQueue->pxMutexHolder = NULL;
 316              		.loc 1 484 0
 317 000e 7B68     		ldr	r3, [r7, #4]
 318 0010 0022     		mov	r2, #0
 319 0012 5A60     		str	r2, [r3, #4]
 485:../freertos/queue.c **** 			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 320              		.loc 1 485 0
 321 0014 7B68     		ldr	r3, [r7, #4]
 322 0016 0022     		mov	r2, #0
 323 0018 1A60     		str	r2, [r3]
 486:../freertos/queue.c **** 
 487:../freertos/queue.c **** 			/* In case this is a recursive mutex. */
 488:../freertos/queue.c **** 			pxNewQueue->u.uxRecursiveCallCount = 0;
 324              		.loc 1 488 0
 325 001a 7B68     		ldr	r3, [r7, #4]
 326 001c 0022     		mov	r2, #0
 327 001e DA60     		str	r2, [r3, #12]
 489:../freertos/queue.c **** 
 490:../freertos/queue.c **** 			traceCREATE_MUTEX( pxNewQueue );
 491:../freertos/queue.c **** 
 492:../freertos/queue.c **** 			/* Start with the semaphore in the expected state. */
 493:../freertos/queue.c **** 			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
 328              		.loc 1 493 0
 329 0020 7B68     		ldr	r3, [r7, #4]
 330 0022 181C     		mov	r0, r3
 331 0024 0021     		mov	r1, #0
 332 0026 0022     		mov	r2, #0
 333 0028 0023     		mov	r3, #0
 334 002a FFF7FEFF 		bl	xQueueGenericSend
 335              	.L17:
 494:../freertos/queue.c **** 		}
 495:../freertos/queue.c **** 		else
 496:../freertos/queue.c **** 		{
 497:../freertos/queue.c **** 			traceCREATE_MUTEX_FAILED();
 498:../freertos/queue.c **** 		}
 499:../freertos/queue.c **** 	}
 336              		.loc 1 499 0
 337 002e BD46     		mov	sp, r7
 338 0030 02B0     		add	sp, sp, #8
 339              		@ sp needed
 340 0032 80BD     		pop	{r7, pc}
 341              		.cfi_endproc
 342              	.LFE3:
 344              		.section	.text.xQueueCreateMutex,"ax",%progbits
 345              		.align	2
 346              		.global	xQueueCreateMutex
 347              		.code	16
 348              		.thumb_func
 350              	xQueueCreateMutex:
 351              	.LFB4:
 500:../freertos/queue.c **** 
 501:../freertos/queue.c **** #endif /* configUSE_MUTEXES */
 502:../freertos/queue.c **** /*-----------------------------------------------------------*/
 503:../freertos/queue.c **** 
 504:../freertos/queue.c **** #if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 505:../freertos/queue.c **** 
 506:../freertos/queue.c **** 	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
 507:../freertos/queue.c **** 	{
 352              		.loc 1 507 0
 353              		.cfi_startproc
 354 0000 80B5     		push	{r7, lr}
 355              		.cfi_def_cfa_offset 8
 356              		.cfi_offset 7, -8
 357              		.cfi_offset 14, -4
 358 0002 86B0     		sub	sp, sp, #24
 359              		.cfi_def_cfa_offset 32
 360 0004 00AF     		add	r7, sp, #0
 361              		.cfi_def_cfa_register 7
 362 0006 021C     		mov	r2, r0
 363 0008 FB1D     		add	r3, r7, #7
 364 000a 1A70     		strb	r2, [r3]
 508:../freertos/queue.c **** 	Queue_t *pxNewQueue;
 509:../freertos/queue.c **** 	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
 365              		.loc 1 509 0
 366 000c 0123     		mov	r3, #1
 367 000e 7B61     		str	r3, [r7, #20]
 368 0010 0023     		mov	r3, #0
 369 0012 3B61     		str	r3, [r7, #16]
 510:../freertos/queue.c **** 
 511:../freertos/queue.c **** 		pxNewQueue = ( Queue_t * ) xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
 370              		.loc 1 511 0
 371 0014 7969     		ldr	r1, [r7, #20]
 372 0016 3A69     		ldr	r2, [r7, #16]
 373 0018 FB1D     		add	r3, r7, #7
 374 001a 1B78     		ldrb	r3, [r3]
 375 001c 081C     		mov	r0, r1
 376 001e 111C     		mov	r1, r2
 377 0020 1A1C     		mov	r2, r3
 378 0022 FFF7FEFF 		bl	xQueueGenericCreate
 379 0026 031C     		mov	r3, r0
 380 0028 FB60     		str	r3, [r7, #12]
 512:../freertos/queue.c **** 		prvInitialiseMutex( pxNewQueue );
 381              		.loc 1 512 0
 382 002a FB68     		ldr	r3, [r7, #12]
 383 002c 181C     		mov	r0, r3
 384 002e FFF7FEFF 		bl	prvInitialiseMutex
 513:../freertos/queue.c **** 
 514:../freertos/queue.c **** 		return pxNewQueue;
 385              		.loc 1 514 0
 386 0032 FB68     		ldr	r3, [r7, #12]
 515:../freertos/queue.c **** 	}
 387              		.loc 1 515 0
 388 0034 181C     		mov	r0, r3
 389 0036 BD46     		mov	sp, r7
 390 0038 06B0     		add	sp, sp, #24
 391              		@ sp needed
 392 003a 80BD     		pop	{r7, pc}
 393              		.cfi_endproc
 394              	.LFE4:
 396              		.section	.text.xQueueGiveMutexRecursive,"ax",%progbits
 397              		.align	2
 398              		.global	xQueueGiveMutexRecursive
 399              		.code	16
 400              		.thumb_func
 402              	xQueueGiveMutexRecursive:
 403              	.LFB5:
 516:../freertos/queue.c **** 
 517:../freertos/queue.c **** #endif /* configUSE_MUTEXES */
 518:../freertos/queue.c **** /*-----------------------------------------------------------*/
 519:../freertos/queue.c **** 
 520:../freertos/queue.c **** #if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
 521:../freertos/queue.c **** 
 522:../freertos/queue.c **** 	QueueHandle_t xQueueCreateMutexStatic( const uint8_t ucQueueType, StaticQueue_t *pxStaticQueue )
 523:../freertos/queue.c **** 	{
 524:../freertos/queue.c **** 	Queue_t *pxNewQueue;
 525:../freertos/queue.c **** 	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
 526:../freertos/queue.c **** 
 527:../freertos/queue.c **** 		/* Prevent compiler warnings about unused parameters if
 528:../freertos/queue.c **** 		configUSE_TRACE_FACILITY does not equal 1. */
 529:../freertos/queue.c **** 		( void ) ucQueueType;
 530:../freertos/queue.c **** 
 531:../freertos/queue.c **** 		pxNewQueue = ( Queue_t * ) xQueueGenericCreateStatic( uxMutexLength, uxMutexSize, NULL, pxStaticQ
 532:../freertos/queue.c **** 		prvInitialiseMutex( pxNewQueue );
 533:../freertos/queue.c **** 
 534:../freertos/queue.c **** 		return pxNewQueue;
 535:../freertos/queue.c **** 	}
 536:../freertos/queue.c **** 
 537:../freertos/queue.c **** #endif /* configUSE_MUTEXES */
 538:../freertos/queue.c **** /*-----------------------------------------------------------*/
 539:../freertos/queue.c **** 
 540:../freertos/queue.c **** #if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
 541:../freertos/queue.c **** 
 542:../freertos/queue.c **** 	void* xQueueGetMutexHolder( QueueHandle_t xSemaphore )
 543:../freertos/queue.c **** 	{
 544:../freertos/queue.c **** 	void *pxReturn;
 545:../freertos/queue.c **** 
 546:../freertos/queue.c **** 		/* This function is called by xSemaphoreGetMutexHolder(), and should not
 547:../freertos/queue.c **** 		be called directly.  Note:  This is a good way of determining if the
 548:../freertos/queue.c **** 		calling task is the mutex holder, but not a good way of determining the
 549:../freertos/queue.c **** 		identity of the mutex holder, as the holder may change between the
 550:../freertos/queue.c **** 		following critical section exiting and the function returning. */
 551:../freertos/queue.c **** 		taskENTER_CRITICAL();
 552:../freertos/queue.c **** 		{
 553:../freertos/queue.c **** 			if( ( ( Queue_t * ) xSemaphore )->uxQueueType == queueQUEUE_IS_MUTEX )
 554:../freertos/queue.c **** 			{
 555:../freertos/queue.c **** 				pxReturn = ( void * ) ( ( Queue_t * ) xSemaphore )->pxMutexHolder;
 556:../freertos/queue.c **** 			}
 557:../freertos/queue.c **** 			else
 558:../freertos/queue.c **** 			{
 559:../freertos/queue.c **** 				pxReturn = NULL;
 560:../freertos/queue.c **** 			}
 561:../freertos/queue.c **** 		}
 562:../freertos/queue.c **** 		taskEXIT_CRITICAL();
 563:../freertos/queue.c **** 
 564:../freertos/queue.c **** 		return pxReturn;
 565:../freertos/queue.c **** 	} /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
 566:../freertos/queue.c **** 
 567:../freertos/queue.c **** #endif
 568:../freertos/queue.c **** /*-----------------------------------------------------------*/
 569:../freertos/queue.c **** 
 570:../freertos/queue.c **** #if ( configUSE_RECURSIVE_MUTEXES == 1 )
 571:../freertos/queue.c **** 
 572:../freertos/queue.c **** 	BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
 573:../freertos/queue.c **** 	{
 404              		.loc 1 573 0
 405              		.cfi_startproc
 406 0000 90B5     		push	{r4, r7, lr}
 407              		.cfi_def_cfa_offset 12
 408              		.cfi_offset 4, -12
 409              		.cfi_offset 7, -8
 410              		.cfi_offset 14, -4
 411 0002 85B0     		sub	sp, sp, #20
 412              		.cfi_def_cfa_offset 32
 413 0004 00AF     		add	r7, sp, #0
 414              		.cfi_def_cfa_register 7
 415 0006 7860     		str	r0, [r7, #4]
 574:../freertos/queue.c **** 	BaseType_t xReturn;
 575:../freertos/queue.c **** 	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 416              		.loc 1 575 0
 417 0008 7B68     		ldr	r3, [r7, #4]
 418 000a BB60     		str	r3, [r7, #8]
 576:../freertos/queue.c **** 
 577:../freertos/queue.c **** 		configASSERT( pxMutex );
 419              		.loc 1 577 0
 420 000c BB68     		ldr	r3, [r7, #8]
 421 000e 002B     		cmp	r3, #0
 422 0010 01D1     		bne	.L22
 423              		.loc 1 577 0 is_stmt 0 discriminator 1
 424              	@ 577 "../freertos/queue.c" 1
 425 0012 72B6     		 cpsid i 
 426              	@ 0 "" 2
 427              		.code	16
 428              	.L23:
 429 0014 FEE7     		b	.L23
 430              	.L22:
 578:../freertos/queue.c **** 
 579:../freertos/queue.c **** 		/* If this is the task that holds the mutex then pxMutexHolder will not
 580:../freertos/queue.c **** 		change outside of this task.  If this task does not hold the mutex then
 581:../freertos/queue.c **** 		pxMutexHolder can never coincidentally equal the tasks handle, and as
 582:../freertos/queue.c **** 		this is the only condition we are interested in it does not matter if
 583:../freertos/queue.c **** 		pxMutexHolder is accessed simultaneously by another task.  Therefore no
 584:../freertos/queue.c **** 		mutual exclusion is required to test the pxMutexHolder variable. */
 585:../freertos/queue.c **** 		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Not a redunda
 431              		.loc 1 585 0 is_stmt 1
 432 0016 BB68     		ldr	r3, [r7, #8]
 433 0018 5C68     		ldr	r4, [r3, #4]
 434 001a FFF7FEFF 		bl	xTaskGetCurrentTaskHandle
 435 001e 031C     		mov	r3, r0
 436 0020 9C42     		cmp	r4, r3
 437 0022 12D1     		bne	.L24
 586:../freertos/queue.c **** 		{
 587:../freertos/queue.c **** 			traceGIVE_MUTEX_RECURSIVE( pxMutex );
 588:../freertos/queue.c **** 
 589:../freertos/queue.c **** 			/* uxRecursiveCallCount cannot be zero if pxMutexHolder is equal to
 590:../freertos/queue.c **** 			the task handle, therefore no underflow check is required.  Also,
 591:../freertos/queue.c **** 			uxRecursiveCallCount is only modified by the mutex holder, and as
 592:../freertos/queue.c **** 			there can only be one, no mutual exclusion is required to modify the
 593:../freertos/queue.c **** 			uxRecursiveCallCount member. */
 594:../freertos/queue.c **** 			( pxMutex->u.uxRecursiveCallCount )--;
 438              		.loc 1 594 0
 439 0024 BB68     		ldr	r3, [r7, #8]
 440 0026 DB68     		ldr	r3, [r3, #12]
 441 0028 5A1E     		sub	r2, r3, #1
 442 002a BB68     		ldr	r3, [r7, #8]
 443 002c DA60     		str	r2, [r3, #12]
 595:../freertos/queue.c **** 
 596:../freertos/queue.c **** 			/* Has the recursive call count unwound to 0? */
 597:../freertos/queue.c **** 			if( pxMutex->u.uxRecursiveCallCount == ( UBaseType_t ) 0 )
 444              		.loc 1 597 0
 445 002e BB68     		ldr	r3, [r7, #8]
 446 0030 DB68     		ldr	r3, [r3, #12]
 447 0032 002B     		cmp	r3, #0
 448 0034 06D1     		bne	.L25
 598:../freertos/queue.c **** 			{
 599:../freertos/queue.c **** 				/* Return the mutex.  This will automatically unblock any other
 600:../freertos/queue.c **** 				task that might be waiting to access the mutex. */
 601:../freertos/queue.c **** 				( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
 449              		.loc 1 601 0
 450 0036 BB68     		ldr	r3, [r7, #8]
 451 0038 181C     		mov	r0, r3
 452 003a 0021     		mov	r1, #0
 453 003c 0022     		mov	r2, #0
 454 003e 0023     		mov	r3, #0
 455 0040 FFF7FEFF 		bl	xQueueGenericSend
 456              	.L25:
 602:../freertos/queue.c **** 			}
 603:../freertos/queue.c **** 			else
 604:../freertos/queue.c **** 			{
 605:../freertos/queue.c **** 				mtCOVERAGE_TEST_MARKER();
 606:../freertos/queue.c **** 			}
 607:../freertos/queue.c **** 
 608:../freertos/queue.c **** 			xReturn = pdPASS;
 457              		.loc 1 608 0 discriminator 1
 458 0044 0123     		mov	r3, #1
 459 0046 FB60     		str	r3, [r7, #12]
 460 0048 01E0     		b	.L26
 461              	.L24:
 609:../freertos/queue.c **** 		}
 610:../freertos/queue.c **** 		else
 611:../freertos/queue.c **** 		{
 612:../freertos/queue.c **** 			/* The mutex cannot be given because the calling task is not the
 613:../freertos/queue.c **** 			holder. */
 614:../freertos/queue.c **** 			xReturn = pdFAIL;
 462              		.loc 1 614 0
 463 004a 0023     		mov	r3, #0
 464 004c FB60     		str	r3, [r7, #12]
 465              	.L26:
 615:../freertos/queue.c **** 
 616:../freertos/queue.c **** 			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
 617:../freertos/queue.c **** 		}
 618:../freertos/queue.c **** 
 619:../freertos/queue.c **** 		return xReturn;
 466              		.loc 1 619 0
 467 004e FB68     		ldr	r3, [r7, #12]
 620:../freertos/queue.c **** 	}
 468              		.loc 1 620 0
 469 0050 181C     		mov	r0, r3
 470 0052 BD46     		mov	sp, r7
 471 0054 05B0     		add	sp, sp, #20
 472              		@ sp needed
 473 0056 90BD     		pop	{r4, r7, pc}
 474              		.cfi_endproc
 475              	.LFE5:
 477              		.section	.text.xQueueTakeMutexRecursive,"ax",%progbits
 478              		.align	2
 479              		.global	xQueueTakeMutexRecursive
 480              		.code	16
 481              		.thumb_func
 483              	xQueueTakeMutexRecursive:
 484              	.LFB6:
 621:../freertos/queue.c **** 
 622:../freertos/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 623:../freertos/queue.c **** /*-----------------------------------------------------------*/
 624:../freertos/queue.c **** 
 625:../freertos/queue.c **** #if ( configUSE_RECURSIVE_MUTEXES == 1 )
 626:../freertos/queue.c **** 
 627:../freertos/queue.c **** 	BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait )
 628:../freertos/queue.c **** 	{
 485              		.loc 1 628 0
 486              		.cfi_startproc
 487 0000 90B5     		push	{r4, r7, lr}
 488              		.cfi_def_cfa_offset 12
 489              		.cfi_offset 4, -12
 490              		.cfi_offset 7, -8
 491              		.cfi_offset 14, -4
 492 0002 85B0     		sub	sp, sp, #20
 493              		.cfi_def_cfa_offset 32
 494 0004 00AF     		add	r7, sp, #0
 495              		.cfi_def_cfa_register 7
 496 0006 7860     		str	r0, [r7, #4]
 497 0008 3960     		str	r1, [r7]
 629:../freertos/queue.c **** 	BaseType_t xReturn;
 630:../freertos/queue.c **** 	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 498              		.loc 1 630 0
 499 000a 7B68     		ldr	r3, [r7, #4]
 500 000c BB60     		str	r3, [r7, #8]
 631:../freertos/queue.c **** 
 632:../freertos/queue.c **** 		configASSERT( pxMutex );
 501              		.loc 1 632 0
 502 000e BB68     		ldr	r3, [r7, #8]
 503 0010 002B     		cmp	r3, #0
 504 0012 01D1     		bne	.L29
 505              		.loc 1 632 0 is_stmt 0 discriminator 1
 506              	@ 632 "../freertos/queue.c" 1
 507 0014 72B6     		 cpsid i 
 508              	@ 0 "" 2
 509              		.code	16
 510              	.L30:
 511 0016 FEE7     		b	.L30
 512              	.L29:
 633:../freertos/queue.c **** 
 634:../freertos/queue.c **** 		/* Comments regarding mutual exclusion as per those within
 635:../freertos/queue.c **** 		xQueueGiveMutexRecursive(). */
 636:../freertos/queue.c **** 
 637:../freertos/queue.c **** 		traceTAKE_MUTEX_RECURSIVE( pxMutex );
 638:../freertos/queue.c **** 
 639:../freertos/queue.c **** 		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Cast is not r
 513              		.loc 1 639 0 is_stmt 1
 514 0018 BB68     		ldr	r3, [r7, #8]
 515 001a 5C68     		ldr	r4, [r3, #4]
 516 001c FFF7FEFF 		bl	xTaskGetCurrentTaskHandle
 517 0020 031C     		mov	r3, r0
 518 0022 9C42     		cmp	r4, r3
 519 0024 07D1     		bne	.L31
 640:../freertos/queue.c **** 		{
 641:../freertos/queue.c **** 			( pxMutex->u.uxRecursiveCallCount )++;
 520              		.loc 1 641 0
 521 0026 BB68     		ldr	r3, [r7, #8]
 522 0028 DB68     		ldr	r3, [r3, #12]
 523 002a 5A1C     		add	r2, r3, #1
 524 002c BB68     		ldr	r3, [r7, #8]
 525 002e DA60     		str	r2, [r3, #12]
 642:../freertos/queue.c **** 			xReturn = pdPASS;
 526              		.loc 1 642 0
 527 0030 0123     		mov	r3, #1
 528 0032 FB60     		str	r3, [r7, #12]
 529 0034 11E0     		b	.L32
 530              	.L31:
 643:../freertos/queue.c **** 		}
 644:../freertos/queue.c **** 		else
 645:../freertos/queue.c **** 		{
 646:../freertos/queue.c **** 			xReturn = xQueueGenericReceive( pxMutex, NULL, xTicksToWait, pdFALSE );
 531              		.loc 1 646 0
 532 0036 BA68     		ldr	r2, [r7, #8]
 533 0038 3B68     		ldr	r3, [r7]
 534 003a 101C     		mov	r0, r2
 535 003c 0021     		mov	r1, #0
 536 003e 1A1C     		mov	r2, r3
 537 0040 0023     		mov	r3, #0
 538 0042 FFF7FEFF 		bl	xQueueGenericReceive
 539 0046 031C     		mov	r3, r0
 540 0048 FB60     		str	r3, [r7, #12]
 647:../freertos/queue.c **** 
 648:../freertos/queue.c **** 			/* pdPASS will only be returned if the mutex was successfully
 649:../freertos/queue.c **** 			obtained.  The calling task may have entered the Blocked state
 650:../freertos/queue.c **** 			before reaching here. */
 651:../freertos/queue.c **** 			if( xReturn != pdFAIL )
 541              		.loc 1 651 0
 542 004a FB68     		ldr	r3, [r7, #12]
 543 004c 002B     		cmp	r3, #0
 544 004e 04D0     		beq	.L32
 652:../freertos/queue.c **** 			{
 653:../freertos/queue.c **** 				( pxMutex->u.uxRecursiveCallCount )++;
 545              		.loc 1 653 0
 546 0050 BB68     		ldr	r3, [r7, #8]
 547 0052 DB68     		ldr	r3, [r3, #12]
 548 0054 5A1C     		add	r2, r3, #1
 549 0056 BB68     		ldr	r3, [r7, #8]
 550 0058 DA60     		str	r2, [r3, #12]
 551              	.L32:
 654:../freertos/queue.c **** 			}
 655:../freertos/queue.c **** 			else
 656:../freertos/queue.c **** 			{
 657:../freertos/queue.c **** 				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
 658:../freertos/queue.c **** 			}
 659:../freertos/queue.c **** 		}
 660:../freertos/queue.c **** 
 661:../freertos/queue.c **** 		return xReturn;
 552              		.loc 1 661 0
 553 005a FB68     		ldr	r3, [r7, #12]
 662:../freertos/queue.c **** 	}
 554              		.loc 1 662 0
 555 005c 181C     		mov	r0, r3
 556 005e BD46     		mov	sp, r7
 557 0060 05B0     		add	sp, sp, #20
 558              		@ sp needed
 559 0062 90BD     		pop	{r4, r7, pc}
 560              		.cfi_endproc
 561              	.LFE6:
 563              		.section	.text.xQueueCreateCountingSemaphore,"ax",%progbits
 564              		.align	2
 565              		.global	xQueueCreateCountingSemaphore
 566              		.code	16
 567              		.thumb_func
 569              	xQueueCreateCountingSemaphore:
 570              	.LFB7:
 663:../freertos/queue.c **** 
 664:../freertos/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 665:../freertos/queue.c **** /*-----------------------------------------------------------*/
 666:../freertos/queue.c **** 
 667:../freertos/queue.c **** #if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
 668:../freertos/queue.c **** 
 669:../freertos/queue.c **** 	QueueHandle_t xQueueCreateCountingSemaphoreStatic( const UBaseType_t uxMaxCount, const UBaseType_t
 670:../freertos/queue.c **** 	{
 671:../freertos/queue.c **** 	QueueHandle_t xHandle;
 672:../freertos/queue.c **** 
 673:../freertos/queue.c **** 		configASSERT( uxMaxCount != 0 );
 674:../freertos/queue.c **** 		configASSERT( uxInitialCount <= uxMaxCount );
 675:../freertos/queue.c **** 
 676:../freertos/queue.c **** 		xHandle = xQueueGenericCreateStatic( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, NULL, pxStatic
 677:../freertos/queue.c **** 
 678:../freertos/queue.c **** 		if( xHandle != NULL )
 679:../freertos/queue.c **** 		{
 680:../freertos/queue.c **** 			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 681:../freertos/queue.c **** 
 682:../freertos/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE();
 683:../freertos/queue.c **** 		}
 684:../freertos/queue.c **** 		else
 685:../freertos/queue.c **** 		{
 686:../freertos/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE_FAILED();
 687:../freertos/queue.c **** 		}
 688:../freertos/queue.c **** 
 689:../freertos/queue.c **** 		return xHandle;
 690:../freertos/queue.c **** 	}
 691:../freertos/queue.c **** 
 692:../freertos/queue.c **** #endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) *
 693:../freertos/queue.c **** /*-----------------------------------------------------------*/
 694:../freertos/queue.c **** 
 695:../freertos/queue.c **** #if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 696:../freertos/queue.c **** 
 697:../freertos/queue.c **** 	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxIni
 698:../freertos/queue.c **** 	{
 571              		.loc 1 698 0
 572              		.cfi_startproc
 573 0000 80B5     		push	{r7, lr}
 574              		.cfi_def_cfa_offset 8
 575              		.cfi_offset 7, -8
 576              		.cfi_offset 14, -4
 577 0002 84B0     		sub	sp, sp, #16
 578              		.cfi_def_cfa_offset 24
 579 0004 00AF     		add	r7, sp, #0
 580              		.cfi_def_cfa_register 7
 581 0006 7860     		str	r0, [r7, #4]
 582 0008 3960     		str	r1, [r7]
 699:../freertos/queue.c **** 	QueueHandle_t xHandle;
 700:../freertos/queue.c **** 
 701:../freertos/queue.c **** 		configASSERT( uxMaxCount != 0 );
 583              		.loc 1 701 0
 584 000a 7B68     		ldr	r3, [r7, #4]
 585 000c 002B     		cmp	r3, #0
 586 000e 01D1     		bne	.L35
 587              		.loc 1 701 0 is_stmt 0 discriminator 1
 588              	@ 701 "../freertos/queue.c" 1
 589 0010 72B6     		 cpsid i 
 590              	@ 0 "" 2
 591              		.code	16
 592              	.L36:
 593 0012 FEE7     		b	.L36
 594              	.L35:
 702:../freertos/queue.c **** 		configASSERT( uxInitialCount <= uxMaxCount );
 595              		.loc 1 702 0 is_stmt 1
 596 0014 3A68     		ldr	r2, [r7]
 597 0016 7B68     		ldr	r3, [r7, #4]
 598 0018 9A42     		cmp	r2, r3
 599 001a 01D9     		bls	.L37
 600              		.loc 1 702 0 is_stmt 0 discriminator 1
 601              	@ 702 "../freertos/queue.c" 1
 602 001c 72B6     		 cpsid i 
 603              	@ 0 "" 2
 604              		.code	16
 605              	.L38:
 606 001e FEE7     		b	.L38
 607              	.L37:
 703:../freertos/queue.c **** 
 704:../freertos/queue.c **** 		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUN
 608              		.loc 1 704 0 is_stmt 1
 609 0020 7B68     		ldr	r3, [r7, #4]
 610 0022 181C     		mov	r0, r3
 611 0024 0021     		mov	r1, #0
 612 0026 0222     		mov	r2, #2
 613 0028 FFF7FEFF 		bl	xQueueGenericCreate
 614 002c 031C     		mov	r3, r0
 615 002e FB60     		str	r3, [r7, #12]
 705:../freertos/queue.c **** 
 706:../freertos/queue.c **** 		if( xHandle != NULL )
 616              		.loc 1 706 0
 617 0030 FB68     		ldr	r3, [r7, #12]
 618 0032 002B     		cmp	r3, #0
 619 0034 02D0     		beq	.L39
 707:../freertos/queue.c **** 		{
 708:../freertos/queue.c **** 			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 620              		.loc 1 708 0
 621 0036 FB68     		ldr	r3, [r7, #12]
 622 0038 3A68     		ldr	r2, [r7]
 623 003a 9A63     		str	r2, [r3, #56]
 624              	.L39:
 709:../freertos/queue.c **** 
 710:../freertos/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE();
 711:../freertos/queue.c **** 		}
 712:../freertos/queue.c **** 		else
 713:../freertos/queue.c **** 		{
 714:../freertos/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE_FAILED();
 715:../freertos/queue.c **** 		}
 716:../freertos/queue.c **** 
 717:../freertos/queue.c **** 		return xHandle;
 625              		.loc 1 717 0
 626 003c FB68     		ldr	r3, [r7, #12]
 718:../freertos/queue.c **** 	}
 627              		.loc 1 718 0
 628 003e 181C     		mov	r0, r3
 629 0040 BD46     		mov	sp, r7
 630 0042 04B0     		add	sp, sp, #16
 631              		@ sp needed
 632 0044 80BD     		pop	{r7, pc}
 633              		.cfi_endproc
 634              	.LFE7:
 636 0046 C046     		.section	.text.xQueueGenericSend,"ax",%progbits
 637              		.align	2
 638              		.global	xQueueGenericSend
 639              		.code	16
 640              		.thumb_func
 642              	xQueueGenericSend:
 643              	.LFB8:
 719:../freertos/queue.c **** 
 720:../freertos/queue.c **** #endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) *
 721:../freertos/queue.c **** /*-----------------------------------------------------------*/
 722:../freertos/queue.c **** 
 723:../freertos/queue.c **** BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xT
 724:../freertos/queue.c **** {
 644              		.loc 1 724 0
 645              		.cfi_startproc
 646 0000 80B5     		push	{r7, lr}
 647              		.cfi_def_cfa_offset 8
 648              		.cfi_offset 7, -8
 649              		.cfi_offset 14, -4
 650 0002 8AB0     		sub	sp, sp, #40
 651              		.cfi_def_cfa_offset 48
 652 0004 00AF     		add	r7, sp, #0
 653              		.cfi_def_cfa_register 7
 654 0006 F860     		str	r0, [r7, #12]
 655 0008 B960     		str	r1, [r7, #8]
 656 000a 7A60     		str	r2, [r7, #4]
 657 000c 3B60     		str	r3, [r7]
 725:../freertos/queue.c **** BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
 658              		.loc 1 725 0
 659 000e 0023     		mov	r3, #0
 660 0010 7B62     		str	r3, [r7, #36]
 726:../freertos/queue.c **** TimeOut_t xTimeOut;
 727:../freertos/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 661              		.loc 1 727 0
 662 0012 FB68     		ldr	r3, [r7, #12]
 663 0014 3B62     		str	r3, [r7, #32]
 728:../freertos/queue.c **** 
 729:../freertos/queue.c **** 	configASSERT( pxQueue );
 664              		.loc 1 729 0
 665 0016 3B6A     		ldr	r3, [r7, #32]
 666 0018 002B     		cmp	r3, #0
 667 001a 01D1     		bne	.L42
 668              		.loc 1 729 0 is_stmt 0 discriminator 1
 669              	@ 729 "../freertos/queue.c" 1
 670 001c 72B6     		 cpsid i 
 671              	@ 0 "" 2
 672              		.code	16
 673              	.L43:
 674 001e FEE7     		b	.L43
 675              	.L42:
 730:../freertos/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 676              		.loc 1 730 0 is_stmt 1
 677 0020 BB68     		ldr	r3, [r7, #8]
 678 0022 002B     		cmp	r3, #0
 679 0024 03D1     		bne	.L44
 680              		.loc 1 730 0 is_stmt 0 discriminator 2
 681 0026 3B6A     		ldr	r3, [r7, #32]
 682 0028 1B6C     		ldr	r3, [r3, #64]
 683 002a 002B     		cmp	r3, #0
 684 002c 01D1     		bne	.L45
 685              	.L44:
 686              		.loc 1 730 0 discriminator 1
 687 002e 0123     		mov	r3, #1
 688 0030 00E0     		b	.L46
 689              	.L45:
 690              		.loc 1 730 0 discriminator 3
 691 0032 0023     		mov	r3, #0
 692              	.L46:
 693              		.loc 1 730 0 discriminator 4
 694 0034 002B     		cmp	r3, #0
 695 0036 01D1     		bne	.L47
 696              		.loc 1 730 0 discriminator 1
 697              	@ 730 "../freertos/queue.c" 1
 698 0038 72B6     		 cpsid i 
 699              	@ 0 "" 2
 700              		.code	16
 701              	.L48:
 702 003a FEE7     		b	.L48
 703              	.L47:
 731:../freertos/queue.c **** 	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 704              		.loc 1 731 0 is_stmt 1
 705 003c 3B68     		ldr	r3, [r7]
 706 003e 022B     		cmp	r3, #2
 707 0040 03D1     		bne	.L49
 708              		.loc 1 731 0 is_stmt 0 discriminator 2
 709 0042 3B6A     		ldr	r3, [r7, #32]
 710 0044 DB6B     		ldr	r3, [r3, #60]
 711 0046 012B     		cmp	r3, #1
 712 0048 01D1     		bne	.L50
 713              	.L49:
 714              		.loc 1 731 0 discriminator 1
 715 004a 0123     		mov	r3, #1
 716 004c 00E0     		b	.L51
 717              	.L50:
 718              		.loc 1 731 0 discriminator 3
 719 004e 0023     		mov	r3, #0
 720              	.L51:
 721              		.loc 1 731 0 discriminator 4
 722 0050 002B     		cmp	r3, #0
 723 0052 01D1     		bne	.L52
 724              		.loc 1 731 0 discriminator 1
 725              	@ 731 "../freertos/queue.c" 1
 726 0054 72B6     		 cpsid i 
 727              	@ 0 "" 2
 728              		.code	16
 729              	.L53:
 730 0056 FEE7     		b	.L53
 731              	.L52:
 732:../freertos/queue.c **** 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
 733:../freertos/queue.c **** 	{
 734:../freertos/queue.c **** 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 )
 732              		.loc 1 734 0 is_stmt 1
 733 0058 FFF7FEFF 		bl	xTaskGetSchedulerState
 734 005c 031C     		mov	r3, r0
 735 005e 002B     		cmp	r3, #0
 736 0060 02D1     		bne	.L54
 737              		.loc 1 734 0 is_stmt 0 discriminator 2
 738 0062 7B68     		ldr	r3, [r7, #4]
 739 0064 002B     		cmp	r3, #0
 740 0066 01D1     		bne	.L55
 741              	.L54:
 742              		.loc 1 734 0 discriminator 1
 743 0068 0123     		mov	r3, #1
 744 006a 00E0     		b	.L56
 745              	.L55:
 746              		.loc 1 734 0 discriminator 3
 747 006c 0023     		mov	r3, #0
 748              	.L56:
 749              		.loc 1 734 0 discriminator 4
 750 006e 002B     		cmp	r3, #0
 751 0070 01D1     		bne	.L57
 752              		.loc 1 734 0 discriminator 1
 753              	@ 734 "../freertos/queue.c" 1
 754 0072 72B6     		 cpsid i 
 755              	@ 0 "" 2
 756              		.code	16
 757              	.L58:
 758 0074 FEE7     		b	.L58
 759              	.L57:
 735:../freertos/queue.c **** 	}
 736:../freertos/queue.c **** 	#endif
 737:../freertos/queue.c **** 
 738:../freertos/queue.c **** 
 739:../freertos/queue.c **** 	/* This function relaxes the coding standard somewhat to allow return
 740:../freertos/queue.c **** 	statements within the function itself.  This is done in the interest
 741:../freertos/queue.c **** 	of execution time efficiency. */
 742:../freertos/queue.c **** 	for( ;; )
 743:../freertos/queue.c **** 	{
 744:../freertos/queue.c **** 		taskENTER_CRITICAL();
 760              		.loc 1 744 0 is_stmt 1
 761 0076 FFF7FEFF 		bl	vPortEnterCritical
 745:../freertos/queue.c **** 		{
 746:../freertos/queue.c **** 			/* Is there room on the queue now?  The running task must be the
 747:../freertos/queue.c **** 			highest priority task wanting to access the queue.  If the head item
 748:../freertos/queue.c **** 			in the queue is to be overwritten then it does not matter if the
 749:../freertos/queue.c **** 			queue is full. */
 750:../freertos/queue.c **** 			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 762              		.loc 1 750 0
 763 007a 3B6A     		ldr	r3, [r7, #32]
 764 007c 9A6B     		ldr	r2, [r3, #56]
 765 007e 3B6A     		ldr	r3, [r7, #32]
 766 0080 DB6B     		ldr	r3, [r3, #60]
 767 0082 9A42     		cmp	r2, r3
 768 0084 02D3     		bcc	.L59
 769              		.loc 1 750 0 is_stmt 0 discriminator 1
 770 0086 3B68     		ldr	r3, [r7]
 771 0088 022B     		cmp	r3, #2
 772 008a 21D1     		bne	.L60
 773              	.L59:
 751:../freertos/queue.c **** 			{
 752:../freertos/queue.c **** 				traceQUEUE_SEND( pxQueue );
 753:../freertos/queue.c **** 				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 774              		.loc 1 753 0 is_stmt 1
 775 008c 396A     		ldr	r1, [r7, #32]
 776 008e BA68     		ldr	r2, [r7, #8]
 777 0090 3B68     		ldr	r3, [r7]
 778 0092 081C     		mov	r0, r1
 779 0094 111C     		mov	r1, r2
 780 0096 1A1C     		mov	r2, r3
 781 0098 FFF7FEFF 		bl	prvCopyDataToQueue
 782 009c 031C     		mov	r3, r0
 783 009e FB61     		str	r3, [r7, #28]
 754:../freertos/queue.c **** 
 755:../freertos/queue.c **** 				#if ( configUSE_QUEUE_SETS == 1 )
 756:../freertos/queue.c **** 				{
 757:../freertos/queue.c **** 					if( pxQueue->pxQueueSetContainer != NULL )
 758:../freertos/queue.c **** 					{
 759:../freertos/queue.c **** 						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
 760:../freertos/queue.c **** 						{
 761:../freertos/queue.c **** 							/* The queue is a member of a queue set, and posting
 762:../freertos/queue.c **** 							to the queue set caused a higher priority task to
 763:../freertos/queue.c **** 							unblock. A context switch is required. */
 764:../freertos/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 765:../freertos/queue.c **** 						}
 766:../freertos/queue.c **** 						else
 767:../freertos/queue.c **** 						{
 768:../freertos/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 769:../freertos/queue.c **** 						}
 770:../freertos/queue.c **** 					}
 771:../freertos/queue.c **** 					else
 772:../freertos/queue.c **** 					{
 773:../freertos/queue.c **** 						/* If there was a task waiting for data to arrive on the
 774:../freertos/queue.c **** 						queue then unblock it now. */
 775:../freertos/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 776:../freertos/queue.c **** 						{
 777:../freertos/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 778:../freertos/queue.c **** 							{
 779:../freertos/queue.c **** 								/* The unblocked task has a priority higher than
 780:../freertos/queue.c **** 								our own so yield immediately.  Yes it is ok to
 781:../freertos/queue.c **** 								do this from within the critical section - the
 782:../freertos/queue.c **** 								kernel takes care of that. */
 783:../freertos/queue.c **** 								queueYIELD_IF_USING_PREEMPTION();
 784:../freertos/queue.c **** 							}
 785:../freertos/queue.c **** 							else
 786:../freertos/queue.c **** 							{
 787:../freertos/queue.c **** 								mtCOVERAGE_TEST_MARKER();
 788:../freertos/queue.c **** 							}
 789:../freertos/queue.c **** 						}
 790:../freertos/queue.c **** 						else if( xYieldRequired != pdFALSE )
 791:../freertos/queue.c **** 						{
 792:../freertos/queue.c **** 							/* This path is a special case that will only get
 793:../freertos/queue.c **** 							executed if the task was holding multiple mutexes
 794:../freertos/queue.c **** 							and the mutexes were given back in an order that is
 795:../freertos/queue.c **** 							different to that in which they were taken. */
 796:../freertos/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 797:../freertos/queue.c **** 						}
 798:../freertos/queue.c **** 						else
 799:../freertos/queue.c **** 						{
 800:../freertos/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 801:../freertos/queue.c **** 						}
 802:../freertos/queue.c **** 					}
 803:../freertos/queue.c **** 				}
 804:../freertos/queue.c **** 				#else /* configUSE_QUEUE_SETS */
 805:../freertos/queue.c **** 				{
 806:../freertos/queue.c **** 					/* If there was a task waiting for data to arrive on the
 807:../freertos/queue.c **** 					queue then unblock it now. */
 808:../freertos/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 784              		.loc 1 808 0
 785 00a0 3B6A     		ldr	r3, [r7, #32]
 786 00a2 5B6A     		ldr	r3, [r3, #36]
 787 00a4 002B     		cmp	r3, #0
 788 00a6 0AD0     		beq	.L61
 809:../freertos/queue.c **** 					{
 810:../freertos/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 789              		.loc 1 810 0
 790 00a8 3B6A     		ldr	r3, [r7, #32]
 791 00aa 2433     		add	r3, r3, #36
 792 00ac 181C     		mov	r0, r3
 793 00ae FFF7FEFF 		bl	xTaskRemoveFromEventList
 794 00b2 031C     		mov	r3, r0
 795 00b4 002B     		cmp	r3, #0
 796 00b6 07D0     		beq	.L62
 811:../freertos/queue.c **** 						{
 812:../freertos/queue.c **** 							/* The unblocked task has a priority higher than
 813:../freertos/queue.c **** 							our own so yield immediately.  Yes it is ok to do
 814:../freertos/queue.c **** 							this from within the critical section - the kernel
 815:../freertos/queue.c **** 							takes care of that. */
 816:../freertos/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 797              		.loc 1 816 0
 798 00b8 FFF7FEFF 		bl	vPortYield
 799 00bc 04E0     		b	.L62
 800              	.L61:
 817:../freertos/queue.c **** 						}
 818:../freertos/queue.c **** 						else
 819:../freertos/queue.c **** 						{
 820:../freertos/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 821:../freertos/queue.c **** 						}
 822:../freertos/queue.c **** 					}
 823:../freertos/queue.c **** 					else if( xYieldRequired != pdFALSE )
 801              		.loc 1 823 0
 802 00be FB69     		ldr	r3, [r7, #28]
 803 00c0 002B     		cmp	r3, #0
 804 00c2 01D0     		beq	.L62
 824:../freertos/queue.c **** 					{
 825:../freertos/queue.c **** 						/* This path is a special case that will only get
 826:../freertos/queue.c **** 						executed if the task was holding multiple mutexes and
 827:../freertos/queue.c **** 						the mutexes were given back in an order that is
 828:../freertos/queue.c **** 						different to that in which they were taken. */
 829:../freertos/queue.c **** 						queueYIELD_IF_USING_PREEMPTION();
 805              		.loc 1 829 0
 806 00c4 FFF7FEFF 		bl	vPortYield
 807              	.L62:
 830:../freertos/queue.c **** 					}
 831:../freertos/queue.c **** 					else
 832:../freertos/queue.c **** 					{
 833:../freertos/queue.c **** 						mtCOVERAGE_TEST_MARKER();
 834:../freertos/queue.c **** 					}
 835:../freertos/queue.c **** 				}
 836:../freertos/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
 837:../freertos/queue.c **** 
 838:../freertos/queue.c **** 				taskEXIT_CRITICAL();
 808              		.loc 1 838 0
 809 00c8 FFF7FEFF 		bl	vPortExitCritical
 839:../freertos/queue.c **** 				return pdPASS;
 810              		.loc 1 839 0
 811 00cc 0123     		mov	r3, #1
 812 00ce 63E0     		b	.L73
 813              	.L60:
 840:../freertos/queue.c **** 			}
 841:../freertos/queue.c **** 			else
 842:../freertos/queue.c **** 			{
 843:../freertos/queue.c **** 				if( xTicksToWait == ( TickType_t ) 0 )
 814              		.loc 1 843 0
 815 00d0 7B68     		ldr	r3, [r7, #4]
 816 00d2 002B     		cmp	r3, #0
 817 00d4 03D1     		bne	.L64
 844:../freertos/queue.c **** 				{
 845:../freertos/queue.c **** 					/* The queue was full and no block time is specified (or
 846:../freertos/queue.c **** 					the block time has expired) so leave now. */
 847:../freertos/queue.c **** 					taskEXIT_CRITICAL();
 818              		.loc 1 847 0
 819 00d6 FFF7FEFF 		bl	vPortExitCritical
 848:../freertos/queue.c **** 
 849:../freertos/queue.c **** 					/* Return to the original privilege level before exiting
 850:../freertos/queue.c **** 					the function. */
 851:../freertos/queue.c **** 					traceQUEUE_SEND_FAILED( pxQueue );
 852:../freertos/queue.c **** 					return errQUEUE_FULL;
 820              		.loc 1 852 0
 821 00da 0023     		mov	r3, #0
 822 00dc 5CE0     		b	.L73
 823              	.L64:
 853:../freertos/queue.c **** 				}
 854:../freertos/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 824              		.loc 1 854 0
 825 00de 7B6A     		ldr	r3, [r7, #36]
 826 00e0 002B     		cmp	r3, #0
 827 00e2 06D1     		bne	.L65
 855:../freertos/queue.c **** 				{
 856:../freertos/queue.c **** 					/* The queue was full and a block time was specified so
 857:../freertos/queue.c **** 					configure the timeout structure. */
 858:../freertos/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 828              		.loc 1 858 0
 829 00e4 3B1C     		mov	r3, r7
 830 00e6 1433     		add	r3, r3, #20
 831 00e8 181C     		mov	r0, r3
 832 00ea FFF7FEFF 		bl	vTaskSetTimeOutState
 859:../freertos/queue.c **** 					xEntryTimeSet = pdTRUE;
 833              		.loc 1 859 0
 834 00ee 0123     		mov	r3, #1
 835 00f0 7B62     		str	r3, [r7, #36]
 836              	.L65:
 860:../freertos/queue.c **** 				}
 861:../freertos/queue.c **** 				else
 862:../freertos/queue.c **** 				{
 863:../freertos/queue.c **** 					/* Entry time was already set. */
 864:../freertos/queue.c **** 					mtCOVERAGE_TEST_MARKER();
 865:../freertos/queue.c **** 				}
 866:../freertos/queue.c **** 			}
 867:../freertos/queue.c **** 		}
 868:../freertos/queue.c **** 		taskEXIT_CRITICAL();
 837              		.loc 1 868 0
 838 00f2 FFF7FEFF 		bl	vPortExitCritical
 869:../freertos/queue.c **** 
 870:../freertos/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
 871:../freertos/queue.c **** 		now the critical section has been exited. */
 872:../freertos/queue.c **** 
 873:../freertos/queue.c **** 		vTaskSuspendAll();
 839              		.loc 1 873 0
 840 00f6 FFF7FEFF 		bl	vTaskSuspendAll
 874:../freertos/queue.c **** 		prvLockQueue( pxQueue );
 841              		.loc 1 874 0
 842 00fa FFF7FEFF 		bl	vPortEnterCritical
 843 00fe 3A6A     		ldr	r2, [r7, #32]
 844 0100 4423     		mov	r3, #68
 845 0102 D35C     		ldrb	r3, [r2, r3]
 846 0104 DBB2     		uxtb	r3, r3
 847 0106 5BB2     		sxtb	r3, r3
 848 0108 0133     		add	r3, r3, #1
 849 010a 03D1     		bne	.L66
 850              		.loc 1 874 0 is_stmt 0 discriminator 1
 851 010c 3A6A     		ldr	r2, [r7, #32]
 852 010e 4423     		mov	r3, #68
 853 0110 0021     		mov	r1, #0
 854 0112 D154     		strb	r1, [r2, r3]
 855              	.L66:
 856              		.loc 1 874 0 discriminator 2
 857 0114 3A6A     		ldr	r2, [r7, #32]
 858 0116 4523     		mov	r3, #69
 859 0118 D35C     		ldrb	r3, [r2, r3]
 860 011a DBB2     		uxtb	r3, r3
 861 011c 5BB2     		sxtb	r3, r3
 862 011e 0133     		add	r3, r3, #1
 863 0120 03D1     		bne	.L67
 864              		.loc 1 874 0 discriminator 1
 865 0122 3A6A     		ldr	r2, [r7, #32]
 866 0124 4523     		mov	r3, #69
 867 0126 0021     		mov	r1, #0
 868 0128 D154     		strb	r1, [r2, r3]
 869              	.L67:
 870              		.loc 1 874 0 discriminator 2
 871 012a FFF7FEFF 		bl	vPortExitCritical
 875:../freertos/queue.c **** 
 876:../freertos/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
 877:../freertos/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 872              		.loc 1 877 0 is_stmt 1 discriminator 2
 873 012e 3A1C     		mov	r2, r7
 874 0130 1432     		add	r2, r2, #20
 875 0132 3B1D     		add	r3, r7, #4
 876 0134 101C     		mov	r0, r2
 877 0136 191C     		mov	r1, r3
 878 0138 FFF7FEFF 		bl	xTaskCheckForTimeOut
 879 013c 031C     		mov	r3, r0
 880 013e 002B     		cmp	r3, #0
 881 0140 21D1     		bne	.L68
 878:../freertos/queue.c **** 		{
 879:../freertos/queue.c **** 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 882              		.loc 1 879 0
 883 0142 3B6A     		ldr	r3, [r7, #32]
 884 0144 181C     		mov	r0, r3
 885 0146 FFF7FEFF 		bl	prvIsQueueFull
 886 014a 031C     		mov	r3, r0
 887 014c 002B     		cmp	r3, #0
 888 014e 13D0     		beq	.L69
 880:../freertos/queue.c **** 			{
 881:../freertos/queue.c **** 				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
 882:../freertos/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 889              		.loc 1 882 0
 890 0150 3B6A     		ldr	r3, [r7, #32]
 891 0152 1A1C     		mov	r2, r3
 892 0154 1032     		add	r2, r2, #16
 893 0156 7B68     		ldr	r3, [r7, #4]
 894 0158 101C     		mov	r0, r2
 895 015a 191C     		mov	r1, r3
 896 015c FFF7FEFF 		bl	vTaskPlaceOnEventList
 883:../freertos/queue.c **** 
 884:../freertos/queue.c **** 				/* Unlocking the queue means queue events can effect the
 885:../freertos/queue.c **** 				event list.  It is possible	that interrupts occurring now
 886:../freertos/queue.c **** 				remove this task from the event	list again - but as the
 887:../freertos/queue.c **** 				scheduler is suspended the task will go onto the pending
 888:../freertos/queue.c **** 				ready last instead of the actual ready list. */
 889:../freertos/queue.c **** 				prvUnlockQueue( pxQueue );
 897              		.loc 1 889 0
 898 0160 3B6A     		ldr	r3, [r7, #32]
 899 0162 181C     		mov	r0, r3
 900 0164 FFF7FEFF 		bl	prvUnlockQueue
 890:../freertos/queue.c **** 
 891:../freertos/queue.c **** 				/* Resuming the scheduler will move tasks from the pending
 892:../freertos/queue.c **** 				ready list into the ready list - so it is feasible that this
 893:../freertos/queue.c **** 				task is already in a ready list before it yields - in which
 894:../freertos/queue.c **** 				case the yield will not cause a context switch unless there
 895:../freertos/queue.c **** 				is also a higher priority task in the pending ready list. */
 896:../freertos/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 901              		.loc 1 896 0
 902 0168 FFF7FEFF 		bl	xTaskResumeAll
 903 016c 031C     		mov	r3, r0
 904 016e 002B     		cmp	r3, #0
 905 0170 11D1     		bne	.L72
 897:../freertos/queue.c **** 				{
 898:../freertos/queue.c **** 					portYIELD_WITHIN_API();
 906              		.loc 1 898 0
 907 0172 FFF7FEFF 		bl	vPortYield
 908 0176 0EE0     		b	.L72
 909              	.L69:
 899:../freertos/queue.c **** 				}
 900:../freertos/queue.c **** 			}
 901:../freertos/queue.c **** 			else
 902:../freertos/queue.c **** 			{
 903:../freertos/queue.c **** 				/* Try again. */
 904:../freertos/queue.c **** 				prvUnlockQueue( pxQueue );
 910              		.loc 1 904 0
 911 0178 3B6A     		ldr	r3, [r7, #32]
 912 017a 181C     		mov	r0, r3
 913 017c FFF7FEFF 		bl	prvUnlockQueue
 905:../freertos/queue.c **** 				( void ) xTaskResumeAll();
 914              		.loc 1 905 0
 915 0180 FFF7FEFF 		bl	xTaskResumeAll
 906:../freertos/queue.c **** 			}
 907:../freertos/queue.c **** 		}
 908:../freertos/queue.c **** 		else
 909:../freertos/queue.c **** 		{
 910:../freertos/queue.c **** 			/* The timeout has expired. */
 911:../freertos/queue.c **** 			prvUnlockQueue( pxQueue );
 912:../freertos/queue.c **** 			( void ) xTaskResumeAll();
 913:../freertos/queue.c **** 
 914:../freertos/queue.c **** 			traceQUEUE_SEND_FAILED( pxQueue );
 915:../freertos/queue.c **** 			return errQUEUE_FULL;
 916:../freertos/queue.c **** 		}
 917:../freertos/queue.c **** 	}
 916              		.loc 1 917 0
 917 0184 77E7     		b	.L57
 918              	.L68:
 911:../freertos/queue.c **** 			prvUnlockQueue( pxQueue );
 919              		.loc 1 911 0
 920 0186 3B6A     		ldr	r3, [r7, #32]
 921 0188 181C     		mov	r0, r3
 922 018a FFF7FEFF 		bl	prvUnlockQueue
 912:../freertos/queue.c **** 			( void ) xTaskResumeAll();
 923              		.loc 1 912 0
 924 018e FFF7FEFF 		bl	xTaskResumeAll
 915:../freertos/queue.c **** 			return errQUEUE_FULL;
 925              		.loc 1 915 0
 926 0192 0023     		mov	r3, #0
 927 0194 00E0     		b	.L73
 928              	.L72:
 929              		.loc 1 917 0
 930 0196 6EE7     		b	.L57
 931              	.L73:
 918:../freertos/queue.c **** }
 932              		.loc 1 918 0
 933 0198 181C     		mov	r0, r3
 934 019a BD46     		mov	sp, r7
 935 019c 0AB0     		add	sp, sp, #40
 936              		@ sp needed
 937 019e 80BD     		pop	{r7, pc}
 938              		.cfi_endproc
 939              	.LFE8:
 941              		.section	.text.xQueueGenericSendFromISR,"ax",%progbits
 942              		.align	2
 943              		.global	xQueueGenericSendFromISR
 944              		.code	16
 945              		.thumb_func
 947              	xQueueGenericSendFromISR:
 948              	.LFB9:
 919:../freertos/queue.c **** /*-----------------------------------------------------------*/
 920:../freertos/queue.c **** 
 921:../freertos/queue.c **** BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseTy
 922:../freertos/queue.c **** {
 949              		.loc 1 922 0
 950              		.cfi_startproc
 951 0000 80B5     		push	{r7, lr}
 952              		.cfi_def_cfa_offset 8
 953              		.cfi_offset 7, -8
 954              		.cfi_offset 14, -4
 955 0002 88B0     		sub	sp, sp, #32
 956              		.cfi_def_cfa_offset 40
 957 0004 00AF     		add	r7, sp, #0
 958              		.cfi_def_cfa_register 7
 959 0006 F860     		str	r0, [r7, #12]
 960 0008 B960     		str	r1, [r7, #8]
 961 000a 7A60     		str	r2, [r7, #4]
 962 000c 3B60     		str	r3, [r7]
 923:../freertos/queue.c **** BaseType_t xReturn;
 924:../freertos/queue.c **** UBaseType_t uxSavedInterruptStatus;
 925:../freertos/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 963              		.loc 1 925 0
 964 000e FB68     		ldr	r3, [r7, #12]
 965 0010 BB61     		str	r3, [r7, #24]
 926:../freertos/queue.c **** 
 927:../freertos/queue.c **** 	configASSERT( pxQueue );
 966              		.loc 1 927 0
 967 0012 BB69     		ldr	r3, [r7, #24]
 968 0014 002B     		cmp	r3, #0
 969 0016 01D1     		bne	.L75
 970              		.loc 1 927 0 is_stmt 0 discriminator 1
 971              	@ 927 "../freertos/queue.c" 1
 972 0018 72B6     		 cpsid i 
 973              	@ 0 "" 2
 974              		.code	16
 975              	.L76:
 976 001a FEE7     		b	.L76
 977              	.L75:
 928:../freertos/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 978              		.loc 1 928 0 is_stmt 1
 979 001c BB68     		ldr	r3, [r7, #8]
 980 001e 002B     		cmp	r3, #0
 981 0020 03D1     		bne	.L77
 982              		.loc 1 928 0 is_stmt 0 discriminator 2
 983 0022 BB69     		ldr	r3, [r7, #24]
 984 0024 1B6C     		ldr	r3, [r3, #64]
 985 0026 002B     		cmp	r3, #0
 986 0028 01D1     		bne	.L78
 987              	.L77:
 988              		.loc 1 928 0 discriminator 1
 989 002a 0123     		mov	r3, #1
 990 002c 00E0     		b	.L79
 991              	.L78:
 992              		.loc 1 928 0 discriminator 3
 993 002e 0023     		mov	r3, #0
 994              	.L79:
 995              		.loc 1 928 0 discriminator 4
 996 0030 002B     		cmp	r3, #0
 997 0032 01D1     		bne	.L80
 998              		.loc 1 928 0 discriminator 1
 999              	@ 928 "../freertos/queue.c" 1
 1000 0034 72B6     		 cpsid i 
 1001              	@ 0 "" 2
 1002              		.code	16
 1003              	.L81:
 1004 0036 FEE7     		b	.L81
 1005              	.L80:
 929:../freertos/queue.c **** 	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 1006              		.loc 1 929 0 is_stmt 1
 1007 0038 3B68     		ldr	r3, [r7]
 1008 003a 022B     		cmp	r3, #2
 1009 003c 03D1     		bne	.L82
 1010              		.loc 1 929 0 is_stmt 0 discriminator 2
 1011 003e BB69     		ldr	r3, [r7, #24]
 1012 0040 DB6B     		ldr	r3, [r3, #60]
 1013 0042 012B     		cmp	r3, #1
 1014 0044 01D1     		bne	.L83
 1015              	.L82:
 1016              		.loc 1 929 0 discriminator 1
 1017 0046 0123     		mov	r3, #1
 1018 0048 00E0     		b	.L84
 1019              	.L83:
 1020              		.loc 1 929 0 discriminator 3
 1021 004a 0023     		mov	r3, #0
 1022              	.L84:
 1023              		.loc 1 929 0 discriminator 4
 1024 004c 002B     		cmp	r3, #0
 1025 004e 01D1     		bne	.L85
 1026              		.loc 1 929 0 discriminator 1
 1027              	@ 929 "../freertos/queue.c" 1
 1028 0050 72B6     		 cpsid i 
 1029              	@ 0 "" 2
 1030              		.code	16
 1031              	.L86:
 1032 0052 FEE7     		b	.L86
 1033              	.L85:
 930:../freertos/queue.c **** 
 931:../freertos/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
 932:../freertos/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
 933:../freertos/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
 934:../freertos/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
 935:../freertos/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
 936:../freertos/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
 937:../freertos/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
 938:../freertos/queue.c **** 	assigned a priority above the configured maximum system call priority.
 939:../freertos/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
 940:../freertos/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
 941:../freertos/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
 942:../freertos/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
 943:../freertos/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
 944:../freertos/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
 945:../freertos/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 946:../freertos/queue.c **** 
 947:../freertos/queue.c **** 	/* Similar to xQueueGenericSend, except without blocking if there is no room
 948:../freertos/queue.c **** 	in the queue.  Also don't directly wake a task that was blocked on a queue
 949:../freertos/queue.c **** 	read, instead return a flag to say whether a context switch is required or
 950:../freertos/queue.c **** 	not (i.e. has a task with a higher priority than us been woken by this
 951:../freertos/queue.c **** 	post). */
 952:../freertos/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1034              		.loc 1 952 0 is_stmt 1
 1035 0054 FFF7FEFF 		bl	ulSetInterruptMaskFromISR
 1036 0058 031C     		mov	r3, r0
 1037 005a 7B61     		str	r3, [r7, #20]
 953:../freertos/queue.c **** 	{
 954:../freertos/queue.c **** 		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 1038              		.loc 1 954 0
 1039 005c BB69     		ldr	r3, [r7, #24]
 1040 005e 9A6B     		ldr	r2, [r3, #56]
 1041 0060 BB69     		ldr	r3, [r7, #24]
 1042 0062 DB6B     		ldr	r3, [r3, #60]
 1043 0064 9A42     		cmp	r2, r3
 1044 0066 02D3     		bcc	.L87
 1045              		.loc 1 954 0 is_stmt 0 discriminator 1
 1046 0068 3B68     		ldr	r3, [r7]
 1047 006a 022B     		cmp	r3, #2
 1048 006c 32D1     		bne	.L88
 1049              	.L87:
 1050              	.LBB2:
 955:../freertos/queue.c **** 		{
 956:../freertos/queue.c **** 			const int8_t cTxLock = pxQueue->cTxLock;
 1051              		.loc 1 956 0 is_stmt 1
 1052 006e 3B1C     		mov	r3, r7
 1053 0070 1333     		add	r3, r3, #19
 1054 0072 B969     		ldr	r1, [r7, #24]
 1055 0074 4522     		mov	r2, #69
 1056 0076 8A5C     		ldrb	r2, [r1, r2]
 1057 0078 1A70     		strb	r2, [r3]
 957:../freertos/queue.c **** 
 958:../freertos/queue.c **** 			traceQUEUE_SEND_FROM_ISR( pxQueue );
 959:../freertos/queue.c **** 
 960:../freertos/queue.c **** 			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
 961:../freertos/queue.c **** 			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
 962:../freertos/queue.c **** 			in a task disinheriting a priority and prvCopyDataToQueue() can be
 963:../freertos/queue.c **** 			called here even though the disinherit function does not check if
 964:../freertos/queue.c **** 			the scheduler is suspended before accessing the ready lists. */
 965:../freertos/queue.c **** 			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 1058              		.loc 1 965 0
 1059 007a B969     		ldr	r1, [r7, #24]
 1060 007c BA68     		ldr	r2, [r7, #8]
 1061 007e 3B68     		ldr	r3, [r7]
 1062 0080 081C     		mov	r0, r1
 1063 0082 111C     		mov	r1, r2
 1064 0084 1A1C     		mov	r2, r3
 1065 0086 FFF7FEFF 		bl	prvCopyDataToQueue
 966:../freertos/queue.c **** 
 967:../freertos/queue.c **** 			/* The event list is not altered if the queue is locked.  This will
 968:../freertos/queue.c **** 			be done when the queue is unlocked later. */
 969:../freertos/queue.c **** 			if( cTxLock == queueUNLOCKED )
 1066              		.loc 1 969 0
 1067 008a 3B1C     		mov	r3, r7
 1068 008c 1333     		add	r3, r3, #19
 1069 008e 1B78     		ldrb	r3, [r3]
 1070 0090 5BB2     		sxtb	r3, r3
 1071 0092 0133     		add	r3, r3, #1
 1072 0094 12D1     		bne	.L89
 970:../freertos/queue.c **** 			{
 971:../freertos/queue.c **** 				#if ( configUSE_QUEUE_SETS == 1 )
 972:../freertos/queue.c **** 				{
 973:../freertos/queue.c **** 					if( pxQueue->pxQueueSetContainer != NULL )
 974:../freertos/queue.c **** 					{
 975:../freertos/queue.c **** 						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
 976:../freertos/queue.c **** 						{
 977:../freertos/queue.c **** 							/* The queue is a member of a queue set, and posting
 978:../freertos/queue.c **** 							to the queue set caused a higher priority task to
 979:../freertos/queue.c **** 							unblock.  A context switch is required. */
 980:../freertos/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
 981:../freertos/queue.c **** 							{
 982:../freertos/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
 983:../freertos/queue.c **** 							}
 984:../freertos/queue.c **** 							else
 985:../freertos/queue.c **** 							{
 986:../freertos/queue.c **** 								mtCOVERAGE_TEST_MARKER();
 987:../freertos/queue.c **** 							}
 988:../freertos/queue.c **** 						}
 989:../freertos/queue.c **** 						else
 990:../freertos/queue.c **** 						{
 991:../freertos/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 992:../freertos/queue.c **** 						}
 993:../freertos/queue.c **** 					}
 994:../freertos/queue.c **** 					else
 995:../freertos/queue.c **** 					{
 996:../freertos/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 997:../freertos/queue.c **** 						{
 998:../freertos/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 999:../freertos/queue.c **** 							{
1000:../freertos/queue.c **** 								/* The task waiting has a higher priority so
1001:../freertos/queue.c **** 								record that a context switch is required. */
1002:../freertos/queue.c **** 								if( pxHigherPriorityTaskWoken != NULL )
1003:../freertos/queue.c **** 								{
1004:../freertos/queue.c **** 									*pxHigherPriorityTaskWoken = pdTRUE;
1005:../freertos/queue.c **** 								}
1006:../freertos/queue.c **** 								else
1007:../freertos/queue.c **** 								{
1008:../freertos/queue.c **** 									mtCOVERAGE_TEST_MARKER();
1009:../freertos/queue.c **** 								}
1010:../freertos/queue.c **** 							}
1011:../freertos/queue.c **** 							else
1012:../freertos/queue.c **** 							{
1013:../freertos/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1014:../freertos/queue.c **** 							}
1015:../freertos/queue.c **** 						}
1016:../freertos/queue.c **** 						else
1017:../freertos/queue.c **** 						{
1018:../freertos/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1019:../freertos/queue.c **** 						}
1020:../freertos/queue.c **** 					}
1021:../freertos/queue.c **** 				}
1022:../freertos/queue.c **** 				#else /* configUSE_QUEUE_SETS */
1023:../freertos/queue.c **** 				{
1024:../freertos/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 1073              		.loc 1 1024 0
 1074 0096 BB69     		ldr	r3, [r7, #24]
 1075 0098 5B6A     		ldr	r3, [r3, #36]
 1076 009a 002B     		cmp	r3, #0
 1077 009c 17D0     		beq	.L90
1025:../freertos/queue.c **** 					{
1026:../freertos/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 1078              		.loc 1 1026 0
 1079 009e BB69     		ldr	r3, [r7, #24]
 1080 00a0 2433     		add	r3, r3, #36
 1081 00a2 181C     		mov	r0, r3
 1082 00a4 FFF7FEFF 		bl	xTaskRemoveFromEventList
 1083 00a8 031C     		mov	r3, r0
 1084 00aa 002B     		cmp	r3, #0
 1085 00ac 0FD0     		beq	.L90
1027:../freertos/queue.c **** 						{
1028:../freertos/queue.c **** 							/* The task waiting has a higher priority so record that a
1029:../freertos/queue.c **** 							context	switch is required. */
1030:../freertos/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
 1086              		.loc 1 1030 0
 1087 00ae 7B68     		ldr	r3, [r7, #4]
 1088 00b0 002B     		cmp	r3, #0
 1089 00b2 0CD0     		beq	.L90
1031:../freertos/queue.c **** 							{
1032:../freertos/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
 1090              		.loc 1 1032 0
 1091 00b4 7B68     		ldr	r3, [r7, #4]
 1092 00b6 0122     		mov	r2, #1
 1093 00b8 1A60     		str	r2, [r3]
 1094 00ba 08E0     		b	.L90
 1095              	.L89:
1033:../freertos/queue.c **** 							}
1034:../freertos/queue.c **** 							else
1035:../freertos/queue.c **** 							{
1036:../freertos/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1037:../freertos/queue.c **** 							}
1038:../freertos/queue.c **** 						}
1039:../freertos/queue.c **** 						else
1040:../freertos/queue.c **** 						{
1041:../freertos/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1042:../freertos/queue.c **** 						}
1043:../freertos/queue.c **** 					}
1044:../freertos/queue.c **** 					else
1045:../freertos/queue.c **** 					{
1046:../freertos/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1047:../freertos/queue.c **** 					}
1048:../freertos/queue.c **** 				}
1049:../freertos/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
1050:../freertos/queue.c **** 			}
1051:../freertos/queue.c **** 			else
1052:../freertos/queue.c **** 			{
1053:../freertos/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1054:../freertos/queue.c **** 				knows that data was posted while it was locked. */
1055:../freertos/queue.c **** 				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 1096              		.loc 1 1055 0
 1097 00bc 3B1C     		mov	r3, r7
 1098 00be 1333     		add	r3, r3, #19
 1099 00c0 1B78     		ldrb	r3, [r3]
 1100 00c2 0133     		add	r3, r3, #1
 1101 00c4 DBB2     		uxtb	r3, r3
 1102 00c6 D9B2     		uxtb	r1, r3
 1103 00c8 BA69     		ldr	r2, [r7, #24]
 1104 00ca 4523     		mov	r3, #69
 1105 00cc D154     		strb	r1, [r2, r3]
 1106              	.L90:
1056:../freertos/queue.c **** 			}
1057:../freertos/queue.c **** 
1058:../freertos/queue.c **** 			xReturn = pdPASS;
 1107              		.loc 1 1058 0
 1108 00ce 0123     		mov	r3, #1
 1109 00d0 FB61     		str	r3, [r7, #28]
 1110              	.LBE2:
 955:../freertos/queue.c **** 		{
 1111              		.loc 1 955 0
 1112 00d2 01E0     		b	.L91
 1113              	.L88:
1059:../freertos/queue.c **** 		}
1060:../freertos/queue.c **** 		else
1061:../freertos/queue.c **** 		{
1062:../freertos/queue.c **** 			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
1063:../freertos/queue.c **** 			xReturn = errQUEUE_FULL;
 1114              		.loc 1 1063 0
 1115 00d4 0023     		mov	r3, #0
 1116 00d6 FB61     		str	r3, [r7, #28]
 1117              	.L91:
1064:../freertos/queue.c **** 		}
1065:../freertos/queue.c **** 	}
1066:../freertos/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 1118              		.loc 1 1066 0
 1119 00d8 7B69     		ldr	r3, [r7, #20]
 1120 00da 181C     		mov	r0, r3
 1121 00dc FFF7FEFF 		bl	vClearInterruptMaskFromISR
1067:../freertos/queue.c **** 
1068:../freertos/queue.c **** 	return xReturn;
 1122              		.loc 1 1068 0
 1123 00e0 FB69     		ldr	r3, [r7, #28]
1069:../freertos/queue.c **** }
 1124              		.loc 1 1069 0
 1125 00e2 181C     		mov	r0, r3
 1126 00e4 BD46     		mov	sp, r7
 1127 00e6 08B0     		add	sp, sp, #32
 1128              		@ sp needed
 1129 00e8 80BD     		pop	{r7, pc}
 1130              		.cfi_endproc
 1131              	.LFE9:
 1133 00ea C046     		.section	.text.xQueueGiveFromISR,"ax",%progbits
 1134              		.align	2
 1135              		.global	xQueueGiveFromISR
 1136              		.code	16
 1137              		.thumb_func
 1139              	xQueueGiveFromISR:
 1140              	.LFB10:
1070:../freertos/queue.c **** /*-----------------------------------------------------------*/
1071:../freertos/queue.c **** 
1072:../freertos/queue.c **** BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
1073:../freertos/queue.c **** {
 1141              		.loc 1 1073 0
 1142              		.cfi_startproc
 1143 0000 80B5     		push	{r7, lr}
 1144              		.cfi_def_cfa_offset 8
 1145              		.cfi_offset 7, -8
 1146              		.cfi_offset 14, -4
 1147 0002 88B0     		sub	sp, sp, #32
 1148              		.cfi_def_cfa_offset 40
 1149 0004 00AF     		add	r7, sp, #0
 1150              		.cfi_def_cfa_register 7
 1151 0006 7860     		str	r0, [r7, #4]
 1152 0008 3960     		str	r1, [r7]
1074:../freertos/queue.c **** BaseType_t xReturn;
1075:../freertos/queue.c **** UBaseType_t uxSavedInterruptStatus;
1076:../freertos/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 1153              		.loc 1 1076 0
 1154 000a 7B68     		ldr	r3, [r7, #4]
 1155 000c BB61     		str	r3, [r7, #24]
1077:../freertos/queue.c **** 
1078:../freertos/queue.c **** 	/* Similar to xQueueGenericSendFromISR() but used with semaphores where the
1079:../freertos/queue.c **** 	item size is 0.  Don't directly wake a task that was blocked on a queue
1080:../freertos/queue.c **** 	read, instead return a flag to say whether a context switch is required or
1081:../freertos/queue.c **** 	not (i.e. has a task with a higher priority than us been woken by this
1082:../freertos/queue.c **** 	post). */
1083:../freertos/queue.c **** 
1084:../freertos/queue.c **** 	configASSERT( pxQueue );
 1156              		.loc 1 1084 0
 1157 000e BB69     		ldr	r3, [r7, #24]
 1158 0010 002B     		cmp	r3, #0
 1159 0012 01D1     		bne	.L94
 1160              		.loc 1 1084 0 is_stmt 0 discriminator 1
 1161              	@ 1084 "../freertos/queue.c" 1
 1162 0014 72B6     		 cpsid i 
 1163              	@ 0 "" 2
 1164              		.code	16
 1165              	.L95:
 1166 0016 FEE7     		b	.L95
 1167              	.L94:
1085:../freertos/queue.c **** 
1086:../freertos/queue.c **** 	/* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
1087:../freertos/queue.c **** 	if the item size is not 0. */
1088:../freertos/queue.c **** 	configASSERT( pxQueue->uxItemSize == 0 );
 1168              		.loc 1 1088 0 is_stmt 1
 1169 0018 BB69     		ldr	r3, [r7, #24]
 1170 001a 1B6C     		ldr	r3, [r3, #64]
 1171 001c 002B     		cmp	r3, #0
 1172 001e 01D0     		beq	.L96
 1173              		.loc 1 1088 0 is_stmt 0 discriminator 1
 1174              	@ 1088 "../freertos/queue.c" 1
 1175 0020 72B6     		 cpsid i 
 1176              	@ 0 "" 2
 1177              		.code	16
 1178              	.L97:
 1179 0022 FEE7     		b	.L97
 1180              	.L96:
1089:../freertos/queue.c **** 
1090:../freertos/queue.c **** 	/* Normally a mutex would not be given from an interrupt, especially if
1091:../freertos/queue.c **** 	there is a mutex holder, as priority inheritance makes no sense for an
1092:../freertos/queue.c **** 	interrupts, only tasks. */
1093:../freertos/queue.c **** 	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->pxMutexHolder != NU
 1181              		.loc 1 1093 0 is_stmt 1
 1182 0024 BB69     		ldr	r3, [r7, #24]
 1183 0026 1B68     		ldr	r3, [r3]
 1184 0028 002B     		cmp	r3, #0
 1185 002a 03D1     		bne	.L98
 1186              		.loc 1 1093 0 is_stmt 0 discriminator 2
 1187 002c BB69     		ldr	r3, [r7, #24]
 1188 002e 5B68     		ldr	r3, [r3, #4]
 1189 0030 002B     		cmp	r3, #0
 1190 0032 01D1     		bne	.L99
 1191              	.L98:
 1192              		.loc 1 1093 0 discriminator 1
 1193 0034 0123     		mov	r3, #1
 1194 0036 00E0     		b	.L100
 1195              	.L99:
 1196              		.loc 1 1093 0 discriminator 3
 1197 0038 0023     		mov	r3, #0
 1198              	.L100:
 1199              		.loc 1 1093 0 discriminator 4
 1200 003a 002B     		cmp	r3, #0
 1201 003c 01D1     		bne	.L101
 1202              		.loc 1 1093 0 discriminator 1
 1203              	@ 1093 "../freertos/queue.c" 1
 1204 003e 72B6     		 cpsid i 
 1205              	@ 0 "" 2
 1206              		.code	16
 1207              	.L102:
 1208 0040 FEE7     		b	.L102
 1209              	.L101:
1094:../freertos/queue.c **** 
1095:../freertos/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1096:../freertos/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1097:../freertos/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
1098:../freertos/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1099:../freertos/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1100:../freertos/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1101:../freertos/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1102:../freertos/queue.c **** 	assigned a priority above the configured maximum system call priority.
1103:../freertos/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1104:../freertos/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
1105:../freertos/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1106:../freertos/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1107:../freertos/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
1108:../freertos/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1109:../freertos/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1110:../freertos/queue.c **** 
1111:../freertos/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1210              		.loc 1 1111 0 is_stmt 1
 1211 0042 FFF7FEFF 		bl	ulSetInterruptMaskFromISR
 1212 0046 031C     		mov	r3, r0
 1213 0048 7B61     		str	r3, [r7, #20]
 1214              	.LBB3:
1112:../freertos/queue.c **** 	{
1113:../freertos/queue.c **** 		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 1215              		.loc 1 1113 0
 1216 004a BB69     		ldr	r3, [r7, #24]
 1217 004c 9B6B     		ldr	r3, [r3, #56]
 1218 004e 3B61     		str	r3, [r7, #16]
1114:../freertos/queue.c **** 
1115:../freertos/queue.c **** 		/* When the queue is used to implement a semaphore no data is ever
1116:../freertos/queue.c **** 		moved through the queue but it is still valid to see if the queue 'has
1117:../freertos/queue.c **** 		space'. */
1118:../freertos/queue.c **** 		if( uxMessagesWaiting < pxQueue->uxLength )
 1219              		.loc 1 1118 0
 1220 0050 BB69     		ldr	r3, [r7, #24]
 1221 0052 DA6B     		ldr	r2, [r3, #60]
 1222 0054 3B69     		ldr	r3, [r7, #16]
 1223 0056 9A42     		cmp	r2, r3
 1224 0058 2ED9     		bls	.L103
 1225              	.LBB4:
1119:../freertos/queue.c **** 		{
1120:../freertos/queue.c **** 			const int8_t cTxLock = pxQueue->cTxLock;
 1226              		.loc 1 1120 0
 1227 005a 3B1C     		mov	r3, r7
 1228 005c 0F33     		add	r3, r3, #15
 1229 005e B969     		ldr	r1, [r7, #24]
 1230 0060 4522     		mov	r2, #69
 1231 0062 8A5C     		ldrb	r2, [r1, r2]
 1232 0064 1A70     		strb	r2, [r3]
1121:../freertos/queue.c **** 
1122:../freertos/queue.c **** 			traceQUEUE_SEND_FROM_ISR( pxQueue );
1123:../freertos/queue.c **** 
1124:../freertos/queue.c **** 			/* A task can only have an inherited priority if it is a mutex
1125:../freertos/queue.c **** 			holder - and if there is a mutex holder then the mutex cannot be
1126:../freertos/queue.c **** 			given from an ISR.  As this is the ISR version of the function it
1127:../freertos/queue.c **** 			can be assumed there is no mutex holder and no need to determine if
1128:../freertos/queue.c **** 			priority disinheritance is needed.  Simply increase the count of
1129:../freertos/queue.c **** 			messages (semaphores) available. */
1130:../freertos/queue.c **** 			pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
 1233              		.loc 1 1130 0
 1234 0066 3B69     		ldr	r3, [r7, #16]
 1235 0068 5A1C     		add	r2, r3, #1
 1236 006a BB69     		ldr	r3, [r7, #24]
 1237 006c 9A63     		str	r2, [r3, #56]
1131:../freertos/queue.c **** 
1132:../freertos/queue.c **** 			/* The event list is not altered if the queue is locked.  This will
1133:../freertos/queue.c **** 			be done when the queue is unlocked later. */
1134:../freertos/queue.c **** 			if( cTxLock == queueUNLOCKED )
 1238              		.loc 1 1134 0
 1239 006e 3B1C     		mov	r3, r7
 1240 0070 0F33     		add	r3, r3, #15
 1241 0072 1B78     		ldrb	r3, [r3]
 1242 0074 5BB2     		sxtb	r3, r3
 1243 0076 0133     		add	r3, r3, #1
 1244 0078 12D1     		bne	.L104
1135:../freertos/queue.c **** 			{
1136:../freertos/queue.c **** 				#if ( configUSE_QUEUE_SETS == 1 )
1137:../freertos/queue.c **** 				{
1138:../freertos/queue.c **** 					if( pxQueue->pxQueueSetContainer != NULL )
1139:../freertos/queue.c **** 					{
1140:../freertos/queue.c **** 						if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
1141:../freertos/queue.c **** 						{
1142:../freertos/queue.c **** 							/* The semaphore is a member of a queue set, and
1143:../freertos/queue.c **** 							posting	to the queue set caused a higher priority
1144:../freertos/queue.c **** 							task to	unblock.  A context switch is required. */
1145:../freertos/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
1146:../freertos/queue.c **** 							{
1147:../freertos/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
1148:../freertos/queue.c **** 							}
1149:../freertos/queue.c **** 							else
1150:../freertos/queue.c **** 							{
1151:../freertos/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1152:../freertos/queue.c **** 							}
1153:../freertos/queue.c **** 						}
1154:../freertos/queue.c **** 						else
1155:../freertos/queue.c **** 						{
1156:../freertos/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1157:../freertos/queue.c **** 						}
1158:../freertos/queue.c **** 					}
1159:../freertos/queue.c **** 					else
1160:../freertos/queue.c **** 					{
1161:../freertos/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1162:../freertos/queue.c **** 						{
1163:../freertos/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1164:../freertos/queue.c **** 							{
1165:../freertos/queue.c **** 								/* The task waiting has a higher priority so
1166:../freertos/queue.c **** 								record that a context switch is required. */
1167:../freertos/queue.c **** 								if( pxHigherPriorityTaskWoken != NULL )
1168:../freertos/queue.c **** 								{
1169:../freertos/queue.c **** 									*pxHigherPriorityTaskWoken = pdTRUE;
1170:../freertos/queue.c **** 								}
1171:../freertos/queue.c **** 								else
1172:../freertos/queue.c **** 								{
1173:../freertos/queue.c **** 									mtCOVERAGE_TEST_MARKER();
1174:../freertos/queue.c **** 								}
1175:../freertos/queue.c **** 							}
1176:../freertos/queue.c **** 							else
1177:../freertos/queue.c **** 							{
1178:../freertos/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1179:../freertos/queue.c **** 							}
1180:../freertos/queue.c **** 						}
1181:../freertos/queue.c **** 						else
1182:../freertos/queue.c **** 						{
1183:../freertos/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1184:../freertos/queue.c **** 						}
1185:../freertos/queue.c **** 					}
1186:../freertos/queue.c **** 				}
1187:../freertos/queue.c **** 				#else /* configUSE_QUEUE_SETS */
1188:../freertos/queue.c **** 				{
1189:../freertos/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 1245              		.loc 1 1189 0
 1246 007a BB69     		ldr	r3, [r7, #24]
 1247 007c 5B6A     		ldr	r3, [r3, #36]
 1248 007e 002B     		cmp	r3, #0
 1249 0080 17D0     		beq	.L105
1190:../freertos/queue.c **** 					{
1191:../freertos/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 1250              		.loc 1 1191 0
 1251 0082 BB69     		ldr	r3, [r7, #24]
 1252 0084 2433     		add	r3, r3, #36
 1253 0086 181C     		mov	r0, r3
 1254 0088 FFF7FEFF 		bl	xTaskRemoveFromEventList
 1255 008c 031C     		mov	r3, r0
 1256 008e 002B     		cmp	r3, #0
 1257 0090 0FD0     		beq	.L105
1192:../freertos/queue.c **** 						{
1193:../freertos/queue.c **** 							/* The task waiting has a higher priority so record that a
1194:../freertos/queue.c **** 							context	switch is required. */
1195:../freertos/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
 1258              		.loc 1 1195 0
 1259 0092 3B68     		ldr	r3, [r7]
 1260 0094 002B     		cmp	r3, #0
 1261 0096 0CD0     		beq	.L105
1196:../freertos/queue.c **** 							{
1197:../freertos/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
 1262              		.loc 1 1197 0
 1263 0098 3B68     		ldr	r3, [r7]
 1264 009a 0122     		mov	r2, #1
 1265 009c 1A60     		str	r2, [r3]
 1266 009e 08E0     		b	.L105
 1267              	.L104:
1198:../freertos/queue.c **** 							}
1199:../freertos/queue.c **** 							else
1200:../freertos/queue.c **** 							{
1201:../freertos/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1202:../freertos/queue.c **** 							}
1203:../freertos/queue.c **** 						}
1204:../freertos/queue.c **** 						else
1205:../freertos/queue.c **** 						{
1206:../freertos/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1207:../freertos/queue.c **** 						}
1208:../freertos/queue.c **** 					}
1209:../freertos/queue.c **** 					else
1210:../freertos/queue.c **** 					{
1211:../freertos/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1212:../freertos/queue.c **** 					}
1213:../freertos/queue.c **** 				}
1214:../freertos/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
1215:../freertos/queue.c **** 			}
1216:../freertos/queue.c **** 			else
1217:../freertos/queue.c **** 			{
1218:../freertos/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1219:../freertos/queue.c **** 				knows that data was posted while it was locked. */
1220:../freertos/queue.c **** 				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 1268              		.loc 1 1220 0
 1269 00a0 3B1C     		mov	r3, r7
 1270 00a2 0F33     		add	r3, r3, #15
 1271 00a4 1B78     		ldrb	r3, [r3]
 1272 00a6 0133     		add	r3, r3, #1
 1273 00a8 DBB2     		uxtb	r3, r3
 1274 00aa D9B2     		uxtb	r1, r3
 1275 00ac BA69     		ldr	r2, [r7, #24]
 1276 00ae 4523     		mov	r3, #69
 1277 00b0 D154     		strb	r1, [r2, r3]
 1278              	.L105:
1221:../freertos/queue.c **** 			}
1222:../freertos/queue.c **** 
1223:../freertos/queue.c **** 			xReturn = pdPASS;
 1279              		.loc 1 1223 0 discriminator 4
 1280 00b2 0123     		mov	r3, #1
 1281 00b4 FB61     		str	r3, [r7, #28]
 1282              	.LBE4:
 1283 00b6 01E0     		b	.L106
 1284              	.L103:
1224:../freertos/queue.c **** 		}
1225:../freertos/queue.c **** 		else
1226:../freertos/queue.c **** 		{
1227:../freertos/queue.c **** 			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
1228:../freertos/queue.c **** 			xReturn = errQUEUE_FULL;
 1285              		.loc 1 1228 0
 1286 00b8 0023     		mov	r3, #0
 1287 00ba FB61     		str	r3, [r7, #28]
 1288              	.L106:
 1289              	.LBE3:
1229:../freertos/queue.c **** 		}
1230:../freertos/queue.c **** 	}
1231:../freertos/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 1290              		.loc 1 1231 0
 1291 00bc 7B69     		ldr	r3, [r7, #20]
 1292 00be 181C     		mov	r0, r3
 1293 00c0 FFF7FEFF 		bl	vClearInterruptMaskFromISR
1232:../freertos/queue.c **** 
1233:../freertos/queue.c **** 	return xReturn;
 1294              		.loc 1 1233 0
 1295 00c4 FB69     		ldr	r3, [r7, #28]
1234:../freertos/queue.c **** }
 1296              		.loc 1 1234 0
 1297 00c6 181C     		mov	r0, r3
 1298 00c8 BD46     		mov	sp, r7
 1299 00ca 08B0     		add	sp, sp, #32
 1300              		@ sp needed
 1301 00cc 80BD     		pop	{r7, pc}
 1302              		.cfi_endproc
 1303              	.LFE10:
 1305 00ce C046     		.section	.text.xQueueGenericReceive,"ax",%progbits
 1306              		.align	2
 1307              		.global	xQueueGenericReceive
 1308              		.code	16
 1309              		.thumb_func
 1311              	xQueueGenericReceive:
 1312              	.LFB11:
1235:../freertos/queue.c **** /*-----------------------------------------------------------*/
1236:../freertos/queue.c **** 
1237:../freertos/queue.c **** BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWa
1238:../freertos/queue.c **** {
 1313              		.loc 1 1238 0
 1314              		.cfi_startproc
 1315 0000 80B5     		push	{r7, lr}
 1316              		.cfi_def_cfa_offset 8
 1317              		.cfi_offset 7, -8
 1318              		.cfi_offset 14, -4
 1319 0002 8AB0     		sub	sp, sp, #40
 1320              		.cfi_def_cfa_offset 48
 1321 0004 00AF     		add	r7, sp, #0
 1322              		.cfi_def_cfa_register 7
 1323 0006 F860     		str	r0, [r7, #12]
 1324 0008 B960     		str	r1, [r7, #8]
 1325 000a 7A60     		str	r2, [r7, #4]
 1326 000c 3B60     		str	r3, [r7]
1239:../freertos/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
 1327              		.loc 1 1239 0
 1328 000e 0023     		mov	r3, #0
 1329 0010 7B62     		str	r3, [r7, #36]
1240:../freertos/queue.c **** TimeOut_t xTimeOut;
1241:../freertos/queue.c **** int8_t *pcOriginalReadPosition;
1242:../freertos/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 1330              		.loc 1 1242 0
 1331 0012 FB68     		ldr	r3, [r7, #12]
 1332 0014 3B62     		str	r3, [r7, #32]
1243:../freertos/queue.c **** 
1244:../freertos/queue.c **** 	configASSERT( pxQueue );
 1333              		.loc 1 1244 0
 1334 0016 3B6A     		ldr	r3, [r7, #32]
 1335 0018 002B     		cmp	r3, #0
 1336 001a 01D1     		bne	.L109
 1337              		.loc 1 1244 0 is_stmt 0 discriminator 1
 1338              	@ 1244 "../freertos/queue.c" 1
 1339 001c 72B6     		 cpsid i 
 1340              	@ 0 "" 2
 1341              		.code	16
 1342              	.L110:
 1343 001e FEE7     		b	.L110
 1344              	.L109:
1245:../freertos/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 1345              		.loc 1 1245 0 is_stmt 1
 1346 0020 BB68     		ldr	r3, [r7, #8]
 1347 0022 002B     		cmp	r3, #0
 1348 0024 03D1     		bne	.L111
 1349              		.loc 1 1245 0 is_stmt 0 discriminator 2
 1350 0026 3B6A     		ldr	r3, [r7, #32]
 1351 0028 1B6C     		ldr	r3, [r3, #64]
 1352 002a 002B     		cmp	r3, #0
 1353 002c 01D1     		bne	.L112
 1354              	.L111:
 1355              		.loc 1 1245 0 discriminator 1
 1356 002e 0123     		mov	r3, #1
 1357 0030 00E0     		b	.L113
 1358              	.L112:
 1359              		.loc 1 1245 0 discriminator 3
 1360 0032 0023     		mov	r3, #0
 1361              	.L113:
 1362              		.loc 1 1245 0 discriminator 4
 1363 0034 002B     		cmp	r3, #0
 1364 0036 01D1     		bne	.L114
 1365              		.loc 1 1245 0 discriminator 1
 1366              	@ 1245 "../freertos/queue.c" 1
 1367 0038 72B6     		 cpsid i 
 1368              	@ 0 "" 2
 1369              		.code	16
 1370              	.L115:
 1371 003a FEE7     		b	.L115
 1372              	.L114:
1246:../freertos/queue.c **** 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1247:../freertos/queue.c **** 	{
1248:../freertos/queue.c **** 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 )
 1373              		.loc 1 1248 0 is_stmt 1
 1374 003c FFF7FEFF 		bl	xTaskGetSchedulerState
 1375 0040 031C     		mov	r3, r0
 1376 0042 002B     		cmp	r3, #0
 1377 0044 02D1     		bne	.L116
 1378              		.loc 1 1248 0 is_stmt 0 discriminator 2
 1379 0046 7B68     		ldr	r3, [r7, #4]
 1380 0048 002B     		cmp	r3, #0
 1381 004a 01D1     		bne	.L117
 1382              	.L116:
 1383              		.loc 1 1248 0 discriminator 1
 1384 004c 0123     		mov	r3, #1
 1385 004e 00E0     		b	.L118
 1386              	.L117:
 1387              		.loc 1 1248 0 discriminator 3
 1388 0050 0023     		mov	r3, #0
 1389              	.L118:
 1390              		.loc 1 1248 0 discriminator 4
 1391 0052 002B     		cmp	r3, #0
 1392 0054 01D1     		bne	.L119
 1393              		.loc 1 1248 0 discriminator 1
 1394              	@ 1248 "../freertos/queue.c" 1
 1395 0056 72B6     		 cpsid i 
 1396              	@ 0 "" 2
 1397              		.code	16
 1398              	.L120:
 1399 0058 FEE7     		b	.L120
 1400              	.L119:
1249:../freertos/queue.c **** 	}
1250:../freertos/queue.c **** 	#endif
1251:../freertos/queue.c **** 
1252:../freertos/queue.c **** 	/* This function relaxes the coding standard somewhat to allow return
1253:../freertos/queue.c **** 	statements within the function itself.  This is done in the interest
1254:../freertos/queue.c **** 	of execution time efficiency. */
1255:../freertos/queue.c **** 
1256:../freertos/queue.c **** 	for( ;; )
1257:../freertos/queue.c **** 	{
1258:../freertos/queue.c **** 		taskENTER_CRITICAL();
 1401              		.loc 1 1258 0 is_stmt 1
 1402 005a FFF7FEFF 		bl	vPortEnterCritical
 1403              	.LBB5:
1259:../freertos/queue.c **** 		{
1260:../freertos/queue.c **** 			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 1404              		.loc 1 1260 0
 1405 005e 3B6A     		ldr	r3, [r7, #32]
 1406 0060 9B6B     		ldr	r3, [r3, #56]
 1407 0062 FB61     		str	r3, [r7, #28]
1261:../freertos/queue.c **** 
1262:../freertos/queue.c **** 			/* Is there data in the queue now?  To be running the calling task
1263:../freertos/queue.c **** 			must be the highest priority task wanting to access the queue. */
1264:../freertos/queue.c **** 			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 1408              		.loc 1 1264 0
 1409 0064 FB69     		ldr	r3, [r7, #28]
 1410 0066 002B     		cmp	r3, #0
 1411 0068 3CD0     		beq	.L121
1265:../freertos/queue.c **** 			{
1266:../freertos/queue.c **** 				/* Remember the read position in case the queue is only being
1267:../freertos/queue.c **** 				peeked. */
1268:../freertos/queue.c **** 				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
 1412              		.loc 1 1268 0
 1413 006a 3B6A     		ldr	r3, [r7, #32]
 1414 006c DB68     		ldr	r3, [r3, #12]
 1415 006e BB61     		str	r3, [r7, #24]
1269:../freertos/queue.c **** 
1270:../freertos/queue.c **** 				prvCopyDataFromQueue( pxQueue, pvBuffer );
 1416              		.loc 1 1270 0
 1417 0070 3A6A     		ldr	r2, [r7, #32]
 1418 0072 BB68     		ldr	r3, [r7, #8]
 1419 0074 101C     		mov	r0, r2
 1420 0076 191C     		mov	r1, r3
 1421 0078 FFF7FEFF 		bl	prvCopyDataFromQueue
1271:../freertos/queue.c **** 
1272:../freertos/queue.c **** 				if( xJustPeeking == pdFALSE )
 1422              		.loc 1 1272 0
 1423 007c 3B68     		ldr	r3, [r7]
 1424 007e 002B     		cmp	r3, #0
 1425 0080 1BD1     		bne	.L122
1273:../freertos/queue.c **** 				{
1274:../freertos/queue.c **** 					traceQUEUE_RECEIVE( pxQueue );
1275:../freertos/queue.c **** 
1276:../freertos/queue.c **** 					/* Actually removing data, not just peeking. */
1277:../freertos/queue.c **** 					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
 1426              		.loc 1 1277 0
 1427 0082 FB69     		ldr	r3, [r7, #28]
 1428 0084 5A1E     		sub	r2, r3, #1
 1429 0086 3B6A     		ldr	r3, [r7, #32]
 1430 0088 9A63     		str	r2, [r3, #56]
1278:../freertos/queue.c **** 
1279:../freertos/queue.c **** 					#if ( configUSE_MUTEXES == 1 )
1280:../freertos/queue.c **** 					{
1281:../freertos/queue.c **** 						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 1431              		.loc 1 1281 0
 1432 008a 3B6A     		ldr	r3, [r7, #32]
 1433 008c 1B68     		ldr	r3, [r3]
 1434 008e 002B     		cmp	r3, #0
 1435 0090 04D1     		bne	.L123
1282:../freertos/queue.c **** 						{
1283:../freertos/queue.c **** 							/* Record the information required to implement
1284:../freertos/queue.c **** 							priority inheritance should it become necessary. */
1285:../freertos/queue.c **** 							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is 
 1436              		.loc 1 1285 0
 1437 0092 FFF7FEFF 		bl	pvTaskIncrementMutexHeldCount
 1438 0096 021C     		mov	r2, r0
 1439 0098 3B6A     		ldr	r3, [r7, #32]
 1440 009a 5A60     		str	r2, [r3, #4]
 1441              	.L123:
1286:../freertos/queue.c **** 						}
1287:../freertos/queue.c **** 						else
1288:../freertos/queue.c **** 						{
1289:../freertos/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1290:../freertos/queue.c **** 						}
1291:../freertos/queue.c **** 					}
1292:../freertos/queue.c **** 					#endif /* configUSE_MUTEXES */
1293:../freertos/queue.c **** 
1294:../freertos/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 1442              		.loc 1 1294 0
 1443 009c 3B6A     		ldr	r3, [r7, #32]
 1444 009e 1B69     		ldr	r3, [r3, #16]
 1445 00a0 002B     		cmp	r3, #0
 1446 00a2 1BD0     		beq	.L124
1295:../freertos/queue.c **** 					{
1296:../freertos/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 1447              		.loc 1 1296 0
 1448 00a4 3B6A     		ldr	r3, [r7, #32]
 1449 00a6 1033     		add	r3, r3, #16
 1450 00a8 181C     		mov	r0, r3
 1451 00aa FFF7FEFF 		bl	xTaskRemoveFromEventList
 1452 00ae 031C     		mov	r3, r0
 1453 00b0 002B     		cmp	r3, #0
 1454 00b2 13D0     		beq	.L124
1297:../freertos/queue.c **** 						{
1298:../freertos/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 1455              		.loc 1 1298 0
 1456 00b4 FFF7FEFF 		bl	vPortYield
 1457 00b8 10E0     		b	.L124
 1458              	.L122:
1299:../freertos/queue.c **** 						}
1300:../freertos/queue.c **** 						else
1301:../freertos/queue.c **** 						{
1302:../freertos/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1303:../freertos/queue.c **** 						}
1304:../freertos/queue.c **** 					}
1305:../freertos/queue.c **** 					else
1306:../freertos/queue.c **** 					{
1307:../freertos/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1308:../freertos/queue.c **** 					}
1309:../freertos/queue.c **** 				}
1310:../freertos/queue.c **** 				else
1311:../freertos/queue.c **** 				{
1312:../freertos/queue.c **** 					traceQUEUE_PEEK( pxQueue );
1313:../freertos/queue.c **** 
1314:../freertos/queue.c **** 					/* The data is not being removed, so reset the read
1315:../freertos/queue.c **** 					pointer. */
1316:../freertos/queue.c **** 					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
 1459              		.loc 1 1316 0
 1460 00ba 3B6A     		ldr	r3, [r7, #32]
 1461 00bc BA69     		ldr	r2, [r7, #24]
 1462 00be DA60     		str	r2, [r3, #12]
1317:../freertos/queue.c **** 
1318:../freertos/queue.c **** 					/* The data is being left in the queue, so see if there are
1319:../freertos/queue.c **** 					any other tasks waiting for the data. */
1320:../freertos/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 1463              		.loc 1 1320 0
 1464 00c0 3B6A     		ldr	r3, [r7, #32]
 1465 00c2 5B6A     		ldr	r3, [r3, #36]
 1466 00c4 002B     		cmp	r3, #0
 1467 00c6 09D0     		beq	.L124
1321:../freertos/queue.c **** 					{
1322:../freertos/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 1468              		.loc 1 1322 0
 1469 00c8 3B6A     		ldr	r3, [r7, #32]
 1470 00ca 2433     		add	r3, r3, #36
 1471 00cc 181C     		mov	r0, r3
 1472 00ce FFF7FEFF 		bl	xTaskRemoveFromEventList
 1473 00d2 031C     		mov	r3, r0
 1474 00d4 002B     		cmp	r3, #0
 1475 00d6 01D0     		beq	.L124
1323:../freertos/queue.c **** 						{
1324:../freertos/queue.c **** 							/* The task waiting has a higher priority than this task. */
1325:../freertos/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 1476              		.loc 1 1325 0
 1477 00d8 FFF7FEFF 		bl	vPortYield
 1478              	.L124:
1326:../freertos/queue.c **** 						}
1327:../freertos/queue.c **** 						else
1328:../freertos/queue.c **** 						{
1329:../freertos/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1330:../freertos/queue.c **** 						}
1331:../freertos/queue.c **** 					}
1332:../freertos/queue.c **** 					else
1333:../freertos/queue.c **** 					{
1334:../freertos/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1335:../freertos/queue.c **** 					}
1336:../freertos/queue.c **** 				}
1337:../freertos/queue.c **** 
1338:../freertos/queue.c **** 				taskEXIT_CRITICAL();
 1479              		.loc 1 1338 0
 1480 00dc FFF7FEFF 		bl	vPortExitCritical
1339:../freertos/queue.c **** 				return pdPASS;
 1481              		.loc 1 1339 0
 1482 00e0 0123     		mov	r3, #1
 1483 00e2 77E0     		b	.L135
 1484              	.L121:
1340:../freertos/queue.c **** 			}
1341:../freertos/queue.c **** 			else
1342:../freertos/queue.c **** 			{
1343:../freertos/queue.c **** 				if( xTicksToWait == ( TickType_t ) 0 )
 1485              		.loc 1 1343 0
 1486 00e4 7B68     		ldr	r3, [r7, #4]
 1487 00e6 002B     		cmp	r3, #0
 1488 00e8 03D1     		bne	.L126
1344:../freertos/queue.c **** 				{
1345:../freertos/queue.c **** 					/* The queue was empty and no block time is specified (or
1346:../freertos/queue.c **** 					the block time has expired) so leave now. */
1347:../freertos/queue.c **** 					taskEXIT_CRITICAL();
 1489              		.loc 1 1347 0
 1490 00ea FFF7FEFF 		bl	vPortExitCritical
1348:../freertos/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
1349:../freertos/queue.c **** 					return errQUEUE_EMPTY;
 1491              		.loc 1 1349 0
 1492 00ee 0023     		mov	r3, #0
 1493 00f0 70E0     		b	.L135
 1494              	.L126:
1350:../freertos/queue.c **** 				}
1351:../freertos/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 1495              		.loc 1 1351 0
 1496 00f2 7B6A     		ldr	r3, [r7, #36]
 1497 00f4 002B     		cmp	r3, #0
 1498 00f6 06D1     		bne	.L127
1352:../freertos/queue.c **** 				{
1353:../freertos/queue.c **** 					/* The queue was empty and a block time was specified so
1354:../freertos/queue.c **** 					configure the timeout structure. */
1355:../freertos/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 1499              		.loc 1 1355 0
 1500 00f8 3B1C     		mov	r3, r7
 1501 00fa 1033     		add	r3, r3, #16
 1502 00fc 181C     		mov	r0, r3
 1503 00fe FFF7FEFF 		bl	vTaskSetTimeOutState
1356:../freertos/queue.c **** 					xEntryTimeSet = pdTRUE;
 1504              		.loc 1 1356 0
 1505 0102 0123     		mov	r3, #1
 1506 0104 7B62     		str	r3, [r7, #36]
 1507              	.L127:
 1508              	.LBE5:
1357:../freertos/queue.c **** 				}
1358:../freertos/queue.c **** 				else
1359:../freertos/queue.c **** 				{
1360:../freertos/queue.c **** 					/* Entry time was already set. */
1361:../freertos/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1362:../freertos/queue.c **** 				}
1363:../freertos/queue.c **** 			}
1364:../freertos/queue.c **** 		}
1365:../freertos/queue.c **** 		taskEXIT_CRITICAL();
 1509              		.loc 1 1365 0
 1510 0106 FFF7FEFF 		bl	vPortExitCritical
1366:../freertos/queue.c **** 
1367:../freertos/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
1368:../freertos/queue.c **** 		now the critical section has been exited. */
1369:../freertos/queue.c **** 
1370:../freertos/queue.c **** 		vTaskSuspendAll();
 1511              		.loc 1 1370 0
 1512 010a FFF7FEFF 		bl	vTaskSuspendAll
1371:../freertos/queue.c **** 		prvLockQueue( pxQueue );
 1513              		.loc 1 1371 0
 1514 010e FFF7FEFF 		bl	vPortEnterCritical
 1515 0112 3A6A     		ldr	r2, [r7, #32]
 1516 0114 4423     		mov	r3, #68
 1517 0116 D35C     		ldrb	r3, [r2, r3]
 1518 0118 DBB2     		uxtb	r3, r3
 1519 011a 5BB2     		sxtb	r3, r3
 1520 011c 0133     		add	r3, r3, #1
 1521 011e 03D1     		bne	.L128
 1522              		.loc 1 1371 0 is_stmt 0 discriminator 1
 1523 0120 3A6A     		ldr	r2, [r7, #32]
 1524 0122 4423     		mov	r3, #68
 1525 0124 0021     		mov	r1, #0
 1526 0126 D154     		strb	r1, [r2, r3]
 1527              	.L128:
 1528              		.loc 1 1371 0 discriminator 2
 1529 0128 3A6A     		ldr	r2, [r7, #32]
 1530 012a 4523     		mov	r3, #69
 1531 012c D35C     		ldrb	r3, [r2, r3]
 1532 012e DBB2     		uxtb	r3, r3
 1533 0130 5BB2     		sxtb	r3, r3
 1534 0132 0133     		add	r3, r3, #1
 1535 0134 03D1     		bne	.L129
 1536              		.loc 1 1371 0 discriminator 1
 1537 0136 3A6A     		ldr	r2, [r7, #32]
 1538 0138 4523     		mov	r3, #69
 1539 013a 0021     		mov	r1, #0
 1540 013c D154     		strb	r1, [r2, r3]
 1541              	.L129:
 1542              		.loc 1 1371 0 discriminator 2
 1543 013e FFF7FEFF 		bl	vPortExitCritical
1372:../freertos/queue.c **** 
1373:../freertos/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
1374:../freertos/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 1544              		.loc 1 1374 0 is_stmt 1 discriminator 2
 1545 0142 3A1C     		mov	r2, r7
 1546 0144 1032     		add	r2, r2, #16
 1547 0146 3B1D     		add	r3, r7, #4
 1548 0148 101C     		mov	r0, r2
 1549 014a 191C     		mov	r1, r3
 1550 014c FFF7FEFF 		bl	xTaskCheckForTimeOut
 1551 0150 031C     		mov	r3, r0
 1552 0152 002B     		cmp	r3, #0
 1553 0154 2ED1     		bne	.L130
1375:../freertos/queue.c **** 		{
1376:../freertos/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 1554              		.loc 1 1376 0
 1555 0156 3B6A     		ldr	r3, [r7, #32]
 1556 0158 181C     		mov	r0, r3
 1557 015a FFF7FEFF 		bl	prvIsQueueEmpty
 1558 015e 031C     		mov	r3, r0
 1559 0160 002B     		cmp	r3, #0
 1560 0162 20D0     		beq	.L131
1377:../freertos/queue.c **** 			{
1378:../freertos/queue.c **** 				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
1379:../freertos/queue.c **** 
1380:../freertos/queue.c **** 				#if ( configUSE_MUTEXES == 1 )
1381:../freertos/queue.c **** 				{
1382:../freertos/queue.c **** 					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 1561              		.loc 1 1382 0
 1562 0164 3B6A     		ldr	r3, [r7, #32]
 1563 0166 1B68     		ldr	r3, [r3]
 1564 0168 002B     		cmp	r3, #0
 1565 016a 08D1     		bne	.L132
1383:../freertos/queue.c **** 					{
1384:../freertos/queue.c **** 						taskENTER_CRITICAL();
 1566              		.loc 1 1384 0
 1567 016c FFF7FEFF 		bl	vPortEnterCritical
1385:../freertos/queue.c **** 						{
1386:../freertos/queue.c **** 							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 1568              		.loc 1 1386 0
 1569 0170 3B6A     		ldr	r3, [r7, #32]
 1570 0172 5B68     		ldr	r3, [r3, #4]
 1571 0174 181C     		mov	r0, r3
 1572 0176 FFF7FEFF 		bl	vTaskPriorityInherit
1387:../freertos/queue.c **** 						}
1388:../freertos/queue.c **** 						taskEXIT_CRITICAL();
 1573              		.loc 1 1388 0
 1574 017a FFF7FEFF 		bl	vPortExitCritical
 1575              	.L132:
1389:../freertos/queue.c **** 					}
1390:../freertos/queue.c **** 					else
1391:../freertos/queue.c **** 					{
1392:../freertos/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1393:../freertos/queue.c **** 					}
1394:../freertos/queue.c **** 				}
1395:../freertos/queue.c **** 				#endif
1396:../freertos/queue.c **** 
1397:../freertos/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 1576              		.loc 1 1397 0
 1577 017e 3B6A     		ldr	r3, [r7, #32]
 1578 0180 1A1C     		mov	r2, r3
 1579 0182 2432     		add	r2, r2, #36
 1580 0184 7B68     		ldr	r3, [r7, #4]
 1581 0186 101C     		mov	r0, r2
 1582 0188 191C     		mov	r1, r3
 1583 018a FFF7FEFF 		bl	vTaskPlaceOnEventList
1398:../freertos/queue.c **** 				prvUnlockQueue( pxQueue );
 1584              		.loc 1 1398 0
 1585 018e 3B6A     		ldr	r3, [r7, #32]
 1586 0190 181C     		mov	r0, r3
 1587 0192 FFF7FEFF 		bl	prvUnlockQueue
1399:../freertos/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 1588              		.loc 1 1399 0
 1589 0196 FFF7FEFF 		bl	xTaskResumeAll
 1590 019a 031C     		mov	r3, r0
 1591 019c 002B     		cmp	r3, #0
 1592 019e 18D1     		bne	.L134
1400:../freertos/queue.c **** 				{
1401:../freertos/queue.c **** 					portYIELD_WITHIN_API();
 1593              		.loc 1 1401 0
 1594 01a0 FFF7FEFF 		bl	vPortYield
 1595 01a4 15E0     		b	.L134
 1596              	.L131:
1402:../freertos/queue.c **** 				}
1403:../freertos/queue.c **** 				else
1404:../freertos/queue.c **** 				{
1405:../freertos/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1406:../freertos/queue.c **** 				}
1407:../freertos/queue.c **** 			}
1408:../freertos/queue.c **** 			else
1409:../freertos/queue.c **** 			{
1410:../freertos/queue.c **** 				/* Try again. */
1411:../freertos/queue.c **** 				prvUnlockQueue( pxQueue );
 1597              		.loc 1 1411 0
 1598 01a6 3B6A     		ldr	r3, [r7, #32]
 1599 01a8 181C     		mov	r0, r3
 1600 01aa FFF7FEFF 		bl	prvUnlockQueue
1412:../freertos/queue.c **** 				( void ) xTaskResumeAll();
 1601              		.loc 1 1412 0
 1602 01ae FFF7FEFF 		bl	xTaskResumeAll
1413:../freertos/queue.c **** 			}
1414:../freertos/queue.c **** 		}
1415:../freertos/queue.c **** 		else
1416:../freertos/queue.c **** 		{
1417:../freertos/queue.c **** 			prvUnlockQueue( pxQueue );
1418:../freertos/queue.c **** 			( void ) xTaskResumeAll();
1419:../freertos/queue.c **** 
1420:../freertos/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1421:../freertos/queue.c **** 			{
1422:../freertos/queue.c **** 				traceQUEUE_RECEIVE_FAILED( pxQueue );
1423:../freertos/queue.c **** 				return errQUEUE_EMPTY;
1424:../freertos/queue.c **** 			}
1425:../freertos/queue.c **** 			else
1426:../freertos/queue.c **** 			{
1427:../freertos/queue.c **** 				mtCOVERAGE_TEST_MARKER();
1428:../freertos/queue.c **** 			}
1429:../freertos/queue.c **** 		}
1430:../freertos/queue.c **** 	}
 1603              		.loc 1 1430 0
 1604 01b2 52E7     		b	.L119
 1605              	.L130:
1417:../freertos/queue.c **** 			prvUnlockQueue( pxQueue );
 1606              		.loc 1 1417 0
 1607 01b4 3B6A     		ldr	r3, [r7, #32]
 1608 01b6 181C     		mov	r0, r3
 1609 01b8 FFF7FEFF 		bl	prvUnlockQueue
1418:../freertos/queue.c **** 			( void ) xTaskResumeAll();
 1610              		.loc 1 1418 0
 1611 01bc FFF7FEFF 		bl	xTaskResumeAll
1420:../freertos/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 1612              		.loc 1 1420 0
 1613 01c0 3B6A     		ldr	r3, [r7, #32]
 1614 01c2 181C     		mov	r0, r3
 1615 01c4 FFF7FEFF 		bl	prvIsQueueEmpty
 1616 01c8 031C     		mov	r3, r0
 1617 01ca 002B     		cmp	r3, #0
 1618 01cc 01D0     		beq	.L134
1423:../freertos/queue.c **** 				return errQUEUE_EMPTY;
 1619              		.loc 1 1423 0
 1620 01ce 0023     		mov	r3, #0
 1621 01d0 00E0     		b	.L135
 1622              	.L134:
 1623              		.loc 1 1430 0
 1624 01d2 42E7     		b	.L119
 1625              	.L135:
1431:../freertos/queue.c **** }
 1626              		.loc 1 1431 0
 1627 01d4 181C     		mov	r0, r3
 1628 01d6 BD46     		mov	sp, r7
 1629 01d8 0AB0     		add	sp, sp, #40
 1630              		@ sp needed
 1631 01da 80BD     		pop	{r7, pc}
 1632              		.cfi_endproc
 1633              	.LFE11:
 1635              		.section	.text.xQueueReceiveFromISR,"ax",%progbits
 1636              		.align	2
 1637              		.global	xQueueReceiveFromISR
 1638              		.code	16
 1639              		.thumb_func
 1641              	xQueueReceiveFromISR:
 1642              	.LFB12:
1432:../freertos/queue.c **** /*-----------------------------------------------------------*/
1433:../freertos/queue.c **** 
1434:../freertos/queue.c **** BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const px
1435:../freertos/queue.c **** {
 1643              		.loc 1 1435 0
 1644              		.cfi_startproc
 1645 0000 80B5     		push	{r7, lr}
 1646              		.cfi_def_cfa_offset 8
 1647              		.cfi_offset 7, -8
 1648              		.cfi_offset 14, -4
 1649 0002 8AB0     		sub	sp, sp, #40
 1650              		.cfi_def_cfa_offset 48
 1651 0004 00AF     		add	r7, sp, #0
 1652              		.cfi_def_cfa_register 7
 1653 0006 F860     		str	r0, [r7, #12]
 1654 0008 B960     		str	r1, [r7, #8]
 1655 000a 7A60     		str	r2, [r7, #4]
1436:../freertos/queue.c **** BaseType_t xReturn;
1437:../freertos/queue.c **** UBaseType_t uxSavedInterruptStatus;
1438:../freertos/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 1656              		.loc 1 1438 0
 1657 000c FB68     		ldr	r3, [r7, #12]
 1658 000e 3B62     		str	r3, [r7, #32]
1439:../freertos/queue.c **** 
1440:../freertos/queue.c **** 	configASSERT( pxQueue );
 1659              		.loc 1 1440 0
 1660 0010 3B6A     		ldr	r3, [r7, #32]
 1661 0012 002B     		cmp	r3, #0
 1662 0014 01D1     		bne	.L137
 1663              		.loc 1 1440 0 is_stmt 0 discriminator 1
 1664              	@ 1440 "../freertos/queue.c" 1
 1665 0016 72B6     		 cpsid i 
 1666              	@ 0 "" 2
 1667              		.code	16
 1668              	.L138:
 1669 0018 FEE7     		b	.L138
 1670              	.L137:
1441:../freertos/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 1671              		.loc 1 1441 0 is_stmt 1
 1672 001a BB68     		ldr	r3, [r7, #8]
 1673 001c 002B     		cmp	r3, #0
 1674 001e 03D1     		bne	.L139
 1675              		.loc 1 1441 0 is_stmt 0 discriminator 2
 1676 0020 3B6A     		ldr	r3, [r7, #32]
 1677 0022 1B6C     		ldr	r3, [r3, #64]
 1678 0024 002B     		cmp	r3, #0
 1679 0026 01D1     		bne	.L140
 1680              	.L139:
 1681              		.loc 1 1441 0 discriminator 1
 1682 0028 0123     		mov	r3, #1
 1683 002a 00E0     		b	.L141
 1684              	.L140:
 1685              		.loc 1 1441 0 discriminator 3
 1686 002c 0023     		mov	r3, #0
 1687              	.L141:
 1688              		.loc 1 1441 0 discriminator 4
 1689 002e 002B     		cmp	r3, #0
 1690 0030 01D1     		bne	.L142
 1691              		.loc 1 1441 0 discriminator 1
 1692              	@ 1441 "../freertos/queue.c" 1
 1693 0032 72B6     		 cpsid i 
 1694              	@ 0 "" 2
 1695              		.code	16
 1696              	.L143:
 1697 0034 FEE7     		b	.L143
 1698              	.L142:
1442:../freertos/queue.c **** 
1443:../freertos/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1444:../freertos/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1445:../freertos/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
1446:../freertos/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1447:../freertos/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1448:../freertos/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1449:../freertos/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1450:../freertos/queue.c **** 	assigned a priority above the configured maximum system call priority.
1451:../freertos/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1452:../freertos/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
1453:../freertos/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1454:../freertos/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1455:../freertos/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
1456:../freertos/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1457:../freertos/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1458:../freertos/queue.c **** 
1459:../freertos/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1699              		.loc 1 1459 0 is_stmt 1
 1700 0036 FFF7FEFF 		bl	ulSetInterruptMaskFromISR
 1701 003a 031C     		mov	r3, r0
 1702 003c FB61     		str	r3, [r7, #28]
 1703              	.LBB6:
1460:../freertos/queue.c **** 	{
1461:../freertos/queue.c **** 		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 1704              		.loc 1 1461 0
 1705 003e 3B6A     		ldr	r3, [r7, #32]
 1706 0040 9B6B     		ldr	r3, [r3, #56]
 1707 0042 BB61     		str	r3, [r7, #24]
1462:../freertos/queue.c **** 
1463:../freertos/queue.c **** 		/* Cannot block in an ISR, so check there is data available. */
1464:../freertos/queue.c **** 		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 1708              		.loc 1 1464 0
 1709 0044 BB69     		ldr	r3, [r7, #24]
 1710 0046 002B     		cmp	r3, #0
 1711 0048 34D0     		beq	.L144
 1712              	.LBB7:
1465:../freertos/queue.c **** 		{
1466:../freertos/queue.c **** 			const int8_t cRxLock = pxQueue->cRxLock;
 1713              		.loc 1 1466 0
 1714 004a 3B1C     		mov	r3, r7
 1715 004c 1733     		add	r3, r3, #23
 1716 004e 396A     		ldr	r1, [r7, #32]
 1717 0050 4422     		mov	r2, #68
 1718 0052 8A5C     		ldrb	r2, [r1, r2]
 1719 0054 1A70     		strb	r2, [r3]
1467:../freertos/queue.c **** 
1468:../freertos/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
1469:../freertos/queue.c **** 
1470:../freertos/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
 1720              		.loc 1 1470 0
 1721 0056 3A6A     		ldr	r2, [r7, #32]
 1722 0058 BB68     		ldr	r3, [r7, #8]
 1723 005a 101C     		mov	r0, r2
 1724 005c 191C     		mov	r1, r3
 1725 005e FFF7FEFF 		bl	prvCopyDataFromQueue
1471:../freertos/queue.c **** 			pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
 1726              		.loc 1 1471 0
 1727 0062 BB69     		ldr	r3, [r7, #24]
 1728 0064 5A1E     		sub	r2, r3, #1
 1729 0066 3B6A     		ldr	r3, [r7, #32]
 1730 0068 9A63     		str	r2, [r3, #56]
1472:../freertos/queue.c **** 
1473:../freertos/queue.c **** 			/* If the queue is locked the event list will not be modified.
1474:../freertos/queue.c **** 			Instead update the lock count so the task that unlocks the queue
1475:../freertos/queue.c **** 			will know that an ISR has removed data while the queue was
1476:../freertos/queue.c **** 			locked. */
1477:../freertos/queue.c **** 			if( cRxLock == queueUNLOCKED )
 1731              		.loc 1 1477 0
 1732 006a 3B1C     		mov	r3, r7
 1733 006c 1733     		add	r3, r3, #23
 1734 006e 1B78     		ldrb	r3, [r3]
 1735 0070 5BB2     		sxtb	r3, r3
 1736 0072 0133     		add	r3, r3, #1
 1737 0074 12D1     		bne	.L145
1478:../freertos/queue.c **** 			{
1479:../freertos/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 1738              		.loc 1 1479 0
 1739 0076 3B6A     		ldr	r3, [r7, #32]
 1740 0078 1B69     		ldr	r3, [r3, #16]
 1741 007a 002B     		cmp	r3, #0
 1742 007c 17D0     		beq	.L146
1480:../freertos/queue.c **** 				{
1481:../freertos/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 1743              		.loc 1 1481 0
 1744 007e 3B6A     		ldr	r3, [r7, #32]
 1745 0080 1033     		add	r3, r3, #16
 1746 0082 181C     		mov	r0, r3
 1747 0084 FFF7FEFF 		bl	xTaskRemoveFromEventList
 1748 0088 031C     		mov	r3, r0
 1749 008a 002B     		cmp	r3, #0
 1750 008c 0FD0     		beq	.L146
1482:../freertos/queue.c **** 					{
1483:../freertos/queue.c **** 						/* The task waiting has a higher priority than us so
1484:../freertos/queue.c **** 						force a context switch. */
1485:../freertos/queue.c **** 						if( pxHigherPriorityTaskWoken != NULL )
 1751              		.loc 1 1485 0
 1752 008e 7B68     		ldr	r3, [r7, #4]
 1753 0090 002B     		cmp	r3, #0
 1754 0092 0CD0     		beq	.L146
1486:../freertos/queue.c **** 						{
1487:../freertos/queue.c **** 							*pxHigherPriorityTaskWoken = pdTRUE;
 1755              		.loc 1 1487 0
 1756 0094 7B68     		ldr	r3, [r7, #4]
 1757 0096 0122     		mov	r2, #1
 1758 0098 1A60     		str	r2, [r3]
 1759 009a 08E0     		b	.L146
 1760              	.L145:
1488:../freertos/queue.c **** 						}
1489:../freertos/queue.c **** 						else
1490:../freertos/queue.c **** 						{
1491:../freertos/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1492:../freertos/queue.c **** 						}
1493:../freertos/queue.c **** 					}
1494:../freertos/queue.c **** 					else
1495:../freertos/queue.c **** 					{
1496:../freertos/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1497:../freertos/queue.c **** 					}
1498:../freertos/queue.c **** 				}
1499:../freertos/queue.c **** 				else
1500:../freertos/queue.c **** 				{
1501:../freertos/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1502:../freertos/queue.c **** 				}
1503:../freertos/queue.c **** 			}
1504:../freertos/queue.c **** 			else
1505:../freertos/queue.c **** 			{
1506:../freertos/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1507:../freertos/queue.c **** 				knows that data was removed while it was locked. */
1508:../freertos/queue.c **** 				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
 1761              		.loc 1 1508 0
 1762 009c 3B1C     		mov	r3, r7
 1763 009e 1733     		add	r3, r3, #23
 1764 00a0 1B78     		ldrb	r3, [r3]
 1765 00a2 0133     		add	r3, r3, #1
 1766 00a4 DBB2     		uxtb	r3, r3
 1767 00a6 D9B2     		uxtb	r1, r3
 1768 00a8 3A6A     		ldr	r2, [r7, #32]
 1769 00aa 4423     		mov	r3, #68
 1770 00ac D154     		strb	r1, [r2, r3]
 1771              	.L146:
1509:../freertos/queue.c **** 			}
1510:../freertos/queue.c **** 
1511:../freertos/queue.c **** 			xReturn = pdPASS;
 1772              		.loc 1 1511 0 discriminator 4
 1773 00ae 0123     		mov	r3, #1
 1774 00b0 7B62     		str	r3, [r7, #36]
 1775              	.LBE7:
 1776 00b2 01E0     		b	.L147
 1777              	.L144:
1512:../freertos/queue.c **** 		}
1513:../freertos/queue.c **** 		else
1514:../freertos/queue.c **** 		{
1515:../freertos/queue.c **** 			xReturn = pdFAIL;
 1778              		.loc 1 1515 0
 1779 00b4 0023     		mov	r3, #0
 1780 00b6 7B62     		str	r3, [r7, #36]
 1781              	.L147:
 1782              	.LBE6:
1516:../freertos/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
1517:../freertos/queue.c **** 		}
1518:../freertos/queue.c **** 	}
1519:../freertos/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 1783              		.loc 1 1519 0
 1784 00b8 FB69     		ldr	r3, [r7, #28]
 1785 00ba 181C     		mov	r0, r3
 1786 00bc FFF7FEFF 		bl	vClearInterruptMaskFromISR
1520:../freertos/queue.c **** 
1521:../freertos/queue.c **** 	return xReturn;
 1787              		.loc 1 1521 0
 1788 00c0 7B6A     		ldr	r3, [r7, #36]
1522:../freertos/queue.c **** }
 1789              		.loc 1 1522 0
 1790 00c2 181C     		mov	r0, r3
 1791 00c4 BD46     		mov	sp, r7
 1792 00c6 0AB0     		add	sp, sp, #40
 1793              		@ sp needed
 1794 00c8 80BD     		pop	{r7, pc}
 1795              		.cfi_endproc
 1796              	.LFE12:
 1798 00ca C046     		.section	.text.xQueuePeekFromISR,"ax",%progbits
 1799              		.align	2
 1800              		.global	xQueuePeekFromISR
 1801              		.code	16
 1802              		.thumb_func
 1804              	xQueuePeekFromISR:
 1805              	.LFB13:
1523:../freertos/queue.c **** /*-----------------------------------------------------------*/
1524:../freertos/queue.c **** 
1525:../freertos/queue.c **** BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
1526:../freertos/queue.c **** {
 1806              		.loc 1 1526 0
 1807              		.cfi_startproc
 1808 0000 80B5     		push	{r7, lr}
 1809              		.cfi_def_cfa_offset 8
 1810              		.cfi_offset 7, -8
 1811              		.cfi_offset 14, -4
 1812 0002 86B0     		sub	sp, sp, #24
 1813              		.cfi_def_cfa_offset 32
 1814 0004 00AF     		add	r7, sp, #0
 1815              		.cfi_def_cfa_register 7
 1816 0006 7860     		str	r0, [r7, #4]
 1817 0008 3960     		str	r1, [r7]
1527:../freertos/queue.c **** BaseType_t xReturn;
1528:../freertos/queue.c **** UBaseType_t uxSavedInterruptStatus;
1529:../freertos/queue.c **** int8_t *pcOriginalReadPosition;
1530:../freertos/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 1818              		.loc 1 1530 0
 1819 000a 7B68     		ldr	r3, [r7, #4]
 1820 000c 3B61     		str	r3, [r7, #16]
1531:../freertos/queue.c **** 
1532:../freertos/queue.c **** 	configASSERT( pxQueue );
 1821              		.loc 1 1532 0
 1822 000e 3B69     		ldr	r3, [r7, #16]
 1823 0010 002B     		cmp	r3, #0
 1824 0012 01D1     		bne	.L150
 1825              		.loc 1 1532 0 is_stmt 0 discriminator 1
 1826              	@ 1532 "../freertos/queue.c" 1
 1827 0014 72B6     		 cpsid i 
 1828              	@ 0 "" 2
 1829              		.code	16
 1830              	.L151:
 1831 0016 FEE7     		b	.L151
 1832              	.L150:
1533:../freertos/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 1833              		.loc 1 1533 0 is_stmt 1
 1834 0018 3B68     		ldr	r3, [r7]
 1835 001a 002B     		cmp	r3, #0
 1836 001c 03D1     		bne	.L152
 1837              		.loc 1 1533 0 is_stmt 0 discriminator 2
 1838 001e 3B69     		ldr	r3, [r7, #16]
 1839 0020 1B6C     		ldr	r3, [r3, #64]
 1840 0022 002B     		cmp	r3, #0
 1841 0024 01D1     		bne	.L153
 1842              	.L152:
 1843              		.loc 1 1533 0 discriminator 1
 1844 0026 0123     		mov	r3, #1
 1845 0028 00E0     		b	.L154
 1846              	.L153:
 1847              		.loc 1 1533 0 discriminator 3
 1848 002a 0023     		mov	r3, #0
 1849              	.L154:
 1850              		.loc 1 1533 0 discriminator 4
 1851 002c 002B     		cmp	r3, #0
 1852 002e 01D1     		bne	.L155
 1853              		.loc 1 1533 0 discriminator 1
 1854              	@ 1533 "../freertos/queue.c" 1
 1855 0030 72B6     		 cpsid i 
 1856              	@ 0 "" 2
 1857              		.code	16
 1858              	.L156:
 1859 0032 FEE7     		b	.L156
 1860              	.L155:
1534:../freertos/queue.c **** 	configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
 1861              		.loc 1 1534 0 is_stmt 1
 1862 0034 3B69     		ldr	r3, [r7, #16]
 1863 0036 1B6C     		ldr	r3, [r3, #64]
 1864 0038 002B     		cmp	r3, #0
 1865 003a 01D1     		bne	.L157
 1866              		.loc 1 1534 0 is_stmt 0 discriminator 1
 1867              	@ 1534 "../freertos/queue.c" 1
 1868 003c 72B6     		 cpsid i 
 1869              	@ 0 "" 2
 1870              		.code	16
 1871              	.L158:
 1872 003e FEE7     		b	.L158
 1873              	.L157:
1535:../freertos/queue.c **** 
1536:../freertos/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1537:../freertos/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1538:../freertos/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
1539:../freertos/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1540:../freertos/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1541:../freertos/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1542:../freertos/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1543:../freertos/queue.c **** 	assigned a priority above the configured maximum system call priority.
1544:../freertos/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1545:../freertos/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
1546:../freertos/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1547:../freertos/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1548:../freertos/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
1549:../freertos/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1550:../freertos/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1551:../freertos/queue.c **** 
1552:../freertos/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1874              		.loc 1 1552 0 is_stmt 1
 1875 0040 FFF7FEFF 		bl	ulSetInterruptMaskFromISR
 1876 0044 031C     		mov	r3, r0
 1877 0046 FB60     		str	r3, [r7, #12]
1553:../freertos/queue.c **** 	{
1554:../freertos/queue.c **** 		/* Cannot block in an ISR, so check there is data available. */
1555:../freertos/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 1878              		.loc 1 1555 0
 1879 0048 3B69     		ldr	r3, [r7, #16]
 1880 004a 9B6B     		ldr	r3, [r3, #56]
 1881 004c 002B     		cmp	r3, #0
 1882 004e 0ED0     		beq	.L159
1556:../freertos/queue.c **** 		{
1557:../freertos/queue.c **** 			traceQUEUE_PEEK_FROM_ISR( pxQueue );
1558:../freertos/queue.c **** 
1559:../freertos/queue.c **** 			/* Remember the read position so it can be reset as nothing is
1560:../freertos/queue.c **** 			actually being removed from the queue. */
1561:../freertos/queue.c **** 			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
 1883              		.loc 1 1561 0
 1884 0050 3B69     		ldr	r3, [r7, #16]
 1885 0052 DB68     		ldr	r3, [r3, #12]
 1886 0054 BB60     		str	r3, [r7, #8]
1562:../freertos/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
 1887              		.loc 1 1562 0
 1888 0056 3A69     		ldr	r2, [r7, #16]
 1889 0058 3B68     		ldr	r3, [r7]
 1890 005a 101C     		mov	r0, r2
 1891 005c 191C     		mov	r1, r3
 1892 005e FFF7FEFF 		bl	prvCopyDataFromQueue
1563:../freertos/queue.c **** 			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
 1893              		.loc 1 1563 0
 1894 0062 3B69     		ldr	r3, [r7, #16]
 1895 0064 BA68     		ldr	r2, [r7, #8]
 1896 0066 DA60     		str	r2, [r3, #12]
1564:../freertos/queue.c **** 
1565:../freertos/queue.c **** 			xReturn = pdPASS;
 1897              		.loc 1 1565 0
 1898 0068 0123     		mov	r3, #1
 1899 006a 7B61     		str	r3, [r7, #20]
 1900 006c 01E0     		b	.L160
 1901              	.L159:
1566:../freertos/queue.c **** 		}
1567:../freertos/queue.c **** 		else
1568:../freertos/queue.c **** 		{
1569:../freertos/queue.c **** 			xReturn = pdFAIL;
 1902              		.loc 1 1569 0
 1903 006e 0023     		mov	r3, #0
 1904 0070 7B61     		str	r3, [r7, #20]
 1905              	.L160:
1570:../freertos/queue.c **** 			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
1571:../freertos/queue.c **** 		}
1572:../freertos/queue.c **** 	}
1573:../freertos/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 1906              		.loc 1 1573 0
 1907 0072 FB68     		ldr	r3, [r7, #12]
 1908 0074 181C     		mov	r0, r3
 1909 0076 FFF7FEFF 		bl	vClearInterruptMaskFromISR
1574:../freertos/queue.c **** 
1575:../freertos/queue.c **** 	return xReturn;
 1910              		.loc 1 1575 0
 1911 007a 7B69     		ldr	r3, [r7, #20]
1576:../freertos/queue.c **** }
 1912              		.loc 1 1576 0
 1913 007c 181C     		mov	r0, r3
 1914 007e BD46     		mov	sp, r7
 1915 0080 06B0     		add	sp, sp, #24
 1916              		@ sp needed
 1917 0082 80BD     		pop	{r7, pc}
 1918              		.cfi_endproc
 1919              	.LFE13:
 1921              		.section	.text.uxQueueMessagesWaiting,"ax",%progbits
 1922              		.align	2
 1923              		.global	uxQueueMessagesWaiting
 1924              		.code	16
 1925              		.thumb_func
 1927              	uxQueueMessagesWaiting:
 1928              	.LFB14:
1577:../freertos/queue.c **** /*-----------------------------------------------------------*/
1578:../freertos/queue.c **** 
1579:../freertos/queue.c **** UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
1580:../freertos/queue.c **** {
 1929              		.loc 1 1580 0
 1930              		.cfi_startproc
 1931 0000 80B5     		push	{r7, lr}
 1932              		.cfi_def_cfa_offset 8
 1933              		.cfi_offset 7, -8
 1934              		.cfi_offset 14, -4
 1935 0002 84B0     		sub	sp, sp, #16
 1936              		.cfi_def_cfa_offset 24
 1937 0004 00AF     		add	r7, sp, #0
 1938              		.cfi_def_cfa_register 7
 1939 0006 7860     		str	r0, [r7, #4]
1581:../freertos/queue.c **** UBaseType_t uxReturn;
1582:../freertos/queue.c **** 
1583:../freertos/queue.c **** 	configASSERT( xQueue );
 1940              		.loc 1 1583 0
 1941 0008 7B68     		ldr	r3, [r7, #4]
 1942 000a 002B     		cmp	r3, #0
 1943 000c 01D1     		bne	.L163
 1944              		.loc 1 1583 0 is_stmt 0 discriminator 1
 1945              	@ 1583 "../freertos/queue.c" 1
 1946 000e 72B6     		 cpsid i 
 1947              	@ 0 "" 2
 1948              		.code	16
 1949              	.L164:
 1950 0010 FEE7     		b	.L164
 1951              	.L163:
1584:../freertos/queue.c **** 
1585:../freertos/queue.c **** 	taskENTER_CRITICAL();
 1952              		.loc 1 1585 0 is_stmt 1
 1953 0012 FFF7FEFF 		bl	vPortEnterCritical
1586:../freertos/queue.c **** 	{
1587:../freertos/queue.c **** 		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
 1954              		.loc 1 1587 0
 1955 0016 7B68     		ldr	r3, [r7, #4]
 1956 0018 9B6B     		ldr	r3, [r3, #56]
 1957 001a FB60     		str	r3, [r7, #12]
1588:../freertos/queue.c **** 	}
1589:../freertos/queue.c **** 	taskEXIT_CRITICAL();
 1958              		.loc 1 1589 0
 1959 001c FFF7FEFF 		bl	vPortExitCritical
1590:../freertos/queue.c **** 
1591:../freertos/queue.c **** 	return uxReturn;
 1960              		.loc 1 1591 0
 1961 0020 FB68     		ldr	r3, [r7, #12]
1592:../freertos/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 1962              		.loc 1 1592 0
 1963 0022 181C     		mov	r0, r3
 1964 0024 BD46     		mov	sp, r7
 1965 0026 04B0     		add	sp, sp, #16
 1966              		@ sp needed
 1967 0028 80BD     		pop	{r7, pc}
 1968              		.cfi_endproc
 1969              	.LFE14:
 1971 002a C046     		.section	.text.uxQueueSpacesAvailable,"ax",%progbits
 1972              		.align	2
 1973              		.global	uxQueueSpacesAvailable
 1974              		.code	16
 1975              		.thumb_func
 1977              	uxQueueSpacesAvailable:
 1978              	.LFB15:
1593:../freertos/queue.c **** /*-----------------------------------------------------------*/
1594:../freertos/queue.c **** 
1595:../freertos/queue.c **** UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
1596:../freertos/queue.c **** {
 1979              		.loc 1 1596 0
 1980              		.cfi_startproc
 1981 0000 80B5     		push	{r7, lr}
 1982              		.cfi_def_cfa_offset 8
 1983              		.cfi_offset 7, -8
 1984              		.cfi_offset 14, -4
 1985 0002 84B0     		sub	sp, sp, #16
 1986              		.cfi_def_cfa_offset 24
 1987 0004 00AF     		add	r7, sp, #0
 1988              		.cfi_def_cfa_register 7
 1989 0006 7860     		str	r0, [r7, #4]
1597:../freertos/queue.c **** UBaseType_t uxReturn;
1598:../freertos/queue.c **** Queue_t *pxQueue;
1599:../freertos/queue.c **** 
1600:../freertos/queue.c **** 	pxQueue = ( Queue_t * ) xQueue;
 1990              		.loc 1 1600 0
 1991 0008 7B68     		ldr	r3, [r7, #4]
 1992 000a FB60     		str	r3, [r7, #12]
1601:../freertos/queue.c **** 	configASSERT( pxQueue );
 1993              		.loc 1 1601 0
 1994 000c FB68     		ldr	r3, [r7, #12]
 1995 000e 002B     		cmp	r3, #0
 1996 0010 01D1     		bne	.L167
 1997              		.loc 1 1601 0 is_stmt 0 discriminator 1
 1998              	@ 1601 "../freertos/queue.c" 1
 1999 0012 72B6     		 cpsid i 
 2000              	@ 0 "" 2
 2001              		.code	16
 2002              	.L168:
 2003 0014 FEE7     		b	.L168
 2004              	.L167:
1602:../freertos/queue.c **** 
1603:../freertos/queue.c **** 	taskENTER_CRITICAL();
 2005              		.loc 1 1603 0 is_stmt 1
 2006 0016 FFF7FEFF 		bl	vPortEnterCritical
1604:../freertos/queue.c **** 	{
1605:../freertos/queue.c **** 		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
 2007              		.loc 1 1605 0
 2008 001a FB68     		ldr	r3, [r7, #12]
 2009 001c DA6B     		ldr	r2, [r3, #60]
 2010 001e FB68     		ldr	r3, [r7, #12]
 2011 0020 9B6B     		ldr	r3, [r3, #56]
 2012 0022 D31A     		sub	r3, r2, r3
 2013 0024 BB60     		str	r3, [r7, #8]
1606:../freertos/queue.c **** 	}
1607:../freertos/queue.c **** 	taskEXIT_CRITICAL();
 2014              		.loc 1 1607 0
 2015 0026 FFF7FEFF 		bl	vPortExitCritical
1608:../freertos/queue.c **** 
1609:../freertos/queue.c **** 	return uxReturn;
 2016              		.loc 1 1609 0
 2017 002a BB68     		ldr	r3, [r7, #8]
1610:../freertos/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 2018              		.loc 1 1610 0
 2019 002c 181C     		mov	r0, r3
 2020 002e BD46     		mov	sp, r7
 2021 0030 04B0     		add	sp, sp, #16
 2022              		@ sp needed
 2023 0032 80BD     		pop	{r7, pc}
 2024              		.cfi_endproc
 2025              	.LFE15:
 2027              		.section	.text.uxQueueMessagesWaitingFromISR,"ax",%progbits
 2028              		.align	2
 2029              		.global	uxQueueMessagesWaitingFromISR
 2030              		.code	16
 2031              		.thumb_func
 2033              	uxQueueMessagesWaitingFromISR:
 2034              	.LFB16:
1611:../freertos/queue.c **** /*-----------------------------------------------------------*/
1612:../freertos/queue.c **** 
1613:../freertos/queue.c **** UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
1614:../freertos/queue.c **** {
 2035              		.loc 1 1614 0
 2036              		.cfi_startproc
 2037 0000 80B5     		push	{r7, lr}
 2038              		.cfi_def_cfa_offset 8
 2039              		.cfi_offset 7, -8
 2040              		.cfi_offset 14, -4
 2041 0002 84B0     		sub	sp, sp, #16
 2042              		.cfi_def_cfa_offset 24
 2043 0004 00AF     		add	r7, sp, #0
 2044              		.cfi_def_cfa_register 7
 2045 0006 7860     		str	r0, [r7, #4]
1615:../freertos/queue.c **** UBaseType_t uxReturn;
1616:../freertos/queue.c **** 
1617:../freertos/queue.c **** 	configASSERT( xQueue );
 2046              		.loc 1 1617 0
 2047 0008 7B68     		ldr	r3, [r7, #4]
 2048 000a 002B     		cmp	r3, #0
 2049 000c 01D1     		bne	.L171
 2050              		.loc 1 1617 0 is_stmt 0 discriminator 1
 2051              	@ 1617 "../freertos/queue.c" 1
 2052 000e 72B6     		 cpsid i 
 2053              	@ 0 "" 2
 2054              		.code	16
 2055              	.L172:
 2056 0010 FEE7     		b	.L172
 2057              	.L171:
1618:../freertos/queue.c **** 
1619:../freertos/queue.c **** 	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
 2058              		.loc 1 1619 0 is_stmt 1
 2059 0012 7B68     		ldr	r3, [r7, #4]
 2060 0014 9B6B     		ldr	r3, [r3, #56]
 2061 0016 FB60     		str	r3, [r7, #12]
1620:../freertos/queue.c **** 
1621:../freertos/queue.c **** 	return uxReturn;
 2062              		.loc 1 1621 0
 2063 0018 FB68     		ldr	r3, [r7, #12]
1622:../freertos/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 2064              		.loc 1 1622 0
 2065 001a 181C     		mov	r0, r3
 2066 001c BD46     		mov	sp, r7
 2067 001e 04B0     		add	sp, sp, #16
 2068              		@ sp needed
 2069 0020 80BD     		pop	{r7, pc}
 2070              		.cfi_endproc
 2071              	.LFE16:
 2073 0022 C046     		.section	.text.vQueueDelete,"ax",%progbits
 2074              		.align	2
 2075              		.global	vQueueDelete
 2076              		.code	16
 2077              		.thumb_func
 2079              	vQueueDelete:
 2080              	.LFB17:
1623:../freertos/queue.c **** /*-----------------------------------------------------------*/
1624:../freertos/queue.c **** 
1625:../freertos/queue.c **** void vQueueDelete( QueueHandle_t xQueue )
1626:../freertos/queue.c **** {
 2081              		.loc 1 1626 0
 2082              		.cfi_startproc
 2083 0000 80B5     		push	{r7, lr}
 2084              		.cfi_def_cfa_offset 8
 2085              		.cfi_offset 7, -8
 2086              		.cfi_offset 14, -4
 2087 0002 84B0     		sub	sp, sp, #16
 2088              		.cfi_def_cfa_offset 24
 2089 0004 00AF     		add	r7, sp, #0
 2090              		.cfi_def_cfa_register 7
 2091 0006 7860     		str	r0, [r7, #4]
1627:../freertos/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 2092              		.loc 1 1627 0
 2093 0008 7B68     		ldr	r3, [r7, #4]
 2094 000a FB60     		str	r3, [r7, #12]
1628:../freertos/queue.c **** 
1629:../freertos/queue.c **** 	configASSERT( pxQueue );
 2095              		.loc 1 1629 0
 2096 000c FB68     		ldr	r3, [r7, #12]
 2097 000e 002B     		cmp	r3, #0
 2098 0010 01D1     		bne	.L175
 2099              		.loc 1 1629 0 is_stmt 0 discriminator 1
 2100              	@ 1629 "../freertos/queue.c" 1
 2101 0012 72B6     		 cpsid i 
 2102              	@ 0 "" 2
 2103              		.code	16
 2104              	.L176:
 2105 0014 FEE7     		b	.L176
 2106              	.L175:
1630:../freertos/queue.c **** 	traceQUEUE_DELETE( pxQueue );
1631:../freertos/queue.c **** 
1632:../freertos/queue.c **** 	#if ( configQUEUE_REGISTRY_SIZE > 0 )
1633:../freertos/queue.c **** 	{
1634:../freertos/queue.c **** 		vQueueUnregisterQueue( pxQueue );
 2107              		.loc 1 1634 0 is_stmt 1
 2108 0016 FB68     		ldr	r3, [r7, #12]
 2109 0018 181C     		mov	r0, r3
 2110 001a FFF7FEFF 		bl	vQueueUnregisterQueue
1635:../freertos/queue.c **** 	}
1636:../freertos/queue.c **** 	#endif
1637:../freertos/queue.c **** 
1638:../freertos/queue.c **** 	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
1639:../freertos/queue.c **** 	{
1640:../freertos/queue.c **** 		/* The queue can only have been allocated dynamically - free it
1641:../freertos/queue.c **** 		again. */
1642:../freertos/queue.c **** 		vPortFree( pxQueue );
 2111              		.loc 1 1642 0
 2112 001e FB68     		ldr	r3, [r7, #12]
 2113 0020 181C     		mov	r0, r3
 2114 0022 FFF7FEFF 		bl	vPortFree
1643:../freertos/queue.c **** 	}
1644:../freertos/queue.c **** 	#elif( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
1645:../freertos/queue.c **** 	{
1646:../freertos/queue.c **** 		/* The queue could have been allocated statically or dynamically, so
1647:../freertos/queue.c **** 		check before attempting to free the memory. */
1648:../freertos/queue.c **** 		if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
1649:../freertos/queue.c **** 		{
1650:../freertos/queue.c **** 			vPortFree( pxQueue );
1651:../freertos/queue.c **** 		}
1652:../freertos/queue.c **** 		else
1653:../freertos/queue.c **** 		{
1654:../freertos/queue.c **** 			mtCOVERAGE_TEST_MARKER();
1655:../freertos/queue.c **** 		}
1656:../freertos/queue.c **** 	}
1657:../freertos/queue.c **** 	#else
1658:../freertos/queue.c **** 	{
1659:../freertos/queue.c **** 		/* The queue must have been statically allocated, so is not going to be
1660:../freertos/queue.c **** 		deleted.  Avoid compiler warnings about the unused parameter. */
1661:../freertos/queue.c **** 		( void ) pxQueue;
1662:../freertos/queue.c **** 	}
1663:../freertos/queue.c **** 	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
1664:../freertos/queue.c **** }
 2115              		.loc 1 1664 0
 2116 0026 BD46     		mov	sp, r7
 2117 0028 04B0     		add	sp, sp, #16
 2118              		@ sp needed
 2119 002a 80BD     		pop	{r7, pc}
 2120              		.cfi_endproc
 2121              	.LFE17:
 2123              		.section	.text.uxQueueGetQueueNumber,"ax",%progbits
 2124              		.align	2
 2125              		.global	uxQueueGetQueueNumber
 2126              		.code	16
 2127              		.thumb_func
 2129              	uxQueueGetQueueNumber:
 2130              	.LFB18:
1665:../freertos/queue.c **** /*-----------------------------------------------------------*/
1666:../freertos/queue.c **** 
1667:../freertos/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1668:../freertos/queue.c **** 
1669:../freertos/queue.c **** 	UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue )
1670:../freertos/queue.c **** 	{
 2131              		.loc 1 1670 0
 2132              		.cfi_startproc
 2133 0000 80B5     		push	{r7, lr}
 2134              		.cfi_def_cfa_offset 8
 2135              		.cfi_offset 7, -8
 2136              		.cfi_offset 14, -4
 2137 0002 82B0     		sub	sp, sp, #8
 2138              		.cfi_def_cfa_offset 16
 2139 0004 00AF     		add	r7, sp, #0
 2140              		.cfi_def_cfa_register 7
 2141 0006 7860     		str	r0, [r7, #4]
1671:../freertos/queue.c **** 		return ( ( Queue_t * ) xQueue )->uxQueueNumber;
 2142              		.loc 1 1671 0
 2143 0008 7B68     		ldr	r3, [r7, #4]
 2144 000a 9B6C     		ldr	r3, [r3, #72]
1672:../freertos/queue.c **** 	}
 2145              		.loc 1 1672 0
 2146 000c 181C     		mov	r0, r3
 2147 000e BD46     		mov	sp, r7
 2148 0010 02B0     		add	sp, sp, #8
 2149              		@ sp needed
 2150 0012 80BD     		pop	{r7, pc}
 2151              		.cfi_endproc
 2152              	.LFE18:
 2154              		.section	.text.vQueueSetQueueNumber,"ax",%progbits
 2155              		.align	2
 2156              		.global	vQueueSetQueueNumber
 2157              		.code	16
 2158              		.thumb_func
 2160              	vQueueSetQueueNumber:
 2161              	.LFB19:
1673:../freertos/queue.c **** 
1674:../freertos/queue.c **** #endif /* configUSE_TRACE_FACILITY */
1675:../freertos/queue.c **** /*-----------------------------------------------------------*/
1676:../freertos/queue.c **** 
1677:../freertos/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1678:../freertos/queue.c **** 
1679:../freertos/queue.c **** 	void vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber )
1680:../freertos/queue.c **** 	{
 2162              		.loc 1 1680 0
 2163              		.cfi_startproc
 2164 0000 80B5     		push	{r7, lr}
 2165              		.cfi_def_cfa_offset 8
 2166              		.cfi_offset 7, -8
 2167              		.cfi_offset 14, -4
 2168 0002 82B0     		sub	sp, sp, #8
 2169              		.cfi_def_cfa_offset 16
 2170 0004 00AF     		add	r7, sp, #0
 2171              		.cfi_def_cfa_register 7
 2172 0006 7860     		str	r0, [r7, #4]
 2173 0008 3960     		str	r1, [r7]
1681:../freertos/queue.c **** 		( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
 2174              		.loc 1 1681 0
 2175 000a 7B68     		ldr	r3, [r7, #4]
 2176 000c 3A68     		ldr	r2, [r7]
 2177 000e 9A64     		str	r2, [r3, #72]
1682:../freertos/queue.c **** 	}
 2178              		.loc 1 1682 0
 2179 0010 BD46     		mov	sp, r7
 2180 0012 02B0     		add	sp, sp, #8
 2181              		@ sp needed
 2182 0014 80BD     		pop	{r7, pc}
 2183              		.cfi_endproc
 2184              	.LFE19:
 2186 0016 C046     		.section	.text.ucQueueGetQueueType,"ax",%progbits
 2187              		.align	2
 2188              		.global	ucQueueGetQueueType
 2189              		.code	16
 2190              		.thumb_func
 2192              	ucQueueGetQueueType:
 2193              	.LFB20:
1683:../freertos/queue.c **** 
1684:../freertos/queue.c **** #endif /* configUSE_TRACE_FACILITY */
1685:../freertos/queue.c **** /*-----------------------------------------------------------*/
1686:../freertos/queue.c **** 
1687:../freertos/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1688:../freertos/queue.c **** 
1689:../freertos/queue.c **** 	uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )
1690:../freertos/queue.c **** 	{
 2194              		.loc 1 1690 0
 2195              		.cfi_startproc
 2196 0000 80B5     		push	{r7, lr}
 2197              		.cfi_def_cfa_offset 8
 2198              		.cfi_offset 7, -8
 2199              		.cfi_offset 14, -4
 2200 0002 82B0     		sub	sp, sp, #8
 2201              		.cfi_def_cfa_offset 16
 2202 0004 00AF     		add	r7, sp, #0
 2203              		.cfi_def_cfa_register 7
 2204 0006 7860     		str	r0, [r7, #4]
1691:../freertos/queue.c **** 		return ( ( Queue_t * ) xQueue )->ucQueueType;
 2205              		.loc 1 1691 0
 2206 0008 7A68     		ldr	r2, [r7, #4]
 2207 000a 4C23     		mov	r3, #76
 2208 000c D35C     		ldrb	r3, [r2, r3]
1692:../freertos/queue.c **** 	}
 2209              		.loc 1 1692 0
 2210 000e 181C     		mov	r0, r3
 2211 0010 BD46     		mov	sp, r7
 2212 0012 02B0     		add	sp, sp, #8
 2213              		@ sp needed
 2214 0014 80BD     		pop	{r7, pc}
 2215              		.cfi_endproc
 2216              	.LFE20:
 2218 0016 C046     		.section	.text.prvCopyDataToQueue,"ax",%progbits
 2219              		.align	2
 2220              		.code	16
 2221              		.thumb_func
 2223              	prvCopyDataToQueue:
 2224              	.LFB21:
1693:../freertos/queue.c **** 
1694:../freertos/queue.c **** #endif /* configUSE_TRACE_FACILITY */
1695:../freertos/queue.c **** /*-----------------------------------------------------------*/
1696:../freertos/queue.c **** 
1697:../freertos/queue.c **** static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const Bas
1698:../freertos/queue.c **** {
 2225              		.loc 1 1698 0
 2226              		.cfi_startproc
 2227 0000 80B5     		push	{r7, lr}
 2228              		.cfi_def_cfa_offset 8
 2229              		.cfi_offset 7, -8
 2230              		.cfi_offset 14, -4
 2231 0002 86B0     		sub	sp, sp, #24
 2232              		.cfi_def_cfa_offset 32
 2233 0004 00AF     		add	r7, sp, #0
 2234              		.cfi_def_cfa_register 7
 2235 0006 F860     		str	r0, [r7, #12]
 2236 0008 B960     		str	r1, [r7, #8]
 2237 000a 7A60     		str	r2, [r7, #4]
1699:../freertos/queue.c **** BaseType_t xReturn = pdFALSE;
 2238              		.loc 1 1699 0
 2239 000c 0023     		mov	r3, #0
 2240 000e 7B61     		str	r3, [r7, #20]
1700:../freertos/queue.c **** UBaseType_t uxMessagesWaiting;
1701:../freertos/queue.c **** 
1702:../freertos/queue.c **** 	/* This function is called from a critical section. */
1703:../freertos/queue.c **** 
1704:../freertos/queue.c **** 	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 2241              		.loc 1 1704 0
 2242 0010 FB68     		ldr	r3, [r7, #12]
 2243 0012 9B6B     		ldr	r3, [r3, #56]
 2244 0014 3B61     		str	r3, [r7, #16]
1705:../freertos/queue.c **** 
1706:../freertos/queue.c **** 	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 2245              		.loc 1 1706 0
 2246 0016 FB68     		ldr	r3, [r7, #12]
 2247 0018 1B6C     		ldr	r3, [r3, #64]
 2248 001a 002B     		cmp	r3, #0
 2249 001c 0ED1     		bne	.L183
1707:../freertos/queue.c **** 	{
1708:../freertos/queue.c **** 		#if ( configUSE_MUTEXES == 1 )
1709:../freertos/queue.c **** 		{
1710:../freertos/queue.c **** 			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 2250              		.loc 1 1710 0
 2251 001e FB68     		ldr	r3, [r7, #12]
 2252 0020 1B68     		ldr	r3, [r3]
 2253 0022 002B     		cmp	r3, #0
 2254 0024 52D1     		bne	.L184
1711:../freertos/queue.c **** 			{
1712:../freertos/queue.c **** 				/* The mutex is no longer being held. */
1713:../freertos/queue.c **** 				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
 2255              		.loc 1 1713 0
 2256 0026 FB68     		ldr	r3, [r7, #12]
 2257 0028 5B68     		ldr	r3, [r3, #4]
 2258 002a 181C     		mov	r0, r3
 2259 002c FFF7FEFF 		bl	xTaskPriorityDisinherit
 2260 0030 031C     		mov	r3, r0
 2261 0032 7B61     		str	r3, [r7, #20]
1714:../freertos/queue.c **** 				pxQueue->pxMutexHolder = NULL;
 2262              		.loc 1 1714 0
 2263 0034 FB68     		ldr	r3, [r7, #12]
 2264 0036 0022     		mov	r2, #0
 2265 0038 5A60     		str	r2, [r3, #4]
 2266 003a 47E0     		b	.L184
 2267              	.L183:
1715:../freertos/queue.c **** 			}
1716:../freertos/queue.c **** 			else
1717:../freertos/queue.c **** 			{
1718:../freertos/queue.c **** 				mtCOVERAGE_TEST_MARKER();
1719:../freertos/queue.c **** 			}
1720:../freertos/queue.c **** 		}
1721:../freertos/queue.c **** 		#endif /* configUSE_MUTEXES */
1722:../freertos/queue.c **** 	}
1723:../freertos/queue.c **** 	else if( xPosition == queueSEND_TO_BACK )
 2268              		.loc 1 1723 0
 2269 003c 7B68     		ldr	r3, [r7, #4]
 2270 003e 002B     		cmp	r3, #0
 2271 0040 1BD1     		bne	.L185
1724:../freertos/queue.c **** 	{
1725:../freertos/queue.c **** 		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); 
 2272              		.loc 1 1725 0
 2273 0042 FB68     		ldr	r3, [r7, #12]
 2274 0044 9968     		ldr	r1, [r3, #8]
 2275 0046 FB68     		ldr	r3, [r7, #12]
 2276 0048 1B6C     		ldr	r3, [r3, #64]
 2277 004a BA68     		ldr	r2, [r7, #8]
 2278 004c 081C     		mov	r0, r1
 2279 004e 111C     		mov	r1, r2
 2280 0050 1A1C     		mov	r2, r3
 2281 0052 FFF7FEFF 		bl	memcpy
1726:../freertos/queue.c **** 		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 2282              		.loc 1 1726 0
 2283 0056 FB68     		ldr	r3, [r7, #12]
 2284 0058 9A68     		ldr	r2, [r3, #8]
 2285 005a FB68     		ldr	r3, [r7, #12]
 2286 005c 1B6C     		ldr	r3, [r3, #64]
 2287 005e D218     		add	r2, r2, r3
 2288 0060 FB68     		ldr	r3, [r7, #12]
 2289 0062 9A60     		str	r2, [r3, #8]
1727:../freertos/queue.c **** 		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison 
 2290              		.loc 1 1727 0
 2291 0064 FB68     		ldr	r3, [r7, #12]
 2292 0066 9A68     		ldr	r2, [r3, #8]
 2293 0068 FB68     		ldr	r3, [r7, #12]
 2294 006a 5B68     		ldr	r3, [r3, #4]
 2295 006c 9A42     		cmp	r2, r3
 2296 006e 2DD3     		bcc	.L184
1728:../freertos/queue.c **** 		{
1729:../freertos/queue.c **** 			pxQueue->pcWriteTo = pxQueue->pcHead;
 2297              		.loc 1 1729 0
 2298 0070 FB68     		ldr	r3, [r7, #12]
 2299 0072 1A68     		ldr	r2, [r3]
 2300 0074 FB68     		ldr	r3, [r7, #12]
 2301 0076 9A60     		str	r2, [r3, #8]
 2302 0078 28E0     		b	.L184
 2303              	.L185:
1730:../freertos/queue.c **** 		}
1731:../freertos/queue.c **** 		else
1732:../freertos/queue.c **** 		{
1733:../freertos/queue.c **** 			mtCOVERAGE_TEST_MARKER();
1734:../freertos/queue.c **** 		}
1735:../freertos/queue.c **** 	}
1736:../freertos/queue.c **** 	else
1737:../freertos/queue.c **** 	{
1738:../freertos/queue.c **** 		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize 
 2304              		.loc 1 1738 0
 2305 007a FB68     		ldr	r3, [r7, #12]
 2306 007c D968     		ldr	r1, [r3, #12]
 2307 007e FB68     		ldr	r3, [r7, #12]
 2308 0080 1B6C     		ldr	r3, [r3, #64]
 2309 0082 BA68     		ldr	r2, [r7, #8]
 2310 0084 081C     		mov	r0, r1
 2311 0086 111C     		mov	r1, r2
 2312 0088 1A1C     		mov	r2, r3
 2313 008a FFF7FEFF 		bl	memcpy
1739:../freertos/queue.c **** 		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 2314              		.loc 1 1739 0
 2315 008e FB68     		ldr	r3, [r7, #12]
 2316 0090 DA68     		ldr	r2, [r3, #12]
 2317 0092 FB68     		ldr	r3, [r7, #12]
 2318 0094 1B6C     		ldr	r3, [r3, #64]
 2319 0096 5B42     		neg	r3, r3
 2320 0098 D218     		add	r2, r2, r3
 2321 009a FB68     		ldr	r3, [r7, #12]
 2322 009c DA60     		str	r2, [r3, #12]
1740:../freertos/queue.c **** 		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as compariso
 2323              		.loc 1 1740 0
 2324 009e FB68     		ldr	r3, [r7, #12]
 2325 00a0 DA68     		ldr	r2, [r3, #12]
 2326 00a2 FB68     		ldr	r3, [r7, #12]
 2327 00a4 1B68     		ldr	r3, [r3]
 2328 00a6 9A42     		cmp	r2, r3
 2329 00a8 07D2     		bcs	.L186
1741:../freertos/queue.c **** 		{
1742:../freertos/queue.c **** 			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
 2330              		.loc 1 1742 0
 2331 00aa FB68     		ldr	r3, [r7, #12]
 2332 00ac 5A68     		ldr	r2, [r3, #4]
 2333 00ae FB68     		ldr	r3, [r7, #12]
 2334 00b0 1B6C     		ldr	r3, [r3, #64]
 2335 00b2 5B42     		neg	r3, r3
 2336 00b4 D218     		add	r2, r2, r3
 2337 00b6 FB68     		ldr	r3, [r7, #12]
 2338 00b8 DA60     		str	r2, [r3, #12]
 2339              	.L186:
1743:../freertos/queue.c **** 		}
1744:../freertos/queue.c **** 		else
1745:../freertos/queue.c **** 		{
1746:../freertos/queue.c **** 			mtCOVERAGE_TEST_MARKER();
1747:../freertos/queue.c **** 		}
1748:../freertos/queue.c **** 
1749:../freertos/queue.c **** 		if( xPosition == queueOVERWRITE )
 2340              		.loc 1 1749 0
 2341 00ba 7B68     		ldr	r3, [r7, #4]
 2342 00bc 022B     		cmp	r3, #2
 2343 00be 05D1     		bne	.L184
1750:../freertos/queue.c **** 		{
1751:../freertos/queue.c **** 			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 2344              		.loc 1 1751 0
 2345 00c0 3B69     		ldr	r3, [r7, #16]
 2346 00c2 002B     		cmp	r3, #0
 2347 00c4 02D0     		beq	.L184
1752:../freertos/queue.c **** 			{
1753:../freertos/queue.c **** 				/* An item is not being added but overwritten, so subtract
1754:../freertos/queue.c **** 				one from the recorded number of items in the queue so when
1755:../freertos/queue.c **** 				one is added again below the number of recorded items remains
1756:../freertos/queue.c **** 				correct. */
1757:../freertos/queue.c **** 				--uxMessagesWaiting;
 2348              		.loc 1 1757 0
 2349 00c6 3B69     		ldr	r3, [r7, #16]
 2350 00c8 013B     		sub	r3, r3, #1
 2351 00ca 3B61     		str	r3, [r7, #16]
 2352              	.L184:
1758:../freertos/queue.c **** 			}
1759:../freertos/queue.c **** 			else
1760:../freertos/queue.c **** 			{
1761:../freertos/queue.c **** 				mtCOVERAGE_TEST_MARKER();
1762:../freertos/queue.c **** 			}
1763:../freertos/queue.c **** 		}
1764:../freertos/queue.c **** 		else
1765:../freertos/queue.c **** 		{
1766:../freertos/queue.c **** 			mtCOVERAGE_TEST_MARKER();
1767:../freertos/queue.c **** 		}
1768:../freertos/queue.c **** 	}
1769:../freertos/queue.c **** 
1770:../freertos/queue.c **** 	pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
 2353              		.loc 1 1770 0
 2354 00cc 3B69     		ldr	r3, [r7, #16]
 2355 00ce 5A1C     		add	r2, r3, #1
 2356 00d0 FB68     		ldr	r3, [r7, #12]
 2357 00d2 9A63     		str	r2, [r3, #56]
1771:../freertos/queue.c **** 
1772:../freertos/queue.c **** 	return xReturn;
 2358              		.loc 1 1772 0
 2359 00d4 7B69     		ldr	r3, [r7, #20]
1773:../freertos/queue.c **** }
 2360              		.loc 1 1773 0
 2361 00d6 181C     		mov	r0, r3
 2362 00d8 BD46     		mov	sp, r7
 2363 00da 06B0     		add	sp, sp, #24
 2364              		@ sp needed
 2365 00dc 80BD     		pop	{r7, pc}
 2366              		.cfi_endproc
 2367              	.LFE21:
 2369              		.section	.text.prvCopyDataFromQueue,"ax",%progbits
 2370              		.align	2
 2371              		.code	16
 2372              		.thumb_func
 2374              	prvCopyDataFromQueue:
 2375              	.LFB22:
1774:../freertos/queue.c **** /*-----------------------------------------------------------*/
1775:../freertos/queue.c **** 
1776:../freertos/queue.c **** static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
1777:../freertos/queue.c **** {
 2376              		.loc 1 1777 0
 2377              		.cfi_startproc
 2378 0000 80B5     		push	{r7, lr}
 2379              		.cfi_def_cfa_offset 8
 2380              		.cfi_offset 7, -8
 2381              		.cfi_offset 14, -4
 2382 0002 82B0     		sub	sp, sp, #8
 2383              		.cfi_def_cfa_offset 16
 2384 0004 00AF     		add	r7, sp, #0
 2385              		.cfi_def_cfa_register 7
 2386 0006 7860     		str	r0, [r7, #4]
 2387 0008 3960     		str	r1, [r7]
1778:../freertos/queue.c **** 	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 2388              		.loc 1 1778 0
 2389 000a 7B68     		ldr	r3, [r7, #4]
 2390 000c 1B6C     		ldr	r3, [r3, #64]
 2391 000e 002B     		cmp	r3, #0
 2392 0010 1AD0     		beq	.L188
1779:../freertos/queue.c **** 	{
1780:../freertos/queue.c **** 		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 2393              		.loc 1 1780 0
 2394 0012 7B68     		ldr	r3, [r7, #4]
 2395 0014 DA68     		ldr	r2, [r3, #12]
 2396 0016 7B68     		ldr	r3, [r7, #4]
 2397 0018 1B6C     		ldr	r3, [r3, #64]
 2398 001a D218     		add	r2, r2, r3
 2399 001c 7B68     		ldr	r3, [r7, #4]
 2400 001e DA60     		str	r2, [r3, #12]
1781:../freertos/queue.c **** 		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of t
 2401              		.loc 1 1781 0
 2402 0020 7B68     		ldr	r3, [r7, #4]
 2403 0022 DA68     		ldr	r2, [r3, #12]
 2404 0024 7B68     		ldr	r3, [r7, #4]
 2405 0026 5B68     		ldr	r3, [r3, #4]
 2406 0028 9A42     		cmp	r2, r3
 2407 002a 03D3     		bcc	.L190
1782:../freertos/queue.c **** 		{
1783:../freertos/queue.c **** 			pxQueue->u.pcReadFrom = pxQueue->pcHead;
 2408              		.loc 1 1783 0
 2409 002c 7B68     		ldr	r3, [r7, #4]
 2410 002e 1A68     		ldr	r2, [r3]
 2411 0030 7B68     		ldr	r3, [r7, #4]
 2412 0032 DA60     		str	r2, [r3, #12]
 2413              	.L190:
1784:../freertos/queue.c **** 		}
1785:../freertos/queue.c **** 		else
1786:../freertos/queue.c **** 		{
1787:../freertos/queue.c **** 			mtCOVERAGE_TEST_MARKER();
1788:../freertos/queue.c **** 		}
1789:../freertos/queue.c **** 		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxIte
 2414              		.loc 1 1789 0
 2415 0034 7B68     		ldr	r3, [r7, #4]
 2416 0036 DA68     		ldr	r2, [r3, #12]
 2417 0038 7B68     		ldr	r3, [r7, #4]
 2418 003a 1B6C     		ldr	r3, [r3, #64]
 2419 003c 3968     		ldr	r1, [r7]
 2420 003e 081C     		mov	r0, r1
 2421 0040 111C     		mov	r1, r2
 2422 0042 1A1C     		mov	r2, r3
 2423 0044 FFF7FEFF 		bl	memcpy
 2424              	.L188:
1790:../freertos/queue.c **** 	}
1791:../freertos/queue.c **** }
 2425              		.loc 1 1791 0
 2426 0048 BD46     		mov	sp, r7
 2427 004a 02B0     		add	sp, sp, #8
 2428              		@ sp needed
 2429 004c 80BD     		pop	{r7, pc}
 2430              		.cfi_endproc
 2431              	.LFE22:
 2433 004e C046     		.section	.text.prvUnlockQueue,"ax",%progbits
 2434              		.align	2
 2435              		.code	16
 2436              		.thumb_func
 2438              	prvUnlockQueue:
 2439              	.LFB23:
1792:../freertos/queue.c **** /*-----------------------------------------------------------*/
1793:../freertos/queue.c **** 
1794:../freertos/queue.c **** static void prvUnlockQueue( Queue_t * const pxQueue )
1795:../freertos/queue.c **** {
 2440              		.loc 1 1795 0
 2441              		.cfi_startproc
 2442 0000 80B5     		push	{r7, lr}
 2443              		.cfi_def_cfa_offset 8
 2444              		.cfi_offset 7, -8
 2445              		.cfi_offset 14, -4
 2446 0002 84B0     		sub	sp, sp, #16
 2447              		.cfi_def_cfa_offset 24
 2448 0004 00AF     		add	r7, sp, #0
 2449              		.cfi_def_cfa_register 7
 2450 0006 7860     		str	r0, [r7, #4]
1796:../freertos/queue.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
1797:../freertos/queue.c **** 
1798:../freertos/queue.c **** 	/* The lock counts contains the number of extra data items placed or
1799:../freertos/queue.c **** 	removed from the queue while the queue was locked.  When a queue is
1800:../freertos/queue.c **** 	locked items can be added or removed, but the event lists cannot be
1801:../freertos/queue.c **** 	updated. */
1802:../freertos/queue.c **** 	taskENTER_CRITICAL();
 2451              		.loc 1 1802 0
 2452 0008 FFF7FEFF 		bl	vPortEnterCritical
 2453              	.LBB8:
1803:../freertos/queue.c **** 	{
1804:../freertos/queue.c **** 		int8_t cTxLock = pxQueue->cTxLock;
 2454              		.loc 1 1804 0
 2455 000c 3B1C     		mov	r3, r7
 2456 000e 0F33     		add	r3, r3, #15
 2457 0010 7968     		ldr	r1, [r7, #4]
 2458 0012 4522     		mov	r2, #69
 2459 0014 8A5C     		ldrb	r2, [r1, r2]
 2460 0016 1A70     		strb	r2, [r3]
1805:../freertos/queue.c **** 
1806:../freertos/queue.c **** 		/* See if data was added to the queue while it was locked. */
1807:../freertos/queue.c **** 		while( cTxLock > queueLOCKED_UNMODIFIED )
 2461              		.loc 1 1807 0
 2462 0018 16E0     		b	.L192
 2463              	.L196:
1808:../freertos/queue.c **** 		{
1809:../freertos/queue.c **** 			/* Data was posted while the queue was locked.  Are any tasks
1810:../freertos/queue.c **** 			blocked waiting for data to become available? */
1811:../freertos/queue.c **** 			#if ( configUSE_QUEUE_SETS == 1 )
1812:../freertos/queue.c **** 			{
1813:../freertos/queue.c **** 				if( pxQueue->pxQueueSetContainer != NULL )
1814:../freertos/queue.c **** 				{
1815:../freertos/queue.c **** 					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
1816:../freertos/queue.c **** 					{
1817:../freertos/queue.c **** 						/* The queue is a member of a queue set, and posting to
1818:../freertos/queue.c **** 						the queue set caused a higher priority task to unblock.
1819:../freertos/queue.c **** 						A context switch is required. */
1820:../freertos/queue.c **** 						vTaskMissedYield();
1821:../freertos/queue.c **** 					}
1822:../freertos/queue.c **** 					else
1823:../freertos/queue.c **** 					{
1824:../freertos/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1825:../freertos/queue.c **** 					}
1826:../freertos/queue.c **** 				}
1827:../freertos/queue.c **** 				else
1828:../freertos/queue.c **** 				{
1829:../freertos/queue.c **** 					/* Tasks that are removed from the event list will get
1830:../freertos/queue.c **** 					added to the pending ready list as the scheduler is still
1831:../freertos/queue.c **** 					suspended. */
1832:../freertos/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1833:../freertos/queue.c **** 					{
1834:../freertos/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1835:../freertos/queue.c **** 						{
1836:../freertos/queue.c **** 							/* The task waiting has a higher priority so record that a
1837:../freertos/queue.c **** 							context	switch is required. */
1838:../freertos/queue.c **** 							vTaskMissedYield();
1839:../freertos/queue.c **** 						}
1840:../freertos/queue.c **** 						else
1841:../freertos/queue.c **** 						{
1842:../freertos/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1843:../freertos/queue.c **** 						}
1844:../freertos/queue.c **** 					}
1845:../freertos/queue.c **** 					else
1846:../freertos/queue.c **** 					{
1847:../freertos/queue.c **** 						break;
1848:../freertos/queue.c **** 					}
1849:../freertos/queue.c **** 				}
1850:../freertos/queue.c **** 			}
1851:../freertos/queue.c **** 			#else /* configUSE_QUEUE_SETS */
1852:../freertos/queue.c **** 			{
1853:../freertos/queue.c **** 				/* Tasks that are removed from the event list will get added to
1854:../freertos/queue.c **** 				the pending ready list as the scheduler is still suspended. */
1855:../freertos/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 2464              		.loc 1 1855 0
 2465 001a 7B68     		ldr	r3, [r7, #4]
 2466 001c 5B6A     		ldr	r3, [r3, #36]
 2467 001e 002B     		cmp	r3, #0
 2468 0020 0AD0     		beq	.L193
1856:../freertos/queue.c **** 				{
1857:../freertos/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 2469              		.loc 1 1857 0
 2470 0022 7B68     		ldr	r3, [r7, #4]
 2471 0024 2433     		add	r3, r3, #36
 2472 0026 181C     		mov	r0, r3
 2473 0028 FFF7FEFF 		bl	xTaskRemoveFromEventList
 2474 002c 031C     		mov	r3, r0
 2475 002e 002B     		cmp	r3, #0
 2476 0030 03D0     		beq	.L194
1858:../freertos/queue.c **** 					{
1859:../freertos/queue.c **** 						/* The task waiting has a higher priority so record that
1860:../freertos/queue.c **** 						a context switch is required. */
1861:../freertos/queue.c **** 						vTaskMissedYield();
 2477              		.loc 1 1861 0
 2478 0032 FFF7FEFF 		bl	vTaskMissedYield
 2479 0036 00E0     		b	.L194
 2480              	.L193:
1862:../freertos/queue.c **** 					}
1863:../freertos/queue.c **** 					else
1864:../freertos/queue.c **** 					{
1865:../freertos/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1866:../freertos/queue.c **** 					}
1867:../freertos/queue.c **** 				}
1868:../freertos/queue.c **** 				else
1869:../freertos/queue.c **** 				{
1870:../freertos/queue.c **** 					break;
 2481              		.loc 1 1870 0
 2482 0038 0CE0     		b	.L195
 2483              	.L194:
1871:../freertos/queue.c **** 				}
1872:../freertos/queue.c **** 			}
1873:../freertos/queue.c **** 			#endif /* configUSE_QUEUE_SETS */
1874:../freertos/queue.c **** 
1875:../freertos/queue.c **** 			--cTxLock;
 2484              		.loc 1 1875 0
 2485 003a 3B1C     		mov	r3, r7
 2486 003c 0F33     		add	r3, r3, #15
 2487 003e 3A1C     		mov	r2, r7
 2488 0040 0F32     		add	r2, r2, #15
 2489 0042 1278     		ldrb	r2, [r2]
 2490 0044 013A     		sub	r2, r2, #1
 2491 0046 1A70     		strb	r2, [r3]
 2492              	.L192:
1807:../freertos/queue.c **** 		while( cTxLock > queueLOCKED_UNMODIFIED )
 2493              		.loc 1 1807 0 discriminator 1
 2494 0048 3B1C     		mov	r3, r7
 2495 004a 0F33     		add	r3, r3, #15
 2496 004c 1B78     		ldrb	r3, [r3]
 2497 004e 5BB2     		sxtb	r3, r3
 2498 0050 002B     		cmp	r3, #0
 2499 0052 E2DC     		bgt	.L196
 2500              	.L195:
1876:../freertos/queue.c **** 		}
1877:../freertos/queue.c **** 
1878:../freertos/queue.c **** 		pxQueue->cTxLock = queueUNLOCKED;
 2501              		.loc 1 1878 0
 2502 0054 7A68     		ldr	r2, [r7, #4]
 2503 0056 4523     		mov	r3, #69
 2504 0058 FF21     		mov	r1, #255
 2505 005a D154     		strb	r1, [r2, r3]
 2506              	.LBE8:
1879:../freertos/queue.c **** 	}
1880:../freertos/queue.c **** 	taskEXIT_CRITICAL();
 2507              		.loc 1 1880 0
 2508 005c FFF7FEFF 		bl	vPortExitCritical
1881:../freertos/queue.c **** 
1882:../freertos/queue.c **** 	/* Do the same for the Rx lock. */
1883:../freertos/queue.c **** 	taskENTER_CRITICAL();
 2509              		.loc 1 1883 0
 2510 0060 FFF7FEFF 		bl	vPortEnterCritical
 2511              	.LBB9:
1884:../freertos/queue.c **** 	{
1885:../freertos/queue.c **** 		int8_t cRxLock = pxQueue->cRxLock;
 2512              		.loc 1 1885 0
 2513 0064 3B1C     		mov	r3, r7
 2514 0066 0E33     		add	r3, r3, #14
 2515 0068 7968     		ldr	r1, [r7, #4]
 2516 006a 4422     		mov	r2, #68
 2517 006c 8A5C     		ldrb	r2, [r1, r2]
 2518 006e 1A70     		strb	r2, [r3]
1886:../freertos/queue.c **** 
1887:../freertos/queue.c **** 		while( cRxLock > queueLOCKED_UNMODIFIED )
 2519              		.loc 1 1887 0
 2520 0070 16E0     		b	.L197
 2521              	.L201:
1888:../freertos/queue.c **** 		{
1889:../freertos/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 2522              		.loc 1 1889 0
 2523 0072 7B68     		ldr	r3, [r7, #4]
 2524 0074 1B69     		ldr	r3, [r3, #16]
 2525 0076 002B     		cmp	r3, #0
 2526 0078 11D0     		beq	.L198
1890:../freertos/queue.c **** 			{
1891:../freertos/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 2527              		.loc 1 1891 0
 2528 007a 7B68     		ldr	r3, [r7, #4]
 2529 007c 1033     		add	r3, r3, #16
 2530 007e 181C     		mov	r0, r3
 2531 0080 FFF7FEFF 		bl	xTaskRemoveFromEventList
 2532 0084 031C     		mov	r3, r0
 2533 0086 002B     		cmp	r3, #0
 2534 0088 01D0     		beq	.L199
1892:../freertos/queue.c **** 				{
1893:../freertos/queue.c **** 					vTaskMissedYield();
 2535              		.loc 1 1893 0
 2536 008a FFF7FEFF 		bl	vTaskMissedYield
 2537              	.L199:
1894:../freertos/queue.c **** 				}
1895:../freertos/queue.c **** 				else
1896:../freertos/queue.c **** 				{
1897:../freertos/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1898:../freertos/queue.c **** 				}
1899:../freertos/queue.c **** 
1900:../freertos/queue.c **** 				--cRxLock;
 2538              		.loc 1 1900 0 discriminator 1
 2539 008e 3B1C     		mov	r3, r7
 2540 0090 0E33     		add	r3, r3, #14
 2541 0092 3A1C     		mov	r2, r7
 2542 0094 0E32     		add	r2, r2, #14
 2543 0096 1278     		ldrb	r2, [r2]
 2544 0098 013A     		sub	r2, r2, #1
 2545 009a 1A70     		strb	r2, [r3]
 2546 009c 00E0     		b	.L197
 2547              	.L198:
1901:../freertos/queue.c **** 			}
1902:../freertos/queue.c **** 			else
1903:../freertos/queue.c **** 			{
1904:../freertos/queue.c **** 				break;
 2548              		.loc 1 1904 0
 2549 009e 05E0     		b	.L200
 2550              	.L197:
1887:../freertos/queue.c **** 		while( cRxLock > queueLOCKED_UNMODIFIED )
 2551              		.loc 1 1887 0 discriminator 1
 2552 00a0 3B1C     		mov	r3, r7
 2553 00a2 0E33     		add	r3, r3, #14
 2554 00a4 1B78     		ldrb	r3, [r3]
 2555 00a6 5BB2     		sxtb	r3, r3
 2556 00a8 002B     		cmp	r3, #0
 2557 00aa E2DC     		bgt	.L201
 2558              	.L200:
1905:../freertos/queue.c **** 			}
1906:../freertos/queue.c **** 		}
1907:../freertos/queue.c **** 
1908:../freertos/queue.c **** 		pxQueue->cRxLock = queueUNLOCKED;
 2559              		.loc 1 1908 0
 2560 00ac 7A68     		ldr	r2, [r7, #4]
 2561 00ae 4423     		mov	r3, #68
 2562 00b0 FF21     		mov	r1, #255
 2563 00b2 D154     		strb	r1, [r2, r3]
 2564              	.LBE9:
1909:../freertos/queue.c **** 	}
1910:../freertos/queue.c **** 	taskEXIT_CRITICAL();
 2565              		.loc 1 1910 0
 2566 00b4 FFF7FEFF 		bl	vPortExitCritical
1911:../freertos/queue.c **** }
 2567              		.loc 1 1911 0
 2568 00b8 BD46     		mov	sp, r7
 2569 00ba 04B0     		add	sp, sp, #16
 2570              		@ sp needed
 2571 00bc 80BD     		pop	{r7, pc}
 2572              		.cfi_endproc
 2573              	.LFE23:
 2575 00be C046     		.section	.text.prvIsQueueEmpty,"ax",%progbits
 2576              		.align	2
 2577              		.code	16
 2578              		.thumb_func
 2580              	prvIsQueueEmpty:
 2581              	.LFB24:
1912:../freertos/queue.c **** /*-----------------------------------------------------------*/
1913:../freertos/queue.c **** 
1914:../freertos/queue.c **** static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
1915:../freertos/queue.c **** {
 2582              		.loc 1 1915 0
 2583              		.cfi_startproc
 2584 0000 80B5     		push	{r7, lr}
 2585              		.cfi_def_cfa_offset 8
 2586              		.cfi_offset 7, -8
 2587              		.cfi_offset 14, -4
 2588 0002 84B0     		sub	sp, sp, #16
 2589              		.cfi_def_cfa_offset 24
 2590 0004 00AF     		add	r7, sp, #0
 2591              		.cfi_def_cfa_register 7
 2592 0006 7860     		str	r0, [r7, #4]
1916:../freertos/queue.c **** BaseType_t xReturn;
1917:../freertos/queue.c **** 
1918:../freertos/queue.c **** 	taskENTER_CRITICAL();
 2593              		.loc 1 1918 0
 2594 0008 FFF7FEFF 		bl	vPortEnterCritical
1919:../freertos/queue.c **** 	{
1920:../freertos/queue.c **** 		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 2595              		.loc 1 1920 0
 2596 000c 7B68     		ldr	r3, [r7, #4]
 2597 000e 9B6B     		ldr	r3, [r3, #56]
 2598 0010 002B     		cmp	r3, #0
 2599 0012 02D1     		bne	.L203
1921:../freertos/queue.c **** 		{
1922:../freertos/queue.c **** 			xReturn = pdTRUE;
 2600              		.loc 1 1922 0
 2601 0014 0123     		mov	r3, #1
 2602 0016 FB60     		str	r3, [r7, #12]
 2603 0018 01E0     		b	.L204
 2604              	.L203:
1923:../freertos/queue.c **** 		}
1924:../freertos/queue.c **** 		else
1925:../freertos/queue.c **** 		{
1926:../freertos/queue.c **** 			xReturn = pdFALSE;
 2605              		.loc 1 1926 0
 2606 001a 0023     		mov	r3, #0
 2607 001c FB60     		str	r3, [r7, #12]
 2608              	.L204:
1927:../freertos/queue.c **** 		}
1928:../freertos/queue.c **** 	}
1929:../freertos/queue.c **** 	taskEXIT_CRITICAL();
 2609              		.loc 1 1929 0
 2610 001e FFF7FEFF 		bl	vPortExitCritical
1930:../freertos/queue.c **** 
1931:../freertos/queue.c **** 	return xReturn;
 2611              		.loc 1 1931 0
 2612 0022 FB68     		ldr	r3, [r7, #12]
1932:../freertos/queue.c **** }
 2613              		.loc 1 1932 0
 2614 0024 181C     		mov	r0, r3
 2615 0026 BD46     		mov	sp, r7
 2616 0028 04B0     		add	sp, sp, #16
 2617              		@ sp needed
 2618 002a 80BD     		pop	{r7, pc}
 2619              		.cfi_endproc
 2620              	.LFE24:
 2622              		.section	.text.xQueueIsQueueEmptyFromISR,"ax",%progbits
 2623              		.align	2
 2624              		.global	xQueueIsQueueEmptyFromISR
 2625              		.code	16
 2626              		.thumb_func
 2628              	xQueueIsQueueEmptyFromISR:
 2629              	.LFB25:
1933:../freertos/queue.c **** /*-----------------------------------------------------------*/
1934:../freertos/queue.c **** 
1935:../freertos/queue.c **** BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
1936:../freertos/queue.c **** {
 2630              		.loc 1 1936 0
 2631              		.cfi_startproc
 2632 0000 80B5     		push	{r7, lr}
 2633              		.cfi_def_cfa_offset 8
 2634              		.cfi_offset 7, -8
 2635              		.cfi_offset 14, -4
 2636 0002 84B0     		sub	sp, sp, #16
 2637              		.cfi_def_cfa_offset 24
 2638 0004 00AF     		add	r7, sp, #0
 2639              		.cfi_def_cfa_register 7
 2640 0006 7860     		str	r0, [r7, #4]
1937:../freertos/queue.c **** BaseType_t xReturn;
1938:../freertos/queue.c **** 
1939:../freertos/queue.c **** 	configASSERT( xQueue );
 2641              		.loc 1 1939 0
 2642 0008 7B68     		ldr	r3, [r7, #4]
 2643 000a 002B     		cmp	r3, #0
 2644 000c 01D1     		bne	.L207
 2645              		.loc 1 1939 0 is_stmt 0 discriminator 1
 2646              	@ 1939 "../freertos/queue.c" 1
 2647 000e 72B6     		 cpsid i 
 2648              	@ 0 "" 2
 2649              		.code	16
 2650              	.L208:
 2651 0010 FEE7     		b	.L208
 2652              	.L207:
1940:../freertos/queue.c **** 	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
 2653              		.loc 1 1940 0 is_stmt 1
 2654 0012 7B68     		ldr	r3, [r7, #4]
 2655 0014 9B6B     		ldr	r3, [r3, #56]
 2656 0016 002B     		cmp	r3, #0
 2657 0018 02D1     		bne	.L209
1941:../freertos/queue.c **** 	{
1942:../freertos/queue.c **** 		xReturn = pdTRUE;
 2658              		.loc 1 1942 0
 2659 001a 0123     		mov	r3, #1
 2660 001c FB60     		str	r3, [r7, #12]
 2661 001e 01E0     		b	.L210
 2662              	.L209:
1943:../freertos/queue.c **** 	}
1944:../freertos/queue.c **** 	else
1945:../freertos/queue.c **** 	{
1946:../freertos/queue.c **** 		xReturn = pdFALSE;
 2663              		.loc 1 1946 0
 2664 0020 0023     		mov	r3, #0
 2665 0022 FB60     		str	r3, [r7, #12]
 2666              	.L210:
1947:../freertos/queue.c **** 	}
1948:../freertos/queue.c **** 
1949:../freertos/queue.c **** 	return xReturn;
 2667              		.loc 1 1949 0
 2668 0024 FB68     		ldr	r3, [r7, #12]
1950:../freertos/queue.c **** } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 2669              		.loc 1 1950 0
 2670 0026 181C     		mov	r0, r3
 2671 0028 BD46     		mov	sp, r7
 2672 002a 04B0     		add	sp, sp, #16
 2673              		@ sp needed
 2674 002c 80BD     		pop	{r7, pc}
 2675              		.cfi_endproc
 2676              	.LFE25:
 2678 002e C046     		.section	.text.prvIsQueueFull,"ax",%progbits
 2679              		.align	2
 2680              		.code	16
 2681              		.thumb_func
 2683              	prvIsQueueFull:
 2684              	.LFB26:
1951:../freertos/queue.c **** /*-----------------------------------------------------------*/
1952:../freertos/queue.c **** 
1953:../freertos/queue.c **** static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
1954:../freertos/queue.c **** {
 2685              		.loc 1 1954 0
 2686              		.cfi_startproc
 2687 0000 80B5     		push	{r7, lr}
 2688              		.cfi_def_cfa_offset 8
 2689              		.cfi_offset 7, -8
 2690              		.cfi_offset 14, -4
 2691 0002 84B0     		sub	sp, sp, #16
 2692              		.cfi_def_cfa_offset 24
 2693 0004 00AF     		add	r7, sp, #0
 2694              		.cfi_def_cfa_register 7
 2695 0006 7860     		str	r0, [r7, #4]
1955:../freertos/queue.c **** BaseType_t xReturn;
1956:../freertos/queue.c **** 
1957:../freertos/queue.c **** 	taskENTER_CRITICAL();
 2696              		.loc 1 1957 0
 2697 0008 FFF7FEFF 		bl	vPortEnterCritical
1958:../freertos/queue.c **** 	{
1959:../freertos/queue.c **** 		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 2698              		.loc 1 1959 0
 2699 000c 7B68     		ldr	r3, [r7, #4]
 2700 000e 9A6B     		ldr	r2, [r3, #56]
 2701 0010 7B68     		ldr	r3, [r7, #4]
 2702 0012 DB6B     		ldr	r3, [r3, #60]
 2703 0014 9A42     		cmp	r2, r3
 2704 0016 02D1     		bne	.L213
1960:../freertos/queue.c **** 		{
1961:../freertos/queue.c **** 			xReturn = pdTRUE;
 2705              		.loc 1 1961 0
 2706 0018 0123     		mov	r3, #1
 2707 001a FB60     		str	r3, [r7, #12]
 2708 001c 01E0     		b	.L214
 2709              	.L213:
1962:../freertos/queue.c **** 		}
1963:../freertos/queue.c **** 		else
1964:../freertos/queue.c **** 		{
1965:../freertos/queue.c **** 			xReturn = pdFALSE;
 2710              		.loc 1 1965 0
 2711 001e 0023     		mov	r3, #0
 2712 0020 FB60     		str	r3, [r7, #12]
 2713              	.L214:
1966:../freertos/queue.c **** 		}
1967:../freertos/queue.c **** 	}
1968:../freertos/queue.c **** 	taskEXIT_CRITICAL();
 2714              		.loc 1 1968 0
 2715 0022 FFF7FEFF 		bl	vPortExitCritical
1969:../freertos/queue.c **** 
1970:../freertos/queue.c **** 	return xReturn;
 2716              		.loc 1 1970 0
 2717 0026 FB68     		ldr	r3, [r7, #12]
1971:../freertos/queue.c **** }
 2718              		.loc 1 1971 0
 2719 0028 181C     		mov	r0, r3
 2720 002a BD46     		mov	sp, r7
 2721 002c 04B0     		add	sp, sp, #16
 2722              		@ sp needed
 2723 002e 80BD     		pop	{r7, pc}
 2724              		.cfi_endproc
 2725              	.LFE26:
 2727              		.section	.text.xQueueIsQueueFullFromISR,"ax",%progbits
 2728              		.align	2
 2729              		.global	xQueueIsQueueFullFromISR
 2730              		.code	16
 2731              		.thumb_func
 2733              	xQueueIsQueueFullFromISR:
 2734              	.LFB27:
1972:../freertos/queue.c **** /*-----------------------------------------------------------*/
1973:../freertos/queue.c **** 
1974:../freertos/queue.c **** BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
1975:../freertos/queue.c **** {
 2735              		.loc 1 1975 0
 2736              		.cfi_startproc
 2737 0000 80B5     		push	{r7, lr}
 2738              		.cfi_def_cfa_offset 8
 2739              		.cfi_offset 7, -8
 2740              		.cfi_offset 14, -4
 2741 0002 84B0     		sub	sp, sp, #16
 2742              		.cfi_def_cfa_offset 24
 2743 0004 00AF     		add	r7, sp, #0
 2744              		.cfi_def_cfa_register 7
 2745 0006 7860     		str	r0, [r7, #4]
1976:../freertos/queue.c **** BaseType_t xReturn;
1977:../freertos/queue.c **** 
1978:../freertos/queue.c **** 	configASSERT( xQueue );
 2746              		.loc 1 1978 0
 2747 0008 7B68     		ldr	r3, [r7, #4]
 2748 000a 002B     		cmp	r3, #0
 2749 000c 01D1     		bne	.L217
 2750              		.loc 1 1978 0 is_stmt 0 discriminator 1
 2751              	@ 1978 "../freertos/queue.c" 1
 2752 000e 72B6     		 cpsid i 
 2753              	@ 0 "" 2
 2754              		.code	16
 2755              	.L218:
 2756 0010 FEE7     		b	.L218
 2757              	.L217:
1979:../freertos/queue.c **** 	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
 2758              		.loc 1 1979 0 is_stmt 1
 2759 0012 7B68     		ldr	r3, [r7, #4]
 2760 0014 9A6B     		ldr	r2, [r3, #56]
 2761 0016 7B68     		ldr	r3, [r7, #4]
 2762 0018 DB6B     		ldr	r3, [r3, #60]
 2763 001a 9A42     		cmp	r2, r3
 2764 001c 02D1     		bne	.L219
1980:../freertos/queue.c **** 	{
1981:../freertos/queue.c **** 		xReturn = pdTRUE;
 2765              		.loc 1 1981 0
 2766 001e 0123     		mov	r3, #1
 2767 0020 FB60     		str	r3, [r7, #12]
 2768 0022 01E0     		b	.L220
 2769              	.L219:
1982:../freertos/queue.c **** 	}
1983:../freertos/queue.c **** 	else
1984:../freertos/queue.c **** 	{
1985:../freertos/queue.c **** 		xReturn = pdFALSE;
 2770              		.loc 1 1985 0
 2771 0024 0023     		mov	r3, #0
 2772 0026 FB60     		str	r3, [r7, #12]
 2773              	.L220:
1986:../freertos/queue.c **** 	}
1987:../freertos/queue.c **** 
1988:../freertos/queue.c **** 	return xReturn;
 2774              		.loc 1 1988 0
 2775 0028 FB68     		ldr	r3, [r7, #12]
1989:../freertos/queue.c **** } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 2776              		.loc 1 1989 0
 2777 002a 181C     		mov	r0, r3
 2778 002c BD46     		mov	sp, r7
 2779 002e 04B0     		add	sp, sp, #16
 2780              		@ sp needed
 2781 0030 80BD     		pop	{r7, pc}
 2782              		.cfi_endproc
 2783              	.LFE27:
 2785 0032 C046     		.section	.text.vQueueAddToRegistry,"ax",%progbits
 2786              		.align	2
 2787              		.global	vQueueAddToRegistry
 2788              		.code	16
 2789              		.thumb_func
 2791              	vQueueAddToRegistry:
 2792              	.LFB28:
1990:../freertos/queue.c **** /*-----------------------------------------------------------*/
1991:../freertos/queue.c **** 
1992:../freertos/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
1993:../freertos/queue.c **** 
1994:../freertos/queue.c **** 	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait 
1995:../freertos/queue.c **** 	{
1996:../freertos/queue.c **** 	BaseType_t xReturn;
1997:../freertos/queue.c **** 	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
1998:../freertos/queue.c **** 
1999:../freertos/queue.c **** 		/* If the queue is already full we may have to block.  A critical section
2000:../freertos/queue.c **** 		is required to prevent an interrupt removing something from the queue
2001:../freertos/queue.c **** 		between the check to see if the queue is full and blocking on the queue. */
2002:../freertos/queue.c **** 		portDISABLE_INTERRUPTS();
2003:../freertos/queue.c **** 		{
2004:../freertos/queue.c **** 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
2005:../freertos/queue.c **** 			{
2006:../freertos/queue.c **** 				/* The queue is full - do we want to block or just leave without
2007:../freertos/queue.c **** 				posting? */
2008:../freertos/queue.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
2009:../freertos/queue.c **** 				{
2010:../freertos/queue.c **** 					/* As this is called from a coroutine we cannot block directly, but
2011:../freertos/queue.c **** 					return indicating that we need to block. */
2012:../freertos/queue.c **** 					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
2013:../freertos/queue.c **** 					portENABLE_INTERRUPTS();
2014:../freertos/queue.c **** 					return errQUEUE_BLOCKED;
2015:../freertos/queue.c **** 				}
2016:../freertos/queue.c **** 				else
2017:../freertos/queue.c **** 				{
2018:../freertos/queue.c **** 					portENABLE_INTERRUPTS();
2019:../freertos/queue.c **** 					return errQUEUE_FULL;
2020:../freertos/queue.c **** 				}
2021:../freertos/queue.c **** 			}
2022:../freertos/queue.c **** 		}
2023:../freertos/queue.c **** 		portENABLE_INTERRUPTS();
2024:../freertos/queue.c **** 
2025:../freertos/queue.c **** 		portDISABLE_INTERRUPTS();
2026:../freertos/queue.c **** 		{
2027:../freertos/queue.c **** 			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
2028:../freertos/queue.c **** 			{
2029:../freertos/queue.c **** 				/* There is room in the queue, copy the data into the queue. */
2030:../freertos/queue.c **** 				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
2031:../freertos/queue.c **** 				xReturn = pdPASS;
2032:../freertos/queue.c **** 
2033:../freertos/queue.c **** 				/* Were any co-routines waiting for data to become available? */
2034:../freertos/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2035:../freertos/queue.c **** 				{
2036:../freertos/queue.c **** 					/* In this instance the co-routine could be placed directly
2037:../freertos/queue.c **** 					into the ready list as we are within a critical section.
2038:../freertos/queue.c **** 					Instead the same pending ready list mechanism is used as if
2039:../freertos/queue.c **** 					the event were caused from within an interrupt. */
2040:../freertos/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
2041:../freertos/queue.c **** 					{
2042:../freertos/queue.c **** 						/* The co-routine waiting has a higher priority so record
2043:../freertos/queue.c **** 						that a yield might be appropriate. */
2044:../freertos/queue.c **** 						xReturn = errQUEUE_YIELD;
2045:../freertos/queue.c **** 					}
2046:../freertos/queue.c **** 					else
2047:../freertos/queue.c **** 					{
2048:../freertos/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2049:../freertos/queue.c **** 					}
2050:../freertos/queue.c **** 				}
2051:../freertos/queue.c **** 				else
2052:../freertos/queue.c **** 				{
2053:../freertos/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2054:../freertos/queue.c **** 				}
2055:../freertos/queue.c **** 			}
2056:../freertos/queue.c **** 			else
2057:../freertos/queue.c **** 			{
2058:../freertos/queue.c **** 				xReturn = errQUEUE_FULL;
2059:../freertos/queue.c **** 			}
2060:../freertos/queue.c **** 		}
2061:../freertos/queue.c **** 		portENABLE_INTERRUPTS();
2062:../freertos/queue.c **** 
2063:../freertos/queue.c **** 		return xReturn;
2064:../freertos/queue.c **** 	}
2065:../freertos/queue.c **** 
2066:../freertos/queue.c **** #endif /* configUSE_CO_ROUTINES */
2067:../freertos/queue.c **** /*-----------------------------------------------------------*/
2068:../freertos/queue.c **** 
2069:../freertos/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2070:../freertos/queue.c **** 
2071:../freertos/queue.c **** 	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
2072:../freertos/queue.c **** 	{
2073:../freertos/queue.c **** 	BaseType_t xReturn;
2074:../freertos/queue.c **** 	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
2075:../freertos/queue.c **** 
2076:../freertos/queue.c **** 		/* If the queue is already empty we may have to block.  A critical section
2077:../freertos/queue.c **** 		is required to prevent an interrupt adding something to the queue
2078:../freertos/queue.c **** 		between the check to see if the queue is empty and blocking on the queue. */
2079:../freertos/queue.c **** 		portDISABLE_INTERRUPTS();
2080:../freertos/queue.c **** 		{
2081:../freertos/queue.c **** 			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
2082:../freertos/queue.c **** 			{
2083:../freertos/queue.c **** 				/* There are no messages in the queue, do we want to block or just
2084:../freertos/queue.c **** 				leave with nothing? */
2085:../freertos/queue.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
2086:../freertos/queue.c **** 				{
2087:../freertos/queue.c **** 					/* As this is a co-routine we cannot block directly, but return
2088:../freertos/queue.c **** 					indicating that we need to block. */
2089:../freertos/queue.c **** 					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
2090:../freertos/queue.c **** 					portENABLE_INTERRUPTS();
2091:../freertos/queue.c **** 					return errQUEUE_BLOCKED;
2092:../freertos/queue.c **** 				}
2093:../freertos/queue.c **** 				else
2094:../freertos/queue.c **** 				{
2095:../freertos/queue.c **** 					portENABLE_INTERRUPTS();
2096:../freertos/queue.c **** 					return errQUEUE_FULL;
2097:../freertos/queue.c **** 				}
2098:../freertos/queue.c **** 			}
2099:../freertos/queue.c **** 			else
2100:../freertos/queue.c **** 			{
2101:../freertos/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2102:../freertos/queue.c **** 			}
2103:../freertos/queue.c **** 		}
2104:../freertos/queue.c **** 		portENABLE_INTERRUPTS();
2105:../freertos/queue.c **** 
2106:../freertos/queue.c **** 		portDISABLE_INTERRUPTS();
2107:../freertos/queue.c **** 		{
2108:../freertos/queue.c **** 			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
2109:../freertos/queue.c **** 			{
2110:../freertos/queue.c **** 				/* Data is available from the queue. */
2111:../freertos/queue.c **** 				pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
2112:../freertos/queue.c **** 				if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
2113:../freertos/queue.c **** 				{
2114:../freertos/queue.c **** 					pxQueue->u.pcReadFrom = pxQueue->pcHead;
2115:../freertos/queue.c **** 				}
2116:../freertos/queue.c **** 				else
2117:../freertos/queue.c **** 				{
2118:../freertos/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2119:../freertos/queue.c **** 				}
2120:../freertos/queue.c **** 				--( pxQueue->uxMessagesWaiting );
2121:../freertos/queue.c **** 				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->u
2122:../freertos/queue.c **** 
2123:../freertos/queue.c **** 				xReturn = pdPASS;
2124:../freertos/queue.c **** 
2125:../freertos/queue.c **** 				/* Were any co-routines waiting for space to become available? */
2126:../freertos/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
2127:../freertos/queue.c **** 				{
2128:../freertos/queue.c **** 					/* In this instance the co-routine could be placed directly
2129:../freertos/queue.c **** 					into the ready list as we are within a critical section.
2130:../freertos/queue.c **** 					Instead the same pending ready list mechanism is used as if
2131:../freertos/queue.c **** 					the event were caused from within an interrupt. */
2132:../freertos/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
2133:../freertos/queue.c **** 					{
2134:../freertos/queue.c **** 						xReturn = errQUEUE_YIELD;
2135:../freertos/queue.c **** 					}
2136:../freertos/queue.c **** 					else
2137:../freertos/queue.c **** 					{
2138:../freertos/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2139:../freertos/queue.c **** 					}
2140:../freertos/queue.c **** 				}
2141:../freertos/queue.c **** 				else
2142:../freertos/queue.c **** 				{
2143:../freertos/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2144:../freertos/queue.c **** 				}
2145:../freertos/queue.c **** 			}
2146:../freertos/queue.c **** 			else
2147:../freertos/queue.c **** 			{
2148:../freertos/queue.c **** 				xReturn = pdFAIL;
2149:../freertos/queue.c **** 			}
2150:../freertos/queue.c **** 		}
2151:../freertos/queue.c **** 		portENABLE_INTERRUPTS();
2152:../freertos/queue.c **** 
2153:../freertos/queue.c **** 		return xReturn;
2154:../freertos/queue.c **** 	}
2155:../freertos/queue.c **** 
2156:../freertos/queue.c **** #endif /* configUSE_CO_ROUTINES */
2157:../freertos/queue.c **** /*-----------------------------------------------------------*/
2158:../freertos/queue.c **** 
2159:../freertos/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2160:../freertos/queue.c **** 
2161:../freertos/queue.c **** 	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRou
2162:../freertos/queue.c **** 	{
2163:../freertos/queue.c **** 	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
2164:../freertos/queue.c **** 
2165:../freertos/queue.c **** 		/* Cannot block within an ISR so if there is no space on the queue then
2166:../freertos/queue.c **** 		exit without doing anything. */
2167:../freertos/queue.c **** 		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
2168:../freertos/queue.c **** 		{
2169:../freertos/queue.c **** 			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
2170:../freertos/queue.c **** 
2171:../freertos/queue.c **** 			/* We only want to wake one co-routine per ISR, so check that a
2172:../freertos/queue.c **** 			co-routine has not already been woken. */
2173:../freertos/queue.c **** 			if( xCoRoutinePreviouslyWoken == pdFALSE )
2174:../freertos/queue.c **** 			{
2175:../freertos/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2176:../freertos/queue.c **** 				{
2177:../freertos/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
2178:../freertos/queue.c **** 					{
2179:../freertos/queue.c **** 						return pdTRUE;
2180:../freertos/queue.c **** 					}
2181:../freertos/queue.c **** 					else
2182:../freertos/queue.c **** 					{
2183:../freertos/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2184:../freertos/queue.c **** 					}
2185:../freertos/queue.c **** 				}
2186:../freertos/queue.c **** 				else
2187:../freertos/queue.c **** 				{
2188:../freertos/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2189:../freertos/queue.c **** 				}
2190:../freertos/queue.c **** 			}
2191:../freertos/queue.c **** 			else
2192:../freertos/queue.c **** 			{
2193:../freertos/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2194:../freertos/queue.c **** 			}
2195:../freertos/queue.c **** 		}
2196:../freertos/queue.c **** 		else
2197:../freertos/queue.c **** 		{
2198:../freertos/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2199:../freertos/queue.c **** 		}
2200:../freertos/queue.c **** 
2201:../freertos/queue.c **** 		return xCoRoutinePreviouslyWoken;
2202:../freertos/queue.c **** 	}
2203:../freertos/queue.c **** 
2204:../freertos/queue.c **** #endif /* configUSE_CO_ROUTINES */
2205:../freertos/queue.c **** /*-----------------------------------------------------------*/
2206:../freertos/queue.c **** 
2207:../freertos/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2208:../freertos/queue.c **** 
2209:../freertos/queue.c **** 	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWo
2210:../freertos/queue.c **** 	{
2211:../freertos/queue.c **** 	BaseType_t xReturn;
2212:../freertos/queue.c **** 	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
2213:../freertos/queue.c **** 
2214:../freertos/queue.c **** 		/* We cannot block from an ISR, so check there is data available. If
2215:../freertos/queue.c **** 		not then just leave without doing anything. */
2216:../freertos/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
2217:../freertos/queue.c **** 		{
2218:../freertos/queue.c **** 			/* Copy the data from the queue. */
2219:../freertos/queue.c **** 			pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
2220:../freertos/queue.c **** 			if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
2221:../freertos/queue.c **** 			{
2222:../freertos/queue.c **** 				pxQueue->u.pcReadFrom = pxQueue->pcHead;
2223:../freertos/queue.c **** 			}
2224:../freertos/queue.c **** 			else
2225:../freertos/queue.c **** 			{
2226:../freertos/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2227:../freertos/queue.c **** 			}
2228:../freertos/queue.c **** 			--( pxQueue->uxMessagesWaiting );
2229:../freertos/queue.c **** 			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->ux
2230:../freertos/queue.c **** 
2231:../freertos/queue.c **** 			if( ( *pxCoRoutineWoken ) == pdFALSE )
2232:../freertos/queue.c **** 			{
2233:../freertos/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
2234:../freertos/queue.c **** 				{
2235:../freertos/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
2236:../freertos/queue.c **** 					{
2237:../freertos/queue.c **** 						*pxCoRoutineWoken = pdTRUE;
2238:../freertos/queue.c **** 					}
2239:../freertos/queue.c **** 					else
2240:../freertos/queue.c **** 					{
2241:../freertos/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2242:../freertos/queue.c **** 					}
2243:../freertos/queue.c **** 				}
2244:../freertos/queue.c **** 				else
2245:../freertos/queue.c **** 				{
2246:../freertos/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2247:../freertos/queue.c **** 				}
2248:../freertos/queue.c **** 			}
2249:../freertos/queue.c **** 			else
2250:../freertos/queue.c **** 			{
2251:../freertos/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2252:../freertos/queue.c **** 			}
2253:../freertos/queue.c **** 
2254:../freertos/queue.c **** 			xReturn = pdPASS;
2255:../freertos/queue.c **** 		}
2256:../freertos/queue.c **** 		else
2257:../freertos/queue.c **** 		{
2258:../freertos/queue.c **** 			xReturn = pdFAIL;
2259:../freertos/queue.c **** 		}
2260:../freertos/queue.c **** 
2261:../freertos/queue.c **** 		return xReturn;
2262:../freertos/queue.c **** 	}
2263:../freertos/queue.c **** 
2264:../freertos/queue.c **** #endif /* configUSE_CO_ROUTINES */
2265:../freertos/queue.c **** /*-----------------------------------------------------------*/
2266:../freertos/queue.c **** 
2267:../freertos/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
2268:../freertos/queue.c **** 
2269:../freertos/queue.c **** 	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcQueueName ) /*lint !e971 Unqualified
2270:../freertos/queue.c **** 	{
 2793              		.loc 1 2270 0
 2794              		.cfi_startproc
 2795 0000 80B5     		push	{r7, lr}
 2796              		.cfi_def_cfa_offset 8
 2797              		.cfi_offset 7, -8
 2798              		.cfi_offset 14, -4
 2799 0002 84B0     		sub	sp, sp, #16
 2800              		.cfi_def_cfa_offset 24
 2801 0004 00AF     		add	r7, sp, #0
 2802              		.cfi_def_cfa_register 7
 2803 0006 7860     		str	r0, [r7, #4]
 2804 0008 3960     		str	r1, [r7]
2271:../freertos/queue.c **** 	UBaseType_t ux;
2272:../freertos/queue.c **** 
2273:../freertos/queue.c **** 		/* See if there is an empty space in the registry.  A NULL name denotes
2274:../freertos/queue.c **** 		a free slot. */
2275:../freertos/queue.c **** 		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 2805              		.loc 1 2275 0
 2806 000a 0023     		mov	r3, #0
 2807 000c FB60     		str	r3, [r7, #12]
 2808 000e 14E0     		b	.L223
 2809              	.L226:
2276:../freertos/queue.c **** 		{
2277:../freertos/queue.c **** 			if( xQueueRegistry[ ux ].pcQueueName == NULL )
 2810              		.loc 1 2277 0
 2811 0010 0D4B     		ldr	r3, .L227
 2812 0012 FA68     		ldr	r2, [r7, #12]
 2813 0014 D200     		lsl	r2, r2, #3
 2814 0016 D358     		ldr	r3, [r2, r3]
 2815 0018 002B     		cmp	r3, #0
 2816 001a 0BD1     		bne	.L224
2278:../freertos/queue.c **** 			{
2279:../freertos/queue.c **** 				/* Store the information on this queue. */
2280:../freertos/queue.c **** 				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
 2817              		.loc 1 2280 0
 2818 001c 0A4B     		ldr	r3, .L227
 2819 001e FA68     		ldr	r2, [r7, #12]
 2820 0020 D200     		lsl	r2, r2, #3
 2821 0022 3968     		ldr	r1, [r7]
 2822 0024 D150     		str	r1, [r2, r3]
2281:../freertos/queue.c **** 				xQueueRegistry[ ux ].xHandle = xQueue;
 2823              		.loc 1 2281 0
 2824 0026 084A     		ldr	r2, .L227
 2825 0028 FB68     		ldr	r3, [r7, #12]
 2826 002a DB00     		lsl	r3, r3, #3
 2827 002c D318     		add	r3, r2, r3
 2828 002e 7A68     		ldr	r2, [r7, #4]
 2829 0030 5A60     		str	r2, [r3, #4]
2282:../freertos/queue.c **** 
2283:../freertos/queue.c **** 				traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );
2284:../freertos/queue.c **** 				break;
 2830              		.loc 1 2284 0
 2831 0032 05E0     		b	.L222
 2832              	.L224:
2275:../freertos/queue.c **** 		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 2833              		.loc 1 2275 0
 2834 0034 FB68     		ldr	r3, [r7, #12]
 2835 0036 0133     		add	r3, r3, #1
 2836 0038 FB60     		str	r3, [r7, #12]
 2837              	.L223:
2275:../freertos/queue.c **** 		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 2838              		.loc 1 2275 0 is_stmt 0 discriminator 1
 2839 003a FB68     		ldr	r3, [r7, #12]
 2840 003c 072B     		cmp	r3, #7
 2841 003e E7D9     		bls	.L226
 2842              	.L222:
2285:../freertos/queue.c **** 			}
2286:../freertos/queue.c **** 			else
2287:../freertos/queue.c **** 			{
2288:../freertos/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2289:../freertos/queue.c **** 			}
2290:../freertos/queue.c **** 		}
2291:../freertos/queue.c **** 	}
 2843              		.loc 1 2291 0 is_stmt 1
 2844 0040 BD46     		mov	sp, r7
 2845 0042 04B0     		add	sp, sp, #16
 2846              		@ sp needed
 2847 0044 80BD     		pop	{r7, pc}
 2848              	.L228:
 2849 0046 C046     		.align	2
 2850              	.L227:
 2851 0048 00000000 		.word	xQueueRegistry
 2852              		.cfi_endproc
 2853              	.LFE28:
 2855              		.section	.text.pcQueueGetName,"ax",%progbits
 2856              		.align	2
 2857              		.global	pcQueueGetName
 2858              		.code	16
 2859              		.thumb_func
 2861              	pcQueueGetName:
 2862              	.LFB29:
2292:../freertos/queue.c **** 
2293:../freertos/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
2294:../freertos/queue.c **** /*-----------------------------------------------------------*/
2295:../freertos/queue.c **** 
2296:../freertos/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
2297:../freertos/queue.c **** 
2298:../freertos/queue.c **** 	const char *pcQueueGetName( QueueHandle_t xQueue ) /*lint !e971 Unqualified char types are allowed
2299:../freertos/queue.c **** 	{
 2863              		.loc 1 2299 0
 2864              		.cfi_startproc
 2865 0000 80B5     		push	{r7, lr}
 2866              		.cfi_def_cfa_offset 8
 2867              		.cfi_offset 7, -8
 2868              		.cfi_offset 14, -4
 2869 0002 84B0     		sub	sp, sp, #16
 2870              		.cfi_def_cfa_offset 24
 2871 0004 00AF     		add	r7, sp, #0
 2872              		.cfi_def_cfa_register 7
 2873 0006 7860     		str	r0, [r7, #4]
2300:../freertos/queue.c **** 	UBaseType_t ux;
2301:../freertos/queue.c **** 	const char *pcReturn = NULL; /*lint !e971 Unqualified char types are allowed for strings and singl
 2874              		.loc 1 2301 0
 2875 0008 0023     		mov	r3, #0
 2876 000a BB60     		str	r3, [r7, #8]
2302:../freertos/queue.c **** 
2303:../freertos/queue.c **** 		/* Note there is nothing here to protect against another task adding or
2304:../freertos/queue.c **** 		removing entries from the registry while it is being searched. */
2305:../freertos/queue.c **** 		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 2877              		.loc 1 2305 0
 2878 000c 0023     		mov	r3, #0
 2879 000e FB60     		str	r3, [r7, #12]
 2880 0010 10E0     		b	.L230
 2881              	.L233:
2306:../freertos/queue.c **** 		{
2307:../freertos/queue.c **** 			if( xQueueRegistry[ ux ].xHandle == xQueue )
 2882              		.loc 1 2307 0
 2883 0012 0C4A     		ldr	r2, .L235
 2884 0014 FB68     		ldr	r3, [r7, #12]
 2885 0016 DB00     		lsl	r3, r3, #3
 2886 0018 D318     		add	r3, r2, r3
 2887 001a 5A68     		ldr	r2, [r3, #4]
 2888 001c 7B68     		ldr	r3, [r7, #4]
 2889 001e 9A42     		cmp	r2, r3
 2890 0020 05D1     		bne	.L231
2308:../freertos/queue.c **** 			{
2309:../freertos/queue.c **** 				pcReturn = xQueueRegistry[ ux ].pcQueueName;
 2891              		.loc 1 2309 0
 2892 0022 084B     		ldr	r3, .L235
 2893 0024 FA68     		ldr	r2, [r7, #12]
 2894 0026 D200     		lsl	r2, r2, #3
 2895 0028 D358     		ldr	r3, [r2, r3]
 2896 002a BB60     		str	r3, [r7, #8]
2310:../freertos/queue.c **** 				break;
 2897              		.loc 1 2310 0
 2898 002c 05E0     		b	.L232
 2899              	.L231:
2305:../freertos/queue.c **** 		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 2900              		.loc 1 2305 0
 2901 002e FB68     		ldr	r3, [r7, #12]
 2902 0030 0133     		add	r3, r3, #1
 2903 0032 FB60     		str	r3, [r7, #12]
 2904              	.L230:
2305:../freertos/queue.c **** 		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 2905              		.loc 1 2305 0 is_stmt 0 discriminator 1
 2906 0034 FB68     		ldr	r3, [r7, #12]
 2907 0036 072B     		cmp	r3, #7
 2908 0038 EBD9     		bls	.L233
 2909              	.L232:
2311:../freertos/queue.c **** 			}
2312:../freertos/queue.c **** 			else
2313:../freertos/queue.c **** 			{
2314:../freertos/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2315:../freertos/queue.c **** 			}
2316:../freertos/queue.c **** 		}
2317:../freertos/queue.c **** 
2318:../freertos/queue.c **** 		return pcReturn;
 2910              		.loc 1 2318 0 is_stmt 1
 2911 003a BB68     		ldr	r3, [r7, #8]
2319:../freertos/queue.c **** 	}
 2912              		.loc 1 2319 0
 2913 003c 181C     		mov	r0, r3
 2914 003e BD46     		mov	sp, r7
 2915 0040 04B0     		add	sp, sp, #16
 2916              		@ sp needed
 2917 0042 80BD     		pop	{r7, pc}
 2918              	.L236:
 2919              		.align	2
 2920              	.L235:
 2921 0044 00000000 		.word	xQueueRegistry
 2922              		.cfi_endproc
 2923              	.LFE29:
 2925              		.section	.text.vQueueUnregisterQueue,"ax",%progbits
 2926              		.align	2
 2927              		.global	vQueueUnregisterQueue
 2928              		.code	16
 2929              		.thumb_func
 2931              	vQueueUnregisterQueue:
 2932              	.LFB30:
2320:../freertos/queue.c **** 
2321:../freertos/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
2322:../freertos/queue.c **** /*-----------------------------------------------------------*/
2323:../freertos/queue.c **** 
2324:../freertos/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
2325:../freertos/queue.c **** 
2326:../freertos/queue.c **** 	void vQueueUnregisterQueue( QueueHandle_t xQueue )
2327:../freertos/queue.c **** 	{
 2933              		.loc 1 2327 0
 2934              		.cfi_startproc
 2935 0000 80B5     		push	{r7, lr}
 2936              		.cfi_def_cfa_offset 8
 2937              		.cfi_offset 7, -8
 2938              		.cfi_offset 14, -4
 2939 0002 84B0     		sub	sp, sp, #16
 2940              		.cfi_def_cfa_offset 24
 2941 0004 00AF     		add	r7, sp, #0
 2942              		.cfi_def_cfa_register 7
 2943 0006 7860     		str	r0, [r7, #4]
2328:../freertos/queue.c **** 	UBaseType_t ux;
2329:../freertos/queue.c **** 
2330:../freertos/queue.c **** 		/* See if the handle of the queue being unregistered in actually in the
2331:../freertos/queue.c **** 		registry. */
2332:../freertos/queue.c **** 		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 2944              		.loc 1 2332 0
 2945 0008 0023     		mov	r3, #0
 2946 000a FB60     		str	r3, [r7, #12]
 2947 000c 16E0     		b	.L238
 2948              	.L241:
2333:../freertos/queue.c **** 		{
2334:../freertos/queue.c **** 			if( xQueueRegistry[ ux ].xHandle == xQueue )
 2949              		.loc 1 2334 0
 2950 000e 0E4A     		ldr	r2, .L242
 2951 0010 FB68     		ldr	r3, [r7, #12]
 2952 0012 DB00     		lsl	r3, r3, #3
 2953 0014 D318     		add	r3, r2, r3
 2954 0016 5A68     		ldr	r2, [r3, #4]
 2955 0018 7B68     		ldr	r3, [r7, #4]
 2956 001a 9A42     		cmp	r2, r3
 2957 001c 0BD1     		bne	.L239
2335:../freertos/queue.c **** 			{
2336:../freertos/queue.c **** 				/* Set the name to NULL to show that this slot if free again. */
2337:../freertos/queue.c **** 				xQueueRegistry[ ux ].pcQueueName = NULL;
 2958              		.loc 1 2337 0
 2959 001e 0A4B     		ldr	r3, .L242
 2960 0020 FA68     		ldr	r2, [r7, #12]
 2961 0022 D200     		lsl	r2, r2, #3
 2962 0024 0021     		mov	r1, #0
 2963 0026 D150     		str	r1, [r2, r3]
2338:../freertos/queue.c **** 
2339:../freertos/queue.c **** 				/* Set the handle to NULL to ensure the same queue handle cannot
2340:../freertos/queue.c **** 				appear in the registry twice if it is added, removed, then
2341:../freertos/queue.c **** 				added again. */
2342:../freertos/queue.c **** 				xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
 2964              		.loc 1 2342 0
 2965 0028 074A     		ldr	r2, .L242
 2966 002a FB68     		ldr	r3, [r7, #12]
 2967 002c DB00     		lsl	r3, r3, #3
 2968 002e D318     		add	r3, r2, r3
 2969 0030 0022     		mov	r2, #0
 2970 0032 5A60     		str	r2, [r3, #4]
2343:../freertos/queue.c **** 				break;
 2971              		.loc 1 2343 0
 2972 0034 05E0     		b	.L237
 2973              	.L239:
2332:../freertos/queue.c **** 		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 2974              		.loc 1 2332 0
 2975 0036 FB68     		ldr	r3, [r7, #12]
 2976 0038 0133     		add	r3, r3, #1
 2977 003a FB60     		str	r3, [r7, #12]
 2978              	.L238:
2332:../freertos/queue.c **** 		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 2979              		.loc 1 2332 0 is_stmt 0 discriminator 1
 2980 003c FB68     		ldr	r3, [r7, #12]
 2981 003e 072B     		cmp	r3, #7
 2982 0040 E5D9     		bls	.L241
 2983              	.L237:
2344:../freertos/queue.c **** 			}
2345:../freertos/queue.c **** 			else
2346:../freertos/queue.c **** 			{
2347:../freertos/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2348:../freertos/queue.c **** 			}
2349:../freertos/queue.c **** 		}
2350:../freertos/queue.c **** 
2351:../freertos/queue.c **** 	} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 2984              		.loc 1 2351 0 is_stmt 1
 2985 0042 BD46     		mov	sp, r7
 2986 0044 04B0     		add	sp, sp, #16
 2987              		@ sp needed
 2988 0046 80BD     		pop	{r7, pc}
 2989              	.L243:
 2990              		.align	2
 2991              	.L242:
 2992 0048 00000000 		.word	xQueueRegistry
 2993              		.cfi_endproc
 2994              	.LFE30:
 2996              		.section	.text.vQueueWaitForMessageRestricted,"ax",%progbits
 2997              		.align	2
 2998              		.global	vQueueWaitForMessageRestricted
 2999              		.code	16
 3000              		.thumb_func
 3002              	vQueueWaitForMessageRestricted:
 3003              	.LFB31:
2352:../freertos/queue.c **** 
2353:../freertos/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
2354:../freertos/queue.c **** /*-----------------------------------------------------------*/
2355:../freertos/queue.c **** 
2356:../freertos/queue.c **** #if ( configUSE_TIMERS == 1 )
2357:../freertos/queue.c **** 
2358:../freertos/queue.c **** 	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType
2359:../freertos/queue.c **** 	{
 3004              		.loc 1 2359 0
 3005              		.cfi_startproc
 3006 0000 80B5     		push	{r7, lr}
 3007              		.cfi_def_cfa_offset 8
 3008              		.cfi_offset 7, -8
 3009              		.cfi_offset 14, -4
 3010 0002 86B0     		sub	sp, sp, #24
 3011              		.cfi_def_cfa_offset 32
 3012 0004 00AF     		add	r7, sp, #0
 3013              		.cfi_def_cfa_register 7
 3014 0006 F860     		str	r0, [r7, #12]
 3015 0008 B960     		str	r1, [r7, #8]
 3016 000a 7A60     		str	r2, [r7, #4]
2360:../freertos/queue.c **** 	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 3017              		.loc 1 2360 0
 3018 000c FB68     		ldr	r3, [r7, #12]
 3019 000e 7B61     		str	r3, [r7, #20]
2361:../freertos/queue.c **** 
2362:../freertos/queue.c **** 		/* This function should not be called by application code hence the
2363:../freertos/queue.c **** 		'Restricted' in its name.  It is not part of the public API.  It is
2364:../freertos/queue.c **** 		designed for use by kernel code, and has special calling requirements.
2365:../freertos/queue.c **** 		It can result in vListInsert() being called on a list that can only
2366:../freertos/queue.c **** 		possibly ever have one item in it, so the list will be fast, but even
2367:../freertos/queue.c **** 		so it should be called with the scheduler locked and not from a critical
2368:../freertos/queue.c **** 		section. */
2369:../freertos/queue.c **** 
2370:../freertos/queue.c **** 		/* Only do anything if there are no messages in the queue.  This function
2371:../freertos/queue.c **** 		will not actually cause the task to block, just place it on a blocked
2372:../freertos/queue.c **** 		list.  It will not block until the scheduler is unlocked - at which
2373:../freertos/queue.c **** 		time a yield will be performed.  If an item is added to the queue while
2374:../freertos/queue.c **** 		the queue is locked, and the calling task blocks on the queue, then the
2375:../freertos/queue.c **** 		calling task will be immediately unblocked when the queue is unlocked. */
2376:../freertos/queue.c **** 		prvLockQueue( pxQueue );
 3020              		.loc 1 2376 0
 3021 0010 FFF7FEFF 		bl	vPortEnterCritical
 3022 0014 7A69     		ldr	r2, [r7, #20]
 3023 0016 4423     		mov	r3, #68
 3024 0018 D35C     		ldrb	r3, [r2, r3]
 3025 001a DBB2     		uxtb	r3, r3
 3026 001c 5BB2     		sxtb	r3, r3
 3027 001e 0133     		add	r3, r3, #1
 3028 0020 03D1     		bne	.L245
 3029              		.loc 1 2376 0 is_stmt 0 discriminator 1
 3030 0022 7A69     		ldr	r2, [r7, #20]
 3031 0024 4423     		mov	r3, #68
 3032 0026 0021     		mov	r1, #0
 3033 0028 D154     		strb	r1, [r2, r3]
 3034              	.L245:
 3035              		.loc 1 2376 0 discriminator 2
 3036 002a 7A69     		ldr	r2, [r7, #20]
 3037 002c 4523     		mov	r3, #69
 3038 002e D35C     		ldrb	r3, [r2, r3]
 3039 0030 DBB2     		uxtb	r3, r3
 3040 0032 5BB2     		sxtb	r3, r3
 3041 0034 0133     		add	r3, r3, #1
 3042 0036 03D1     		bne	.L246
 3043              		.loc 1 2376 0 discriminator 1
 3044 0038 7A69     		ldr	r2, [r7, #20]
 3045 003a 4523     		mov	r3, #69
 3046 003c 0021     		mov	r1, #0
 3047 003e D154     		strb	r1, [r2, r3]
 3048              	.L246:
 3049              		.loc 1 2376 0 discriminator 2
 3050 0040 FFF7FEFF 		bl	vPortExitCritical
2377:../freertos/queue.c **** 		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
 3051              		.loc 1 2377 0 is_stmt 1 discriminator 2
 3052 0044 7B69     		ldr	r3, [r7, #20]
 3053 0046 9B6B     		ldr	r3, [r3, #56]
 3054 0048 002B     		cmp	r3, #0
 3055 004a 09D1     		bne	.L247
2378:../freertos/queue.c **** 		{
2379:../freertos/queue.c **** 			/* There is nothing in the queue, block for the specified period. */
2380:../freertos/queue.c **** 			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefi
 3056              		.loc 1 2380 0
 3057 004c 7B69     		ldr	r3, [r7, #20]
 3058 004e 191C     		mov	r1, r3
 3059 0050 2431     		add	r1, r1, #36
 3060 0052 BA68     		ldr	r2, [r7, #8]
 3061 0054 7B68     		ldr	r3, [r7, #4]
 3062 0056 081C     		mov	r0, r1
 3063 0058 111C     		mov	r1, r2
 3064 005a 1A1C     		mov	r2, r3
 3065 005c FFF7FEFF 		bl	vTaskPlaceOnEventListRestricted
 3066              	.L247:
2381:../freertos/queue.c **** 		}
2382:../freertos/queue.c **** 		else
2383:../freertos/queue.c **** 		{
2384:../freertos/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2385:../freertos/queue.c **** 		}
2386:../freertos/queue.c **** 		prvUnlockQueue( pxQueue );
 3067              		.loc 1 2386 0
 3068 0060 7B69     		ldr	r3, [r7, #20]
 3069 0062 181C     		mov	r0, r3
 3070 0064 FFF7FEFF 		bl	prvUnlockQueue
2387:../freertos/queue.c **** 	}
 3071              		.loc 1 2387 0
 3072 0068 BD46     		mov	sp, r7
 3073 006a 06B0     		add	sp, sp, #24
 3074              		@ sp needed
 3075 006c 80BD     		pop	{r7, pc}
 3076              		.cfi_endproc
 3077              	.LFE31:
 3079 006e C046     		.text
 3080              	.Letext0:
 3081              		.file 2 "c:\\freescale\\kds_v3\\toolchain\\lib\\gcc\\arm-none-eabi\\4.8.4\\include\\stddef.h"
 3082              		.file 3 "c:\\freescale\\kds_v3\\toolchain\\arm-none-eabi\\include\\machine\\_default_types.h"
 3083              		.file 4 "c:\\freescale\\kds_v3\\toolchain\\arm-none-eabi\\include\\stdint.h"
 3084              		.file 5 "../freertos/portmacro.h"
 3085              		.file 6 "../freertos/list.h"
 3086              		.file 7 "../freertos/task.h"
 3087              		.file 8 "../freertos/queue.h"
DEFINED SYMBOLS
                            *ABS*:00000000 queue.c
                            *COM*:00000040 xQueueRegistry
C:\Users\mathe\AppData\Local\Temp\ccfxpiXf.s:19     .text.xQueueGenericReset:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccfxpiXf.s:24     .text.xQueueGenericReset:00000000 xQueueGenericReset
C:\Users\mathe\AppData\Local\Temp\ccfxpiXf.s:144    .text.xQueueGenericCreate:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccfxpiXf.s:149    .text.xQueueGenericCreate:00000000 xQueueGenericCreate
C:\Users\mathe\AppData\Local\Temp\ccfxpiXf.s:234    .text.prvInitialiseNewQueue:00000000 prvInitialiseNewQueue
C:\Users\mathe\AppData\Local\Temp\ccfxpiXf.s:230    .text.prvInitialiseNewQueue:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccfxpiXf.s:295    .text.prvInitialiseMutex:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccfxpiXf.s:299    .text.prvInitialiseMutex:00000000 prvInitialiseMutex
C:\Users\mathe\AppData\Local\Temp\ccfxpiXf.s:642    .text.xQueueGenericSend:00000000 xQueueGenericSend
C:\Users\mathe\AppData\Local\Temp\ccfxpiXf.s:345    .text.xQueueCreateMutex:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccfxpiXf.s:350    .text.xQueueCreateMutex:00000000 xQueueCreateMutex
C:\Users\mathe\AppData\Local\Temp\ccfxpiXf.s:397    .text.xQueueGiveMutexRecursive:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccfxpiXf.s:402    .text.xQueueGiveMutexRecursive:00000000 xQueueGiveMutexRecursive
C:\Users\mathe\AppData\Local\Temp\ccfxpiXf.s:478    .text.xQueueTakeMutexRecursive:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccfxpiXf.s:483    .text.xQueueTakeMutexRecursive:00000000 xQueueTakeMutexRecursive
C:\Users\mathe\AppData\Local\Temp\ccfxpiXf.s:1311   .text.xQueueGenericReceive:00000000 xQueueGenericReceive
C:\Users\mathe\AppData\Local\Temp\ccfxpiXf.s:564    .text.xQueueCreateCountingSemaphore:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccfxpiXf.s:569    .text.xQueueCreateCountingSemaphore:00000000 xQueueCreateCountingSemaphore
C:\Users\mathe\AppData\Local\Temp\ccfxpiXf.s:637    .text.xQueueGenericSend:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccfxpiXf.s:2223   .text.prvCopyDataToQueue:00000000 prvCopyDataToQueue
C:\Users\mathe\AppData\Local\Temp\ccfxpiXf.s:2683   .text.prvIsQueueFull:00000000 prvIsQueueFull
C:\Users\mathe\AppData\Local\Temp\ccfxpiXf.s:2438   .text.prvUnlockQueue:00000000 prvUnlockQueue
C:\Users\mathe\AppData\Local\Temp\ccfxpiXf.s:942    .text.xQueueGenericSendFromISR:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccfxpiXf.s:947    .text.xQueueGenericSendFromISR:00000000 xQueueGenericSendFromISR
C:\Users\mathe\AppData\Local\Temp\ccfxpiXf.s:1134   .text.xQueueGiveFromISR:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccfxpiXf.s:1139   .text.xQueueGiveFromISR:00000000 xQueueGiveFromISR
C:\Users\mathe\AppData\Local\Temp\ccfxpiXf.s:1306   .text.xQueueGenericReceive:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccfxpiXf.s:2374   .text.prvCopyDataFromQueue:00000000 prvCopyDataFromQueue
C:\Users\mathe\AppData\Local\Temp\ccfxpiXf.s:2580   .text.prvIsQueueEmpty:00000000 prvIsQueueEmpty
C:\Users\mathe\AppData\Local\Temp\ccfxpiXf.s:1636   .text.xQueueReceiveFromISR:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccfxpiXf.s:1641   .text.xQueueReceiveFromISR:00000000 xQueueReceiveFromISR
C:\Users\mathe\AppData\Local\Temp\ccfxpiXf.s:1799   .text.xQueuePeekFromISR:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccfxpiXf.s:1804   .text.xQueuePeekFromISR:00000000 xQueuePeekFromISR
C:\Users\mathe\AppData\Local\Temp\ccfxpiXf.s:1922   .text.uxQueueMessagesWaiting:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccfxpiXf.s:1927   .text.uxQueueMessagesWaiting:00000000 uxQueueMessagesWaiting
C:\Users\mathe\AppData\Local\Temp\ccfxpiXf.s:1972   .text.uxQueueSpacesAvailable:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccfxpiXf.s:1977   .text.uxQueueSpacesAvailable:00000000 uxQueueSpacesAvailable
C:\Users\mathe\AppData\Local\Temp\ccfxpiXf.s:2028   .text.uxQueueMessagesWaitingFromISR:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccfxpiXf.s:2033   .text.uxQueueMessagesWaitingFromISR:00000000 uxQueueMessagesWaitingFromISR
C:\Users\mathe\AppData\Local\Temp\ccfxpiXf.s:2074   .text.vQueueDelete:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccfxpiXf.s:2079   .text.vQueueDelete:00000000 vQueueDelete
C:\Users\mathe\AppData\Local\Temp\ccfxpiXf.s:2931   .text.vQueueUnregisterQueue:00000000 vQueueUnregisterQueue
C:\Users\mathe\AppData\Local\Temp\ccfxpiXf.s:2124   .text.uxQueueGetQueueNumber:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccfxpiXf.s:2129   .text.uxQueueGetQueueNumber:00000000 uxQueueGetQueueNumber
C:\Users\mathe\AppData\Local\Temp\ccfxpiXf.s:2155   .text.vQueueSetQueueNumber:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccfxpiXf.s:2160   .text.vQueueSetQueueNumber:00000000 vQueueSetQueueNumber
C:\Users\mathe\AppData\Local\Temp\ccfxpiXf.s:2187   .text.ucQueueGetQueueType:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccfxpiXf.s:2192   .text.ucQueueGetQueueType:00000000 ucQueueGetQueueType
C:\Users\mathe\AppData\Local\Temp\ccfxpiXf.s:2219   .text.prvCopyDataToQueue:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccfxpiXf.s:2370   .text.prvCopyDataFromQueue:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccfxpiXf.s:2434   .text.prvUnlockQueue:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccfxpiXf.s:2576   .text.prvIsQueueEmpty:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccfxpiXf.s:2623   .text.xQueueIsQueueEmptyFromISR:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccfxpiXf.s:2628   .text.xQueueIsQueueEmptyFromISR:00000000 xQueueIsQueueEmptyFromISR
C:\Users\mathe\AppData\Local\Temp\ccfxpiXf.s:2679   .text.prvIsQueueFull:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccfxpiXf.s:2728   .text.xQueueIsQueueFullFromISR:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccfxpiXf.s:2733   .text.xQueueIsQueueFullFromISR:00000000 xQueueIsQueueFullFromISR
C:\Users\mathe\AppData\Local\Temp\ccfxpiXf.s:2786   .text.vQueueAddToRegistry:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccfxpiXf.s:2791   .text.vQueueAddToRegistry:00000000 vQueueAddToRegistry
C:\Users\mathe\AppData\Local\Temp\ccfxpiXf.s:2851   .text.vQueueAddToRegistry:00000048 $d
C:\Users\mathe\AppData\Local\Temp\ccfxpiXf.s:2856   .text.pcQueueGetName:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccfxpiXf.s:2861   .text.pcQueueGetName:00000000 pcQueueGetName
C:\Users\mathe\AppData\Local\Temp\ccfxpiXf.s:2921   .text.pcQueueGetName:00000044 $d
C:\Users\mathe\AppData\Local\Temp\ccfxpiXf.s:2926   .text.vQueueUnregisterQueue:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccfxpiXf.s:2992   .text.vQueueUnregisterQueue:00000048 $d
C:\Users\mathe\AppData\Local\Temp\ccfxpiXf.s:2997   .text.vQueueWaitForMessageRestricted:00000000 $t
C:\Users\mathe\AppData\Local\Temp\ccfxpiXf.s:3002   .text.vQueueWaitForMessageRestricted:00000000 vQueueWaitForMessageRestricted
                     .debug_frame:00000010 $d
                           .group:00000000 wm4.0.e19fef13b9966be9a9a0df56dde4c190
                           .group:00000000 wm4.newlib.h.8.fec018e441fee7bfa1923812ad010f97
                           .group:00000000 wm4.features.h.22.6a4ca7cd053637cc1d0db6c16f39b2d7
                           .group:00000000 wm4.config.h.212.4163ef2871a828c674038d036b081cfd
                           .group:00000000 wm4._ansi.h.23.2147fde150631f5584b9dc29b914d1b8
                           .group:00000000 wm4.stdlib.h.13.4ed386f5c1a80d71e72172885d946ef2
                           .group:00000000 wm4.stddef.h.184.aa65fb7281d578229bbad41b91862635
                           .group:00000000 wm4.stddef.h.39.d0197034aa5fd947cae140b9289e6734
                           .group:00000000 wm4._default_types.h.6.9e4229723f5523536bc8f574589d6a99
                           .group:00000000 wm4.lock.h.2.9bc98482741e5e2a9450b12934a684ea
                           .group:00000000 wm4._types.h.54.d3d34a3b7f3cc230cd159baf022b4b08
                           .group:00000000 wm4.stddef.h.158.61317cdbfb4026324507d123a50b0fd6
                           .group:00000000 wm4.reent.h.17.8bd9e4098e0428508c282cad794fae43
                           .group:00000000 wm4.stdlib.h.53.a73f7e963d962393b7f9086194931e4a
                           .group:00000000 wm4.cdefs.h.56.a2d04de9d47039852021e66fca39bb58
                           .group:00000000 wm4.string.h.15.dab3980bf35408a4c507182805e2de3a
                           .group:00000000 wm4.stddef.h.158.a7efb00f6cbc6f43213b50e183c9830c
                           .group:00000000 wm4.stdint.h.10.d0f8e374834fcfc2e296d5d5fe82f02a
                           .group:00000000 wm4.FreeRTOSConfig.h.71.9ce5dd93bb084cb2714008d9030c087d
                           .group:00000000 wm4.projdefs.h.71.6ed2b4e07820ea275c61d78138cfae10
                           .group:00000000 wm4.portmacro.h.72.32efb3512b0394b29d8211ba7ab279d9
                           .group:00000000 wm4.portable.h.106.61ffdda1afafb5a5e1f7197ade95b43a
                           .group:00000000 wm4.mpu_wrappers.h.71.c0872672d360e197b5a999335351843d
                           .group:00000000 wm4.FreeRTOS.h.186.2e14eee2d995e9702d028b4adcebc296
                           .group:00000000 wm4.list.h.103.6a12b7b9a7a136c3cca0ee53675c5498
                           .group:00000000 wm4.task.h.88.c21feabc7be8ca1396f9c7c7a7eaee9b
                           .group:00000000 wm4.queue.h.72.09c862d5018c52fa79f0d83a3dbbfe84

UNDEFINED SYMBOLS
vPortEnterCritical
xTaskRemoveFromEventList
vPortYield
vListInitialise
vPortExitCritical
pvPortMalloc
xTaskGetCurrentTaskHandle
xTaskGetSchedulerState
vTaskSetTimeOutState
vTaskSuspendAll
xTaskCheckForTimeOut
vTaskPlaceOnEventList
xTaskResumeAll
ulSetInterruptMaskFromISR
vClearInterruptMaskFromISR
pvTaskIncrementMutexHeldCount
vTaskPriorityInherit
vPortFree
xTaskPriorityDisinherit
memcpy
vTaskMissedYield
vTaskPlaceOnEventListRestricted
