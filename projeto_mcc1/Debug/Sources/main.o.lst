   1              		.cpu cortex-m0plus
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"main.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.NVIC_EnableIRQ,"ax",%progbits
  18              		.align	2
  19              		.code	16
  20              		.thumb_func
  22              	NVIC_EnableIRQ:
  23              	.LFB25:
  24              		.file 1 "../Includes/core_cm0plus.h"
   1:../Includes/core_cm0plus.h **** /**************************************************************************//**
   2:../Includes/core_cm0plus.h ****  * @file     core_cm0plus.h
   3:../Includes/core_cm0plus.h ****  * @brief    CMSIS Cortex-M0+ Core Peripheral Access Layer Header File
   4:../Includes/core_cm0plus.h ****  * @version  V4.10
   5:../Includes/core_cm0plus.h ****  * @date     18. March 2015
   6:../Includes/core_cm0plus.h ****  *
   7:../Includes/core_cm0plus.h ****  * @note
   8:../Includes/core_cm0plus.h ****  *
   9:../Includes/core_cm0plus.h ****  ******************************************************************************/
  10:../Includes/core_cm0plus.h **** /* Copyright (c) 2009 - 2015 ARM LIMITED
  11:../Includes/core_cm0plus.h **** 
  12:../Includes/core_cm0plus.h ****    All rights reserved.
  13:../Includes/core_cm0plus.h ****    Redistribution and use in source and binary forms, with or without
  14:../Includes/core_cm0plus.h ****    modification, are permitted provided that the following conditions are met:
  15:../Includes/core_cm0plus.h ****    - Redistributions of source code must retain the above copyright
  16:../Includes/core_cm0plus.h ****      notice, this list of conditions and the following disclaimer.
  17:../Includes/core_cm0plus.h ****    - Redistributions in binary form must reproduce the above copyright
  18:../Includes/core_cm0plus.h ****      notice, this list of conditions and the following disclaimer in the
  19:../Includes/core_cm0plus.h ****      documentation and/or other materials provided with the distribution.
  20:../Includes/core_cm0plus.h ****    - Neither the name of ARM nor the names of its contributors may be used
  21:../Includes/core_cm0plus.h ****      to endorse or promote products derived from this software without
  22:../Includes/core_cm0plus.h ****      specific prior written permission.
  23:../Includes/core_cm0plus.h ****    *
  24:../Includes/core_cm0plus.h ****    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  25:../Includes/core_cm0plus.h ****    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  26:../Includes/core_cm0plus.h ****    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  27:../Includes/core_cm0plus.h ****    ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
  28:../Includes/core_cm0plus.h ****    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  29:../Includes/core_cm0plus.h ****    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  30:../Includes/core_cm0plus.h ****    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  31:../Includes/core_cm0plus.h ****    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  32:../Includes/core_cm0plus.h ****    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  33:../Includes/core_cm0plus.h ****    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  34:../Includes/core_cm0plus.h ****    POSSIBILITY OF SUCH DAMAGE.
  35:../Includes/core_cm0plus.h ****    ---------------------------------------------------------------------------*/
  36:../Includes/core_cm0plus.h **** 
  37:../Includes/core_cm0plus.h **** 
  38:../Includes/core_cm0plus.h **** #if defined ( __ICCARM__ )
  39:../Includes/core_cm0plus.h ****  #pragma system_include  /* treat file as system include file for MISRA check */
  40:../Includes/core_cm0plus.h **** #endif
  41:../Includes/core_cm0plus.h **** 
  42:../Includes/core_cm0plus.h **** #ifndef __CORE_CM0PLUS_H_GENERIC
  43:../Includes/core_cm0plus.h **** #define __CORE_CM0PLUS_H_GENERIC
  44:../Includes/core_cm0plus.h **** 
  45:../Includes/core_cm0plus.h **** #ifdef __cplusplus
  46:../Includes/core_cm0plus.h ****  extern "C" {
  47:../Includes/core_cm0plus.h **** #endif
  48:../Includes/core_cm0plus.h **** 
  49:../Includes/core_cm0plus.h **** /** \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
  50:../Includes/core_cm0plus.h ****   CMSIS violates the following MISRA-C:2004 rules:
  51:../Includes/core_cm0plus.h **** 
  52:../Includes/core_cm0plus.h ****    \li Required Rule 8.5, object/function definition in header file.<br>
  53:../Includes/core_cm0plus.h ****      Function definitions in header files are used to allow 'inlining'.
  54:../Includes/core_cm0plus.h **** 
  55:../Includes/core_cm0plus.h ****    \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
  56:../Includes/core_cm0plus.h ****      Unions are used for effective representation of core registers.
  57:../Includes/core_cm0plus.h **** 
  58:../Includes/core_cm0plus.h ****    \li Advisory Rule 19.7, Function-like macro defined.<br>
  59:../Includes/core_cm0plus.h ****      Function-like macros are used to allow more efficient code.
  60:../Includes/core_cm0plus.h ****  */
  61:../Includes/core_cm0plus.h **** 
  62:../Includes/core_cm0plus.h **** 
  63:../Includes/core_cm0plus.h **** /*******************************************************************************
  64:../Includes/core_cm0plus.h ****  *                 CMSIS definitions
  65:../Includes/core_cm0plus.h ****  ******************************************************************************/
  66:../Includes/core_cm0plus.h **** /** \ingroup Cortex-M0+
  67:../Includes/core_cm0plus.h ****   @{
  68:../Includes/core_cm0plus.h ****  */
  69:../Includes/core_cm0plus.h **** 
  70:../Includes/core_cm0plus.h **** /*  CMSIS CM0P definitions */
  71:../Includes/core_cm0plus.h **** #define __CM0PLUS_CMSIS_VERSION_MAIN (0x04)                                /*!< [31:16] CMSIS HAL m
  72:../Includes/core_cm0plus.h **** #define __CM0PLUS_CMSIS_VERSION_SUB  (0x00)                                /*!< [15:0]  CMSIS HAL s
  73:../Includes/core_cm0plus.h **** #define __CM0PLUS_CMSIS_VERSION      ((__CM0PLUS_CMSIS_VERSION_MAIN << 16) | \
  74:../Includes/core_cm0plus.h ****                                        __CM0PLUS_CMSIS_VERSION_SUB)        /*!< CMSIS HAL version n
  75:../Includes/core_cm0plus.h **** 
  76:../Includes/core_cm0plus.h **** #define __CORTEX_M                (0x00)                                   /*!< Cortex-M Core      
  77:../Includes/core_cm0plus.h **** 
  78:../Includes/core_cm0plus.h **** 
  79:../Includes/core_cm0plus.h **** #if   defined ( __CC_ARM )
  80:../Includes/core_cm0plus.h ****   #define __ASM            __asm                                      /*!< asm keyword for ARM Comp
  81:../Includes/core_cm0plus.h ****   #define __INLINE         __inline                                   /*!< inline keyword for ARM C
  82:../Includes/core_cm0plus.h ****   #define __STATIC_INLINE  static __inline
  83:../Includes/core_cm0plus.h **** 
  84:../Includes/core_cm0plus.h **** #elif defined ( __GNUC__ )
  85:../Includes/core_cm0plus.h ****   #define __ASM            __asm                                      /*!< asm keyword for GNU Comp
  86:../Includes/core_cm0plus.h ****   #define __INLINE         inline                                     /*!< inline keyword for GNU C
  87:../Includes/core_cm0plus.h ****   #define __STATIC_INLINE  static inline
  88:../Includes/core_cm0plus.h **** 
  89:../Includes/core_cm0plus.h **** #elif defined ( __ICCARM__ )
  90:../Includes/core_cm0plus.h ****   #define __ASM            __asm                                      /*!< asm keyword for IAR Comp
  91:../Includes/core_cm0plus.h ****   #define __INLINE         inline                                     /*!< inline keyword for IAR C
  92:../Includes/core_cm0plus.h ****   #define __STATIC_INLINE  static inline
  93:../Includes/core_cm0plus.h **** 
  94:../Includes/core_cm0plus.h **** #elif defined ( __TMS470__ )
  95:../Includes/core_cm0plus.h ****   #define __ASM            __asm                                      /*!< asm keyword for TI CCS C
  96:../Includes/core_cm0plus.h ****   #define __STATIC_INLINE  static inline
  97:../Includes/core_cm0plus.h **** 
  98:../Includes/core_cm0plus.h **** #elif defined ( __TASKING__ )
  99:../Includes/core_cm0plus.h ****   #define __ASM            __asm                                      /*!< asm keyword for TASKING 
 100:../Includes/core_cm0plus.h ****   #define __INLINE         inline                                     /*!< inline keyword for TASKI
 101:../Includes/core_cm0plus.h ****   #define __STATIC_INLINE  static inline
 102:../Includes/core_cm0plus.h **** 
 103:../Includes/core_cm0plus.h **** #elif defined ( __CSMC__ )
 104:../Includes/core_cm0plus.h ****   #define __packed
 105:../Includes/core_cm0plus.h ****   #define __ASM            _asm                                      /*!< asm keyword for COSMIC Co
 106:../Includes/core_cm0plus.h ****   #define __INLINE         inline                                    /*use -pc99 on compile line !<
 107:../Includes/core_cm0plus.h ****   #define __STATIC_INLINE  static inline
 108:../Includes/core_cm0plus.h **** 
 109:../Includes/core_cm0plus.h **** #endif
 110:../Includes/core_cm0plus.h **** 
 111:../Includes/core_cm0plus.h **** /** __FPU_USED indicates whether an FPU is used or not.
 112:../Includes/core_cm0plus.h ****     This core does not support an FPU at all
 113:../Includes/core_cm0plus.h **** */
 114:../Includes/core_cm0plus.h **** #define __FPU_USED       0
 115:../Includes/core_cm0plus.h **** 
 116:../Includes/core_cm0plus.h **** #if defined ( __CC_ARM )
 117:../Includes/core_cm0plus.h ****   #if defined __TARGET_FPU_VFP
 118:../Includes/core_cm0plus.h ****     #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)
 119:../Includes/core_cm0plus.h ****   #endif
 120:../Includes/core_cm0plus.h **** 
 121:../Includes/core_cm0plus.h **** #elif defined ( __GNUC__ )
 122:../Includes/core_cm0plus.h ****   #if defined (__VFP_FP__) && !defined(__SOFTFP__)
 123:../Includes/core_cm0plus.h ****     #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)
 124:../Includes/core_cm0plus.h ****   #endif
 125:../Includes/core_cm0plus.h **** 
 126:../Includes/core_cm0plus.h **** #elif defined ( __ICCARM__ )
 127:../Includes/core_cm0plus.h ****   #if defined __ARMVFP__
 128:../Includes/core_cm0plus.h ****     #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)
 129:../Includes/core_cm0plus.h ****   #endif
 130:../Includes/core_cm0plus.h **** 
 131:../Includes/core_cm0plus.h **** #elif defined ( __TMS470__ )
 132:../Includes/core_cm0plus.h ****   #if defined __TI__VFP_SUPPORT____
 133:../Includes/core_cm0plus.h ****     #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)
 134:../Includes/core_cm0plus.h ****   #endif
 135:../Includes/core_cm0plus.h **** 
 136:../Includes/core_cm0plus.h **** #elif defined ( __TASKING__ )
 137:../Includes/core_cm0plus.h ****   #if defined __FPU_VFP__
 138:../Includes/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 139:../Includes/core_cm0plus.h ****   #endif
 140:../Includes/core_cm0plus.h **** 
 141:../Includes/core_cm0plus.h **** #elif defined ( __CSMC__ )		/* Cosmic */
 142:../Includes/core_cm0plus.h ****   #if ( __CSMC__ & 0x400)		// FPU present for parser
 143:../Includes/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 144:../Includes/core_cm0plus.h ****   #endif
 145:../Includes/core_cm0plus.h **** #endif
 146:../Includes/core_cm0plus.h **** 
 147:../Includes/core_cm0plus.h **** #include <stdint.h>                      /* standard types definitions                      */
 148:../Includes/core_cm0plus.h **** #include <core_cmInstr.h>                /* Core Instruction Access                         */
 149:../Includes/core_cm0plus.h **** #include <core_cmFunc.h>                 /* Core Function Access                            */
 150:../Includes/core_cm0plus.h **** 
 151:../Includes/core_cm0plus.h **** #ifdef __cplusplus
 152:../Includes/core_cm0plus.h **** }
 153:../Includes/core_cm0plus.h **** #endif
 154:../Includes/core_cm0plus.h **** 
 155:../Includes/core_cm0plus.h **** #endif /* __CORE_CM0PLUS_H_GENERIC */
 156:../Includes/core_cm0plus.h **** 
 157:../Includes/core_cm0plus.h **** #ifndef __CMSIS_GENERIC
 158:../Includes/core_cm0plus.h **** 
 159:../Includes/core_cm0plus.h **** #ifndef __CORE_CM0PLUS_H_DEPENDANT
 160:../Includes/core_cm0plus.h **** #define __CORE_CM0PLUS_H_DEPENDANT
 161:../Includes/core_cm0plus.h **** 
 162:../Includes/core_cm0plus.h **** #ifdef __cplusplus
 163:../Includes/core_cm0plus.h ****  extern "C" {
 164:../Includes/core_cm0plus.h **** #endif
 165:../Includes/core_cm0plus.h **** 
 166:../Includes/core_cm0plus.h **** /* check device defines and use defaults */
 167:../Includes/core_cm0plus.h **** #if defined __CHECK_DEVICE_DEFINES
 168:../Includes/core_cm0plus.h ****   #ifndef __CM0PLUS_REV
 169:../Includes/core_cm0plus.h ****     #define __CM0PLUS_REV             0x0000
 170:../Includes/core_cm0plus.h ****     #warning "__CM0PLUS_REV not defined in device header file; using default!"
 171:../Includes/core_cm0plus.h ****   #endif
 172:../Includes/core_cm0plus.h **** 
 173:../Includes/core_cm0plus.h ****   #ifndef __MPU_PRESENT
 174:../Includes/core_cm0plus.h ****     #define __MPU_PRESENT             0
 175:../Includes/core_cm0plus.h ****     #warning "__MPU_PRESENT not defined in device header file; using default!"
 176:../Includes/core_cm0plus.h ****   #endif
 177:../Includes/core_cm0plus.h **** 
 178:../Includes/core_cm0plus.h ****   #ifndef __VTOR_PRESENT
 179:../Includes/core_cm0plus.h ****     #define __VTOR_PRESENT            0
 180:../Includes/core_cm0plus.h ****     #warning "__VTOR_PRESENT not defined in device header file; using default!"
 181:../Includes/core_cm0plus.h ****   #endif
 182:../Includes/core_cm0plus.h **** 
 183:../Includes/core_cm0plus.h ****   #ifndef __NVIC_PRIO_BITS
 184:../Includes/core_cm0plus.h ****     #define __NVIC_PRIO_BITS          2
 185:../Includes/core_cm0plus.h ****     #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
 186:../Includes/core_cm0plus.h ****   #endif
 187:../Includes/core_cm0plus.h **** 
 188:../Includes/core_cm0plus.h ****   #ifndef __Vendor_SysTickConfig
 189:../Includes/core_cm0plus.h ****     #define __Vendor_SysTickConfig    0
 190:../Includes/core_cm0plus.h ****     #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
 191:../Includes/core_cm0plus.h ****   #endif
 192:../Includes/core_cm0plus.h **** #endif
 193:../Includes/core_cm0plus.h **** 
 194:../Includes/core_cm0plus.h **** /* IO definitions (access restrictions to peripheral registers) */
 195:../Includes/core_cm0plus.h **** /**
 196:../Includes/core_cm0plus.h ****     \defgroup CMSIS_glob_defs CMSIS Global Defines
 197:../Includes/core_cm0plus.h **** 
 198:../Includes/core_cm0plus.h ****     <strong>IO Type Qualifiers</strong> are used
 199:../Includes/core_cm0plus.h ****     \li to specify the access to peripheral variables.
 200:../Includes/core_cm0plus.h ****     \li for automatic generation of peripheral register debug information.
 201:../Includes/core_cm0plus.h **** */
 202:../Includes/core_cm0plus.h **** #ifdef __cplusplus
 203:../Includes/core_cm0plus.h ****   #define   __I     volatile             /*!< Defines 'read only' permissions                 */
 204:../Includes/core_cm0plus.h **** #else
 205:../Includes/core_cm0plus.h ****   #define   __I     volatile const       /*!< Defines 'read only' permissions                 */
 206:../Includes/core_cm0plus.h **** #endif
 207:../Includes/core_cm0plus.h **** #define     __O     volatile             /*!< Defines 'write only' permissions                */
 208:../Includes/core_cm0plus.h **** #define     __IO    volatile             /*!< Defines 'read / write' permissions              */
 209:../Includes/core_cm0plus.h **** 
 210:../Includes/core_cm0plus.h **** /*@} end of group Cortex-M0+ */
 211:../Includes/core_cm0plus.h **** 
 212:../Includes/core_cm0plus.h **** 
 213:../Includes/core_cm0plus.h **** 
 214:../Includes/core_cm0plus.h **** /*******************************************************************************
 215:../Includes/core_cm0plus.h ****  *                 Register Abstraction
 216:../Includes/core_cm0plus.h ****   Core Register contain:
 217:../Includes/core_cm0plus.h ****   - Core Register
 218:../Includes/core_cm0plus.h ****   - Core NVIC Register
 219:../Includes/core_cm0plus.h ****   - Core SCB Register
 220:../Includes/core_cm0plus.h ****   - Core SysTick Register
 221:../Includes/core_cm0plus.h ****   - Core MPU Register
 222:../Includes/core_cm0plus.h ****  ******************************************************************************/
 223:../Includes/core_cm0plus.h **** /** \defgroup CMSIS_core_register Defines and Type Definitions
 224:../Includes/core_cm0plus.h ****     \brief Type definitions and defines for Cortex-M processor based devices.
 225:../Includes/core_cm0plus.h **** */
 226:../Includes/core_cm0plus.h **** 
 227:../Includes/core_cm0plus.h **** /** \ingroup    CMSIS_core_register
 228:../Includes/core_cm0plus.h ****     \defgroup   CMSIS_CORE  Status and Control Registers
 229:../Includes/core_cm0plus.h ****     \brief  Core Register type definitions.
 230:../Includes/core_cm0plus.h ****   @{
 231:../Includes/core_cm0plus.h ****  */
 232:../Includes/core_cm0plus.h **** 
 233:../Includes/core_cm0plus.h **** /** \brief  Union type to access the Application Program Status Register (APSR).
 234:../Includes/core_cm0plus.h ****  */
 235:../Includes/core_cm0plus.h **** typedef union
 236:../Includes/core_cm0plus.h **** {
 237:../Includes/core_cm0plus.h ****   struct
 238:../Includes/core_cm0plus.h ****   {
 239:../Includes/core_cm0plus.h ****     uint32_t _reserved0:28;              /*!< bit:  0..27  Reserved                           */
 240:../Includes/core_cm0plus.h ****     uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
 241:../Includes/core_cm0plus.h ****     uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
 242:../Includes/core_cm0plus.h ****     uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
 243:../Includes/core_cm0plus.h ****     uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
 244:../Includes/core_cm0plus.h ****   } b;                                   /*!< Structure used for bit  access                  */
 245:../Includes/core_cm0plus.h ****   uint32_t w;                            /*!< Type      used for word access                  */
 246:../Includes/core_cm0plus.h **** } APSR_Type;
 247:../Includes/core_cm0plus.h **** 
 248:../Includes/core_cm0plus.h **** /* APSR Register Definitions */
 249:../Includes/core_cm0plus.h **** #define APSR_N_Pos                         31                                             /*!< APSR
 250:../Includes/core_cm0plus.h **** #define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR
 251:../Includes/core_cm0plus.h **** 
 252:../Includes/core_cm0plus.h **** #define APSR_Z_Pos                         30                                             /*!< APSR
 253:../Includes/core_cm0plus.h **** #define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR
 254:../Includes/core_cm0plus.h **** 
 255:../Includes/core_cm0plus.h **** #define APSR_C_Pos                         29                                             /*!< APSR
 256:../Includes/core_cm0plus.h **** #define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR
 257:../Includes/core_cm0plus.h **** 
 258:../Includes/core_cm0plus.h **** #define APSR_V_Pos                         28                                             /*!< APSR
 259:../Includes/core_cm0plus.h **** #define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR
 260:../Includes/core_cm0plus.h **** 
 261:../Includes/core_cm0plus.h **** 
 262:../Includes/core_cm0plus.h **** /** \brief  Union type to access the Interrupt Program Status Register (IPSR).
 263:../Includes/core_cm0plus.h ****  */
 264:../Includes/core_cm0plus.h **** typedef union
 265:../Includes/core_cm0plus.h **** {
 266:../Includes/core_cm0plus.h ****   struct
 267:../Includes/core_cm0plus.h ****   {
 268:../Includes/core_cm0plus.h ****     uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
 269:../Includes/core_cm0plus.h ****     uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved                           */
 270:../Includes/core_cm0plus.h ****   } b;                                   /*!< Structure used for bit  access                  */
 271:../Includes/core_cm0plus.h ****   uint32_t w;                            /*!< Type      used for word access                  */
 272:../Includes/core_cm0plus.h **** } IPSR_Type;
 273:../Includes/core_cm0plus.h **** 
 274:../Includes/core_cm0plus.h **** /* IPSR Register Definitions */
 275:../Includes/core_cm0plus.h **** #define IPSR_ISR_Pos                        0                                             /*!< IPSR
 276:../Includes/core_cm0plus.h **** #define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR
 277:../Includes/core_cm0plus.h **** 
 278:../Includes/core_cm0plus.h **** 
 279:../Includes/core_cm0plus.h **** /** \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
 280:../Includes/core_cm0plus.h ****  */
 281:../Includes/core_cm0plus.h **** typedef union
 282:../Includes/core_cm0plus.h **** {
 283:../Includes/core_cm0plus.h ****   struct
 284:../Includes/core_cm0plus.h ****   {
 285:../Includes/core_cm0plus.h ****     uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
 286:../Includes/core_cm0plus.h ****     uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved                           */
 287:../Includes/core_cm0plus.h ****     uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0)          */
 288:../Includes/core_cm0plus.h ****     uint32_t _reserved1:3;               /*!< bit: 25..27  Reserved                           */
 289:../Includes/core_cm0plus.h ****     uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
 290:../Includes/core_cm0plus.h ****     uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
 291:../Includes/core_cm0plus.h ****     uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
 292:../Includes/core_cm0plus.h ****     uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
 293:../Includes/core_cm0plus.h ****   } b;                                   /*!< Structure used for bit  access                  */
 294:../Includes/core_cm0plus.h ****   uint32_t w;                            /*!< Type      used for word access                  */
 295:../Includes/core_cm0plus.h **** } xPSR_Type;
 296:../Includes/core_cm0plus.h **** 
 297:../Includes/core_cm0plus.h **** /* xPSR Register Definitions */
 298:../Includes/core_cm0plus.h **** #define xPSR_N_Pos                         31                                             /*!< xPSR
 299:../Includes/core_cm0plus.h **** #define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR
 300:../Includes/core_cm0plus.h **** 
 301:../Includes/core_cm0plus.h **** #define xPSR_Z_Pos                         30                                             /*!< xPSR
 302:../Includes/core_cm0plus.h **** #define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR
 303:../Includes/core_cm0plus.h **** 
 304:../Includes/core_cm0plus.h **** #define xPSR_C_Pos                         29                                             /*!< xPSR
 305:../Includes/core_cm0plus.h **** #define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR
 306:../Includes/core_cm0plus.h **** 
 307:../Includes/core_cm0plus.h **** #define xPSR_V_Pos                         28                                             /*!< xPSR
 308:../Includes/core_cm0plus.h **** #define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR
 309:../Includes/core_cm0plus.h **** 
 310:../Includes/core_cm0plus.h **** #define xPSR_T_Pos                         24                                             /*!< xPSR
 311:../Includes/core_cm0plus.h **** #define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR
 312:../Includes/core_cm0plus.h **** 
 313:../Includes/core_cm0plus.h **** #define xPSR_ISR_Pos                        0                                             /*!< xPSR
 314:../Includes/core_cm0plus.h **** #define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR
 315:../Includes/core_cm0plus.h **** 
 316:../Includes/core_cm0plus.h **** 
 317:../Includes/core_cm0plus.h **** /** \brief  Union type to access the Control Registers (CONTROL).
 318:../Includes/core_cm0plus.h ****  */
 319:../Includes/core_cm0plus.h **** typedef union
 320:../Includes/core_cm0plus.h **** {
 321:../Includes/core_cm0plus.h ****   struct
 322:../Includes/core_cm0plus.h ****   {
 323:../Includes/core_cm0plus.h ****     uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
 324:../Includes/core_cm0plus.h ****     uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used                   */
 325:../Includes/core_cm0plus.h ****     uint32_t _reserved1:30;              /*!< bit:  2..31  Reserved                           */
 326:../Includes/core_cm0plus.h ****   } b;                                   /*!< Structure used for bit  access                  */
 327:../Includes/core_cm0plus.h ****   uint32_t w;                            /*!< Type      used for word access                  */
 328:../Includes/core_cm0plus.h **** } CONTROL_Type;
 329:../Includes/core_cm0plus.h **** 
 330:../Includes/core_cm0plus.h **** /* CONTROL Register Definitions */
 331:../Includes/core_cm0plus.h **** #define CONTROL_SPSEL_Pos                   1                                             /*!< CONT
 332:../Includes/core_cm0plus.h **** #define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONT
 333:../Includes/core_cm0plus.h **** 
 334:../Includes/core_cm0plus.h **** #define CONTROL_nPRIV_Pos                   0                                             /*!< CONT
 335:../Includes/core_cm0plus.h **** #define CONTROL_nPRIV_Msk                  (1UL /*<< CONTROL_nPRIV_Pos*/)                 /*!< CONT
 336:../Includes/core_cm0plus.h **** 
 337:../Includes/core_cm0plus.h **** /*@} end of group CMSIS_CORE */
 338:../Includes/core_cm0plus.h **** 
 339:../Includes/core_cm0plus.h **** 
 340:../Includes/core_cm0plus.h **** /** \ingroup    CMSIS_core_register
 341:../Includes/core_cm0plus.h ****     \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
 342:../Includes/core_cm0plus.h ****     \brief      Type definitions for the NVIC Registers
 343:../Includes/core_cm0plus.h ****   @{
 344:../Includes/core_cm0plus.h ****  */
 345:../Includes/core_cm0plus.h **** 
 346:../Includes/core_cm0plus.h **** /** \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
 347:../Includes/core_cm0plus.h ****  */
 348:../Includes/core_cm0plus.h **** typedef struct
 349:../Includes/core_cm0plus.h **** {
 350:../Includes/core_cm0plus.h ****   __IO uint32_t ISER[1];                 /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register   
 351:../Includes/core_cm0plus.h ****        uint32_t RESERVED0[31];
 352:../Includes/core_cm0plus.h ****   __IO uint32_t ICER[1];                 /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register 
 353:../Includes/core_cm0plus.h ****        uint32_t RSERVED1[31];
 354:../Includes/core_cm0plus.h ****   __IO uint32_t ISPR[1];                 /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register  
 355:../Includes/core_cm0plus.h ****        uint32_t RESERVED2[31];
 356:../Includes/core_cm0plus.h ****   __IO uint32_t ICPR[1];                 /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register
 357:../Includes/core_cm0plus.h ****        uint32_t RESERVED3[31];
 358:../Includes/core_cm0plus.h ****        uint32_t RESERVED4[64];
 359:../Includes/core_cm0plus.h ****   __IO uint32_t IP[8];                   /*!< Offset: 0x300 (R/W)  Interrupt Priority Register     
 360:../Includes/core_cm0plus.h **** }  NVIC_Type;
 361:../Includes/core_cm0plus.h **** 
 362:../Includes/core_cm0plus.h **** /*@} end of group CMSIS_NVIC */
 363:../Includes/core_cm0plus.h **** 
 364:../Includes/core_cm0plus.h **** 
 365:../Includes/core_cm0plus.h **** /** \ingroup  CMSIS_core_register
 366:../Includes/core_cm0plus.h ****     \defgroup CMSIS_SCB     System Control Block (SCB)
 367:../Includes/core_cm0plus.h ****     \brief      Type definitions for the System Control Block Registers
 368:../Includes/core_cm0plus.h ****   @{
 369:../Includes/core_cm0plus.h ****  */
 370:../Includes/core_cm0plus.h **** 
 371:../Includes/core_cm0plus.h **** /** \brief  Structure type to access the System Control Block (SCB).
 372:../Includes/core_cm0plus.h ****  */
 373:../Includes/core_cm0plus.h **** typedef struct
 374:../Includes/core_cm0plus.h **** {
 375:../Includes/core_cm0plus.h ****   __I  uint32_t CPUID;                   /*!< Offset: 0x000 (R/ )  CPUID Base Register             
 376:../Includes/core_cm0plus.h ****   __IO uint32_t ICSR;                    /*!< Offset: 0x004 (R/W)  Interrupt Control and State Regi
 377:../Includes/core_cm0plus.h **** #if (__VTOR_PRESENT == 1)
 378:../Includes/core_cm0plus.h ****   __IO uint32_t VTOR;                    /*!< Offset: 0x008 (R/W)  Vector Table Offset Register    
 379:../Includes/core_cm0plus.h **** #else
 380:../Includes/core_cm0plus.h ****        uint32_t RESERVED0;
 381:../Includes/core_cm0plus.h **** #endif
 382:../Includes/core_cm0plus.h ****   __IO uint32_t AIRCR;                   /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset 
 383:../Includes/core_cm0plus.h ****   __IO uint32_t SCR;                     /*!< Offset: 0x010 (R/W)  System Control Register         
 384:../Includes/core_cm0plus.h ****   __IO uint32_t CCR;                     /*!< Offset: 0x014 (R/W)  Configuration Control Register  
 385:../Includes/core_cm0plus.h ****        uint32_t RESERVED1;
 386:../Includes/core_cm0plus.h ****   __IO uint32_t SHP[2];                  /*!< Offset: 0x01C (R/W)  System Handlers Priority Registe
 387:../Includes/core_cm0plus.h ****   __IO uint32_t SHCSR;                   /*!< Offset: 0x024 (R/W)  System Handler Control and State
 388:../Includes/core_cm0plus.h **** } SCB_Type;
 389:../Includes/core_cm0plus.h **** 
 390:../Includes/core_cm0plus.h **** /* SCB CPUID Register Definitions */
 391:../Includes/core_cm0plus.h **** #define SCB_CPUID_IMPLEMENTER_Pos          24                                             /*!< SCB 
 392:../Includes/core_cm0plus.h **** #define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB 
 393:../Includes/core_cm0plus.h **** 
 394:../Includes/core_cm0plus.h **** #define SCB_CPUID_VARIANT_Pos              20                                             /*!< SCB 
 395:../Includes/core_cm0plus.h **** #define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB 
 396:../Includes/core_cm0plus.h **** 
 397:../Includes/core_cm0plus.h **** #define SCB_CPUID_ARCHITECTURE_Pos         16                                             /*!< SCB 
 398:../Includes/core_cm0plus.h **** #define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB 
 399:../Includes/core_cm0plus.h **** 
 400:../Includes/core_cm0plus.h **** #define SCB_CPUID_PARTNO_Pos                4                                             /*!< SCB 
 401:../Includes/core_cm0plus.h **** #define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB 
 402:../Includes/core_cm0plus.h **** 
 403:../Includes/core_cm0plus.h **** #define SCB_CPUID_REVISION_Pos              0                                             /*!< SCB 
 404:../Includes/core_cm0plus.h **** #define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB 
 405:../Includes/core_cm0plus.h **** 
 406:../Includes/core_cm0plus.h **** /* SCB Interrupt Control State Register Definitions */
 407:../Includes/core_cm0plus.h **** #define SCB_ICSR_NMIPENDSET_Pos            31                                             /*!< SCB 
 408:../Includes/core_cm0plus.h **** #define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB 
 409:../Includes/core_cm0plus.h **** 
 410:../Includes/core_cm0plus.h **** #define SCB_ICSR_PENDSVSET_Pos             28                                             /*!< SCB 
 411:../Includes/core_cm0plus.h **** #define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB 
 412:../Includes/core_cm0plus.h **** 
 413:../Includes/core_cm0plus.h **** #define SCB_ICSR_PENDSVCLR_Pos             27                                             /*!< SCB 
 414:../Includes/core_cm0plus.h **** #define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB 
 415:../Includes/core_cm0plus.h **** 
 416:../Includes/core_cm0plus.h **** #define SCB_ICSR_PENDSTSET_Pos             26                                             /*!< SCB 
 417:../Includes/core_cm0plus.h **** #define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB 
 418:../Includes/core_cm0plus.h **** 
 419:../Includes/core_cm0plus.h **** #define SCB_ICSR_PENDSTCLR_Pos             25                                             /*!< SCB 
 420:../Includes/core_cm0plus.h **** #define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB 
 421:../Includes/core_cm0plus.h **** 
 422:../Includes/core_cm0plus.h **** #define SCB_ICSR_ISRPREEMPT_Pos            23                                             /*!< SCB 
 423:../Includes/core_cm0plus.h **** #define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB 
 424:../Includes/core_cm0plus.h **** 
 425:../Includes/core_cm0plus.h **** #define SCB_ICSR_ISRPENDING_Pos            22                                             /*!< SCB 
 426:../Includes/core_cm0plus.h **** #define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB 
 427:../Includes/core_cm0plus.h **** 
 428:../Includes/core_cm0plus.h **** #define SCB_ICSR_VECTPENDING_Pos           12                                             /*!< SCB 
 429:../Includes/core_cm0plus.h **** #define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB 
 430:../Includes/core_cm0plus.h **** 
 431:../Includes/core_cm0plus.h **** #define SCB_ICSR_VECTACTIVE_Pos             0                                             /*!< SCB 
 432:../Includes/core_cm0plus.h **** #define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB 
 433:../Includes/core_cm0plus.h **** 
 434:../Includes/core_cm0plus.h **** #if (__VTOR_PRESENT == 1)
 435:../Includes/core_cm0plus.h **** /* SCB Interrupt Control State Register Definitions */
 436:../Includes/core_cm0plus.h **** #define SCB_VTOR_TBLOFF_Pos                 8                                             /*!< SCB 
 437:../Includes/core_cm0plus.h **** #define SCB_VTOR_TBLOFF_Msk                (0xFFFFFFUL << SCB_VTOR_TBLOFF_Pos)            /*!< SCB 
 438:../Includes/core_cm0plus.h **** #endif
 439:../Includes/core_cm0plus.h **** 
 440:../Includes/core_cm0plus.h **** /* SCB Application Interrupt and Reset Control Register Definitions */
 441:../Includes/core_cm0plus.h **** #define SCB_AIRCR_VECTKEY_Pos              16                                             /*!< SCB 
 442:../Includes/core_cm0plus.h **** #define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB 
 443:../Includes/core_cm0plus.h **** 
 444:../Includes/core_cm0plus.h **** #define SCB_AIRCR_VECTKEYSTAT_Pos          16                                             /*!< SCB 
 445:../Includes/core_cm0plus.h **** #define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB 
 446:../Includes/core_cm0plus.h **** 
 447:../Includes/core_cm0plus.h **** #define SCB_AIRCR_ENDIANESS_Pos            15                                             /*!< SCB 
 448:../Includes/core_cm0plus.h **** #define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB 
 449:../Includes/core_cm0plus.h **** 
 450:../Includes/core_cm0plus.h **** #define SCB_AIRCR_SYSRESETREQ_Pos           2                                             /*!< SCB 
 451:../Includes/core_cm0plus.h **** #define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB 
 452:../Includes/core_cm0plus.h **** 
 453:../Includes/core_cm0plus.h **** #define SCB_AIRCR_VECTCLRACTIVE_Pos         1                                             /*!< SCB 
 454:../Includes/core_cm0plus.h **** #define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB 
 455:../Includes/core_cm0plus.h **** 
 456:../Includes/core_cm0plus.h **** /* SCB System Control Register Definitions */
 457:../Includes/core_cm0plus.h **** #define SCB_SCR_SEVONPEND_Pos               4                                             /*!< SCB 
 458:../Includes/core_cm0plus.h **** #define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB 
 459:../Includes/core_cm0plus.h **** 
 460:../Includes/core_cm0plus.h **** #define SCB_SCR_SLEEPDEEP_Pos               2                                             /*!< SCB 
 461:../Includes/core_cm0plus.h **** #define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB 
 462:../Includes/core_cm0plus.h **** 
 463:../Includes/core_cm0plus.h **** #define SCB_SCR_SLEEPONEXIT_Pos             1                                             /*!< SCB 
 464:../Includes/core_cm0plus.h **** #define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB 
 465:../Includes/core_cm0plus.h **** 
 466:../Includes/core_cm0plus.h **** /* SCB Configuration Control Register Definitions */
 467:../Includes/core_cm0plus.h **** #define SCB_CCR_STKALIGN_Pos                9                                             /*!< SCB 
 468:../Includes/core_cm0plus.h **** #define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB 
 469:../Includes/core_cm0plus.h **** 
 470:../Includes/core_cm0plus.h **** #define SCB_CCR_UNALIGN_TRP_Pos             3                                             /*!< SCB 
 471:../Includes/core_cm0plus.h **** #define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB 
 472:../Includes/core_cm0plus.h **** 
 473:../Includes/core_cm0plus.h **** /* SCB System Handler Control and State Register Definitions */
 474:../Includes/core_cm0plus.h **** #define SCB_SHCSR_SVCALLPENDED_Pos         15                                             /*!< SCB 
 475:../Includes/core_cm0plus.h **** #define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB 
 476:../Includes/core_cm0plus.h **** 
 477:../Includes/core_cm0plus.h **** /*@} end of group CMSIS_SCB */
 478:../Includes/core_cm0plus.h **** 
 479:../Includes/core_cm0plus.h **** 
 480:../Includes/core_cm0plus.h **** /** \ingroup  CMSIS_core_register
 481:../Includes/core_cm0plus.h ****     \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
 482:../Includes/core_cm0plus.h ****     \brief      Type definitions for the System Timer Registers.
 483:../Includes/core_cm0plus.h ****   @{
 484:../Includes/core_cm0plus.h ****  */
 485:../Includes/core_cm0plus.h **** 
 486:../Includes/core_cm0plus.h **** /** \brief  Structure type to access the System Timer (SysTick).
 487:../Includes/core_cm0plus.h ****  */
 488:../Includes/core_cm0plus.h **** typedef struct
 489:../Includes/core_cm0plus.h **** {
 490:../Includes/core_cm0plus.h ****   __IO uint32_t CTRL;                    /*!< Offset: 0x000 (R/W)  SysTick Control and Status Regis
 491:../Includes/core_cm0plus.h ****   __IO uint32_t LOAD;                    /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register   
 492:../Includes/core_cm0plus.h ****   __IO uint32_t VAL;                     /*!< Offset: 0x008 (R/W)  SysTick Current Value Register  
 493:../Includes/core_cm0plus.h ****   __I  uint32_t CALIB;                   /*!< Offset: 0x00C (R/ )  SysTick Calibration Register    
 494:../Includes/core_cm0plus.h **** } SysTick_Type;
 495:../Includes/core_cm0plus.h **** 
 496:../Includes/core_cm0plus.h **** /* SysTick Control / Status Register Definitions */
 497:../Includes/core_cm0plus.h **** #define SysTick_CTRL_COUNTFLAG_Pos         16                                             /*!< SysT
 498:../Includes/core_cm0plus.h **** #define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysT
 499:../Includes/core_cm0plus.h **** 
 500:../Includes/core_cm0plus.h **** #define SysTick_CTRL_CLKSOURCE_Pos          2                                             /*!< SysT
 501:../Includes/core_cm0plus.h **** #define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysT
 502:../Includes/core_cm0plus.h **** 
 503:../Includes/core_cm0plus.h **** #define SysTick_CTRL_TICKINT_Pos            1                                             /*!< SysT
 504:../Includes/core_cm0plus.h **** #define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysT
 505:../Includes/core_cm0plus.h **** 
 506:../Includes/core_cm0plus.h **** #define SysTick_CTRL_ENABLE_Pos             0                                             /*!< SysT
 507:../Includes/core_cm0plus.h **** #define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysT
 508:../Includes/core_cm0plus.h **** 
 509:../Includes/core_cm0plus.h **** /* SysTick Reload Register Definitions */
 510:../Includes/core_cm0plus.h **** #define SysTick_LOAD_RELOAD_Pos             0                                             /*!< SysT
 511:../Includes/core_cm0plus.h **** #define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysT
 512:../Includes/core_cm0plus.h **** 
 513:../Includes/core_cm0plus.h **** /* SysTick Current Register Definitions */
 514:../Includes/core_cm0plus.h **** #define SysTick_VAL_CURRENT_Pos             0                                             /*!< SysT
 515:../Includes/core_cm0plus.h **** #define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysT
 516:../Includes/core_cm0plus.h **** 
 517:../Includes/core_cm0plus.h **** /* SysTick Calibration Register Definitions */
 518:../Includes/core_cm0plus.h **** #define SysTick_CALIB_NOREF_Pos            31                                             /*!< SysT
 519:../Includes/core_cm0plus.h **** #define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysT
 520:../Includes/core_cm0plus.h **** 
 521:../Includes/core_cm0plus.h **** #define SysTick_CALIB_SKEW_Pos             30                                             /*!< SysT
 522:../Includes/core_cm0plus.h **** #define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysT
 523:../Includes/core_cm0plus.h **** 
 524:../Includes/core_cm0plus.h **** #define SysTick_CALIB_TENMS_Pos             0                                             /*!< SysT
 525:../Includes/core_cm0plus.h **** #define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysT
 526:../Includes/core_cm0plus.h **** 
 527:../Includes/core_cm0plus.h **** /*@} end of group CMSIS_SysTick */
 528:../Includes/core_cm0plus.h **** 
 529:../Includes/core_cm0plus.h **** #if (__MPU_PRESENT == 1)
 530:../Includes/core_cm0plus.h **** /** \ingroup  CMSIS_core_register
 531:../Includes/core_cm0plus.h ****     \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
 532:../Includes/core_cm0plus.h ****     \brief      Type definitions for the Memory Protection Unit (MPU)
 533:../Includes/core_cm0plus.h ****   @{
 534:../Includes/core_cm0plus.h ****  */
 535:../Includes/core_cm0plus.h **** 
 536:../Includes/core_cm0plus.h **** /** \brief  Structure type to access the Memory Protection Unit (MPU).
 537:../Includes/core_cm0plus.h ****  */
 538:../Includes/core_cm0plus.h **** typedef struct
 539:../Includes/core_cm0plus.h **** {
 540:../Includes/core_cm0plus.h ****   __I  uint32_t TYPE;                    /*!< Offset: 0x000 (R/ )  MPU Type Register               
 541:../Includes/core_cm0plus.h ****   __IO uint32_t CTRL;                    /*!< Offset: 0x004 (R/W)  MPU Control Register            
 542:../Includes/core_cm0plus.h ****   __IO uint32_t RNR;                     /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register      
 543:../Includes/core_cm0plus.h ****   __IO uint32_t RBAR;                    /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register
 544:../Includes/core_cm0plus.h ****   __IO uint32_t RASR;                    /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Re
 545:../Includes/core_cm0plus.h **** } MPU_Type;
 546:../Includes/core_cm0plus.h **** 
 547:../Includes/core_cm0plus.h **** /* MPU Type Register */
 548:../Includes/core_cm0plus.h **** #define MPU_TYPE_IREGION_Pos               16                                             /*!< MPU 
 549:../Includes/core_cm0plus.h **** #define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU 
 550:../Includes/core_cm0plus.h **** 
 551:../Includes/core_cm0plus.h **** #define MPU_TYPE_DREGION_Pos                8                                             /*!< MPU 
 552:../Includes/core_cm0plus.h **** #define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU 
 553:../Includes/core_cm0plus.h **** 
 554:../Includes/core_cm0plus.h **** #define MPU_TYPE_SEPARATE_Pos               0                                             /*!< MPU 
 555:../Includes/core_cm0plus.h **** #define MPU_TYPE_SEPARATE_Msk              (1UL /*<< MPU_TYPE_SEPARATE_Pos*/)             /*!< MPU 
 556:../Includes/core_cm0plus.h **** 
 557:../Includes/core_cm0plus.h **** /* MPU Control Register */
 558:../Includes/core_cm0plus.h **** #define MPU_CTRL_PRIVDEFENA_Pos             2                                             /*!< MPU 
 559:../Includes/core_cm0plus.h **** #define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU 
 560:../Includes/core_cm0plus.h **** 
 561:../Includes/core_cm0plus.h **** #define MPU_CTRL_HFNMIENA_Pos               1                                             /*!< MPU 
 562:../Includes/core_cm0plus.h **** #define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU 
 563:../Includes/core_cm0plus.h **** 
 564:../Includes/core_cm0plus.h **** #define MPU_CTRL_ENABLE_Pos                 0                                             /*!< MPU 
 565:../Includes/core_cm0plus.h **** #define MPU_CTRL_ENABLE_Msk                (1UL /*<< MPU_CTRL_ENABLE_Pos*/)               /*!< MPU 
 566:../Includes/core_cm0plus.h **** 
 567:../Includes/core_cm0plus.h **** /* MPU Region Number Register */
 568:../Includes/core_cm0plus.h **** #define MPU_RNR_REGION_Pos                  0                                             /*!< MPU 
 569:../Includes/core_cm0plus.h **** #define MPU_RNR_REGION_Msk                 (0xFFUL /*<< MPU_RNR_REGION_Pos*/)             /*!< MPU 
 570:../Includes/core_cm0plus.h **** 
 571:../Includes/core_cm0plus.h **** /* MPU Region Base Address Register */
 572:../Includes/core_cm0plus.h **** #define MPU_RBAR_ADDR_Pos                   8                                             /*!< MPU 
 573:../Includes/core_cm0plus.h **** #define MPU_RBAR_ADDR_Msk                  (0xFFFFFFUL << MPU_RBAR_ADDR_Pos)              /*!< MPU 
 574:../Includes/core_cm0plus.h **** 
 575:../Includes/core_cm0plus.h **** #define MPU_RBAR_VALID_Pos                  4                                             /*!< MPU 
 576:../Includes/core_cm0plus.h **** #define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU 
 577:../Includes/core_cm0plus.h **** 
 578:../Includes/core_cm0plus.h **** #define MPU_RBAR_REGION_Pos                 0                                             /*!< MPU 
 579:../Includes/core_cm0plus.h **** #define MPU_RBAR_REGION_Msk                (0xFUL /*<< MPU_RBAR_REGION_Pos*/)             /*!< MPU 
 580:../Includes/core_cm0plus.h **** 
 581:../Includes/core_cm0plus.h **** /* MPU Region Attribute and Size Register */
 582:../Includes/core_cm0plus.h **** #define MPU_RASR_ATTRS_Pos                 16                                             /*!< MPU 
 583:../Includes/core_cm0plus.h **** #define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU 
 584:../Includes/core_cm0plus.h **** 
 585:../Includes/core_cm0plus.h **** #define MPU_RASR_XN_Pos                    28                                             /*!< MPU 
 586:../Includes/core_cm0plus.h **** #define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU 
 587:../Includes/core_cm0plus.h **** 
 588:../Includes/core_cm0plus.h **** #define MPU_RASR_AP_Pos                    24                                             /*!< MPU 
 589:../Includes/core_cm0plus.h **** #define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU 
 590:../Includes/core_cm0plus.h **** 
 591:../Includes/core_cm0plus.h **** #define MPU_RASR_TEX_Pos                   19                                             /*!< MPU 
 592:../Includes/core_cm0plus.h **** #define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU 
 593:../Includes/core_cm0plus.h **** 
 594:../Includes/core_cm0plus.h **** #define MPU_RASR_S_Pos                     18                                             /*!< MPU 
 595:../Includes/core_cm0plus.h **** #define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU 
 596:../Includes/core_cm0plus.h **** 
 597:../Includes/core_cm0plus.h **** #define MPU_RASR_C_Pos                     17                                             /*!< MPU 
 598:../Includes/core_cm0plus.h **** #define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU 
 599:../Includes/core_cm0plus.h **** 
 600:../Includes/core_cm0plus.h **** #define MPU_RASR_B_Pos                     16                                             /*!< MPU 
 601:../Includes/core_cm0plus.h **** #define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU 
 602:../Includes/core_cm0plus.h **** 
 603:../Includes/core_cm0plus.h **** #define MPU_RASR_SRD_Pos                    8                                             /*!< MPU 
 604:../Includes/core_cm0plus.h **** #define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU 
 605:../Includes/core_cm0plus.h **** 
 606:../Includes/core_cm0plus.h **** #define MPU_RASR_SIZE_Pos                   1                                             /*!< MPU 
 607:../Includes/core_cm0plus.h **** #define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU 
 608:../Includes/core_cm0plus.h **** 
 609:../Includes/core_cm0plus.h **** #define MPU_RASR_ENABLE_Pos                 0                                             /*!< MPU 
 610:../Includes/core_cm0plus.h **** #define MPU_RASR_ENABLE_Msk                (1UL /*<< MPU_RASR_ENABLE_Pos*/)               /*!< MPU 
 611:../Includes/core_cm0plus.h **** 
 612:../Includes/core_cm0plus.h **** /*@} end of group CMSIS_MPU */
 613:../Includes/core_cm0plus.h **** #endif
 614:../Includes/core_cm0plus.h **** 
 615:../Includes/core_cm0plus.h **** 
 616:../Includes/core_cm0plus.h **** /** \ingroup  CMSIS_core_register
 617:../Includes/core_cm0plus.h ****     \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
 618:../Includes/core_cm0plus.h ****     \brief      Cortex-M0+ Core Debug Registers (DCB registers, SHCSR, and DFSR)
 619:../Includes/core_cm0plus.h ****                 are only accessible over DAP and not via processor. Therefore
 620:../Includes/core_cm0plus.h ****                 they are not covered by the Cortex-M0 header file.
 621:../Includes/core_cm0plus.h ****   @{
 622:../Includes/core_cm0plus.h ****  */
 623:../Includes/core_cm0plus.h **** /*@} end of group CMSIS_CoreDebug */
 624:../Includes/core_cm0plus.h **** 
 625:../Includes/core_cm0plus.h **** 
 626:../Includes/core_cm0plus.h **** /** \ingroup    CMSIS_core_register
 627:../Includes/core_cm0plus.h ****     \defgroup   CMSIS_core_base     Core Definitions
 628:../Includes/core_cm0plus.h ****     \brief      Definitions for base addresses, unions, and structures.
 629:../Includes/core_cm0plus.h ****   @{
 630:../Includes/core_cm0plus.h ****  */
 631:../Includes/core_cm0plus.h **** 
 632:../Includes/core_cm0plus.h **** /* Memory mapping of Cortex-M0+ Hardware */
 633:../Includes/core_cm0plus.h **** #define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Bas
 634:../Includes/core_cm0plus.h **** #define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address    
 635:../Includes/core_cm0plus.h **** #define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address       
 636:../Includes/core_cm0plus.h **** #define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Bas
 637:../Includes/core_cm0plus.h **** 
 638:../Includes/core_cm0plus.h **** #define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct
 639:../Includes/core_cm0plus.h **** #define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration st
 640:../Includes/core_cm0plus.h **** #define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struc
 641:../Includes/core_cm0plus.h **** 
 642:../Includes/core_cm0plus.h **** #if (__MPU_PRESENT == 1)
 643:../Includes/core_cm0plus.h ****   #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit  
 644:../Includes/core_cm0plus.h ****   #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit  
 645:../Includes/core_cm0plus.h **** #endif
 646:../Includes/core_cm0plus.h **** 
 647:../Includes/core_cm0plus.h **** /*@} */
 648:../Includes/core_cm0plus.h **** 
 649:../Includes/core_cm0plus.h **** 
 650:../Includes/core_cm0plus.h **** 
 651:../Includes/core_cm0plus.h **** /*******************************************************************************
 652:../Includes/core_cm0plus.h ****  *                Hardware Abstraction Layer
 653:../Includes/core_cm0plus.h ****   Core Function Interface contains:
 654:../Includes/core_cm0plus.h ****   - Core NVIC Functions
 655:../Includes/core_cm0plus.h ****   - Core SysTick Functions
 656:../Includes/core_cm0plus.h ****   - Core Register Access Functions
 657:../Includes/core_cm0plus.h ****  ******************************************************************************/
 658:../Includes/core_cm0plus.h **** /** \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
 659:../Includes/core_cm0plus.h **** */
 660:../Includes/core_cm0plus.h **** 
 661:../Includes/core_cm0plus.h **** 
 662:../Includes/core_cm0plus.h **** 
 663:../Includes/core_cm0plus.h **** /* ##########################   NVIC functions  #################################### */
 664:../Includes/core_cm0plus.h **** /** \ingroup  CMSIS_Core_FunctionInterface
 665:../Includes/core_cm0plus.h ****     \defgroup CMSIS_Core_NVICFunctions NVIC Functions
 666:../Includes/core_cm0plus.h ****     \brief      Functions that manage interrupts and exceptions via the NVIC.
 667:../Includes/core_cm0plus.h ****     @{
 668:../Includes/core_cm0plus.h ****  */
 669:../Includes/core_cm0plus.h **** 
 670:../Includes/core_cm0plus.h **** /* Interrupt Priorities are WORD accessible only under ARMv6M                   */
 671:../Includes/core_cm0plus.h **** /* The following MACROS handle generation of the register offset and byte masks */
 672:../Includes/core_cm0plus.h **** #define _BIT_SHIFT(IRQn)         (  ((((uint32_t)(int32_t)(IRQn))         )      &  0x03UL) * 8UL)
 673:../Includes/core_cm0plus.h **** #define _SHP_IDX(IRQn)           ( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >>    2UL)      )
 674:../Includes/core_cm0plus.h **** #define _IP_IDX(IRQn)            (   (((uint32_t)(int32_t)(IRQn))                >>    2UL)      )
 675:../Includes/core_cm0plus.h **** 
 676:../Includes/core_cm0plus.h **** 
 677:../Includes/core_cm0plus.h **** /** \brief  Enable External Interrupt
 678:../Includes/core_cm0plus.h **** 
 679:../Includes/core_cm0plus.h ****     The function enables a device-specific interrupt in the NVIC interrupt controller.
 680:../Includes/core_cm0plus.h **** 
 681:../Includes/core_cm0plus.h ****     \param [in]      IRQn  External interrupt number. Value cannot be negative.
 682:../Includes/core_cm0plus.h ****  */
 683:../Includes/core_cm0plus.h **** __STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
 684:../Includes/core_cm0plus.h **** {
  25              		.loc 1 684 0
  26              		.cfi_startproc
  27 0000 80B5     		push	{r7, lr}
  28              		.cfi_def_cfa_offset 8
  29              		.cfi_offset 7, -8
  30              		.cfi_offset 14, -4
  31 0002 82B0     		sub	sp, sp, #8
  32              		.cfi_def_cfa_offset 16
  33 0004 00AF     		add	r7, sp, #0
  34              		.cfi_def_cfa_register 7
  35 0006 021C     		mov	r2, r0
  36 0008 FB1D     		add	r3, r7, #7
  37 000a 1A70     		strb	r2, [r3]
 685:../Includes/core_cm0plus.h ****   NVIC->ISER[0] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
  38              		.loc 1 685 0
  39 000c 064B     		ldr	r3, .L2
  40 000e FA1D     		add	r2, r7, #7
  41 0010 1278     		ldrb	r2, [r2]
  42 0012 111C     		mov	r1, r2
  43 0014 1F22     		mov	r2, #31
  44 0016 0A40     		and	r2, r1
  45 0018 0121     		mov	r1, #1
  46 001a 081C     		mov	r0, r1
  47 001c 9040     		lsl	r0, r0, r2
  48 001e 021C     		mov	r2, r0
  49 0020 1A60     		str	r2, [r3]
 686:../Includes/core_cm0plus.h **** }
  50              		.loc 1 686 0
  51 0022 BD46     		mov	sp, r7
  52 0024 02B0     		add	sp, sp, #8
  53              		@ sp needed
  54 0026 80BD     		pop	{r7, pc}
  55              	.L3:
  56              		.align	2
  57              	.L2:
  58 0028 00E100E0 		.word	-536813312
  59              		.cfi_endproc
  60              	.LFE25:
  62              		.section	.text.NVIC_DisableIRQ,"ax",%progbits
  63              		.align	2
  64              		.code	16
  65              		.thumb_func
  67              	NVIC_DisableIRQ:
  68              	.LFB26:
 687:../Includes/core_cm0plus.h **** 
 688:../Includes/core_cm0plus.h **** 
 689:../Includes/core_cm0plus.h **** /** \brief  Disable External Interrupt
 690:../Includes/core_cm0plus.h **** 
 691:../Includes/core_cm0plus.h ****     The function disables a device-specific interrupt in the NVIC interrupt controller.
 692:../Includes/core_cm0plus.h **** 
 693:../Includes/core_cm0plus.h ****     \param [in]      IRQn  External interrupt number. Value cannot be negative.
 694:../Includes/core_cm0plus.h ****  */
 695:../Includes/core_cm0plus.h **** __STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
 696:../Includes/core_cm0plus.h **** {
  69              		.loc 1 696 0
  70              		.cfi_startproc
  71 0000 80B5     		push	{r7, lr}
  72              		.cfi_def_cfa_offset 8
  73              		.cfi_offset 7, -8
  74              		.cfi_offset 14, -4
  75 0002 82B0     		sub	sp, sp, #8
  76              		.cfi_def_cfa_offset 16
  77 0004 00AF     		add	r7, sp, #0
  78              		.cfi_def_cfa_register 7
  79 0006 021C     		mov	r2, r0
  80 0008 FB1D     		add	r3, r7, #7
  81 000a 1A70     		strb	r2, [r3]
 697:../Includes/core_cm0plus.h ****   NVIC->ICER[0] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
  82              		.loc 1 697 0
  83 000c 064A     		ldr	r2, .L5
  84 000e FB1D     		add	r3, r7, #7
  85 0010 1B78     		ldrb	r3, [r3]
  86 0012 191C     		mov	r1, r3
  87 0014 1F23     		mov	r3, #31
  88 0016 0B40     		and	r3, r1
  89 0018 0121     		mov	r1, #1
  90 001a 9940     		lsl	r1, r1, r3
  91 001c 8023     		mov	r3, #128
  92 001e D150     		str	r1, [r2, r3]
 698:../Includes/core_cm0plus.h **** }
  93              		.loc 1 698 0
  94 0020 BD46     		mov	sp, r7
  95 0022 02B0     		add	sp, sp, #8
  96              		@ sp needed
  97 0024 80BD     		pop	{r7, pc}
  98              	.L6:
  99 0026 C046     		.align	2
 100              	.L5:
 101 0028 00E100E0 		.word	-536813312
 102              		.cfi_endproc
 103              	.LFE26:
 105              		.section	.rodata
 106              		.align	2
 107              	.LC0:
 108 0000 2E2E2F53 		.ascii	"../Sources/drivers/port/port.h\000"
 108      6F757263 
 108      65732F64 
 108      72697665 
 108      72732F70 
 109 001f 00       		.align	2
 110              	.LC3:
 111 0020 62617365 		.ascii	"base\000"
 111      00
 112              		.section	.text.PORT_Init,"ax",%progbits
 113              		.align	2
 114              		.code	16
 115              		.thumb_func
 117              	PORT_Init:
 118              	.LFB39:
 119              		.file 2 "../Sources/drivers/port/port.h"
   1:../Sources/drivers/port/port.h **** /***************************************************************************************
   2:../Sources/drivers/port/port.h ****  * Mdulo      : port.h
   3:../Sources/drivers/port/port.h ****  * Reviso     : 1.0
   4:../Sources/drivers/port/port.h ****  * Data        : 09/02/2023
   5:../Sources/drivers/port/port.h ****  * Descrio   : Arquivo com implementaes dos Mdulos PORT da Familia Kinetis KL05.
   6:../Sources/drivers/port/port.h ****  * Comentrios : Nenhum.
   7:../Sources/drivers/port/port.h ****  * Autor(es)   : Matheus Leitzke Pinto
   8:../Sources/drivers/port/port.h ****  ***************************************************************************************/
   9:../Sources/drivers/port/port.h **** 
  10:../Sources/drivers/port/port.h **** #ifndef PORT_DRV_H_
  11:../Sources/drivers/port/port.h **** #define PORT_DRV_H_
  12:../Sources/drivers/port/port.h **** 
  13:../Sources/drivers/port/port.h **** /*ARQUIVOS DE CABEALHO*/
  14:../Sources/drivers/port/port.h **** /*=======================================================================================*/
  15:../Sources/drivers/port/port.h **** 
  16:../Sources/drivers/port/port.h **** #include "drivers/common_driver.h"
  17:../Sources/drivers/port/port.h **** 
  18:../Sources/drivers/port/port.h **** /*FIM: ARQUIVOS DE CABEALHO*/
  19:../Sources/drivers/port/port.h **** /*=======================================================================================*/
  20:../Sources/drivers/port/port.h **** 
  21:../Sources/drivers/port/port.h **** /*TIPOS ENUMERADOS*/
  22:../Sources/drivers/port/port.h **** /*=======================================================================================*/
  23:../Sources/drivers/port/port.h **** 
  24:../Sources/drivers/port/port.h **** /*Possveis alternativas de multiplexao dos pinos das PORTs*/
  25:../Sources/drivers/port/port.h **** typedef enum{
  26:../Sources/drivers/port/port.h **** 	PORT_MUX_ALT0 		= 0x0u,
  27:../Sources/drivers/port/port.h **** 	PORT_MUX_ALT1 		= 0x1u,
  28:../Sources/drivers/port/port.h **** 	PORT_MUX_ALT2 		= 0x2u,
  29:../Sources/drivers/port/port.h **** 	PORT_MUX_ALT3 		= 0x3u,
  30:../Sources/drivers/port/port.h **** 	PORT_MUX_DISABLE 	= PORT_MUX_ALT0
  31:../Sources/drivers/port/port.h **** }portMux_t;
  32:../Sources/drivers/port/port.h **** 
  33:../Sources/drivers/port/port.h **** /*Possveis alternativas de interrupo dos pinos das PORTs*/
  34:../Sources/drivers/port/port.h **** typedef enum{
  35:../Sources/drivers/port/port.h **** 	PORT_IRQ_DISABLE 		 	 = 0x0U,
  36:../Sources/drivers/port/port.h **** 	PORT_IRQ_DMA_ON_RISING_EDGE  = 0x1U,
  37:../Sources/drivers/port/port.h **** 	PORT_IRQ_DMA_ON_FALLING_EDGE = 0x2U,
  38:../Sources/drivers/port/port.h **** 	PORT_IRQ_DMA_ON_EITHER_EDGE  = 0x3U,
  39:../Sources/drivers/port/port.h **** 	PORT_IRQ_ON_lOW_LEVEL		 = 0x8U,
  40:../Sources/drivers/port/port.h **** 	PORT_IRQ_ON_RISING_EDGE 	 = 0x9U,
  41:../Sources/drivers/port/port.h **** 	PORT_IRQ_ON_FALLING_EDGE 	 = 0xAU,
  42:../Sources/drivers/port/port.h **** 	PORT_IRQ_ON_EITHER_EDGE 	 = 0xBU,
  43:../Sources/drivers/port/port.h **** 	PORT_IRQ_ON_HIGH_LEVEL 	 	 = 0xCU
  44:../Sources/drivers/port/port.h **** }portIRQ_t;
  45:../Sources/drivers/port/port.h **** 
  46:../Sources/drivers/port/port.h **** /*FIM: TIPOS ENUMERADOS*/
  47:../Sources/drivers/port/port.h **** /*=======================================================================================*/
  48:../Sources/drivers/port/port.h **** 
  49:../Sources/drivers/port/port.h **** /*PROTOTIPOS - FUNES PBLICAS*/
  50:../Sources/drivers/port/port.h **** /*=======================================================================================*/
  51:../Sources/drivers/port/port.h **** 
  52:../Sources/drivers/port/port.h **** /**********************************************************************
  53:../Sources/drivers/port/port.h ****  * Funo		:	PORT_IRQEnable
  54:../Sources/drivers/port/port.h ****  *
  55:../Sources/drivers/port/port.h ****  * Descrio	:   Habilita a gerao de interrupo pelo pino de
  56:../Sources/drivers/port/port.h ****  * 					um mdulo PORT.
  57:../Sources/drivers/port/port.h ****  *
  58:../Sources/drivers/port/port.h ****  * Entradas		:   *base - registrador base do perifrico PORT.
  59:../Sources/drivers/port/port.h ****  *                  pin	- numerao do pino;
  60:../Sources/drivers/port/port.h ****  * 					irq - uma das alternativas de interrupo do pino.
  61:../Sources/drivers/port/port.h ****  *
  62:../Sources/drivers/port/port.h ****  * Sadas		:  Nenhuma.
  63:../Sources/drivers/port/port.h ****  *
  64:../Sources/drivers/port/port.h ****  * Comentrios 	:  Nenhum.
  65:../Sources/drivers/port/port.h ****  * ********************************************************************/
  66:../Sources/drivers/port/port.h **** void PORT_IRQEnable(PORT_Type *base, uint8_t pin, portIRQ_t irq);
  67:../Sources/drivers/port/port.h **** 
  68:../Sources/drivers/port/port.h **** /**********************************************************************
  69:../Sources/drivers/port/port.h ****  * Funo		:	PORT_GetIRQFlag
  70:../Sources/drivers/port/port.h ****  *
  71:../Sources/drivers/port/port.h ****  * Descrio	:   Retorna se a flag de interrupo de pino do PORT foi setada.
  72:../Sources/drivers/port/port.h ****  *
  73:../Sources/drivers/port/port.h ****  * Entradas		:   *base - registrador base do perifrico PORT.
  74:../Sources/drivers/port/port.h ****  *                  pin	- numerao do pino;
  75:../Sources/drivers/port/port.h ****  *
  76:../Sources/drivers/port/port.h ****  * Sadas		:  0 - se flag no setada;
  77:../Sources/drivers/port/port.h ****  *                 !0 - se flag setada.
  78:../Sources/drivers/port/port.h ****  *
  79:../Sources/drivers/port/port.h ****  * Comentrios 	:  Nenhum.
  80:../Sources/drivers/port/port.h ****  * ********************************************************************/
  81:../Sources/drivers/port/port.h **** uint8_t PORT_GetIRQFlag(PORT_Type *base, uint8_t pin);
  82:../Sources/drivers/port/port.h **** 
  83:../Sources/drivers/port/port.h **** /**********************************************************************
  84:../Sources/drivers/port/port.h ****  * Funo		:	PORT_ClearIRQFlag
  85:../Sources/drivers/port/port.h ****  *
  86:../Sources/drivers/port/port.h ****  * Descrio	:   Limpa flag de interrupo do pino de PORT.
  87:../Sources/drivers/port/port.h ****  *
  88:../Sources/drivers/port/port.h ****  * Entradas		:   *base - registrador base do perifrico PORT.
  89:../Sources/drivers/port/port.h ****  *                  pin	- numerao do pino;
  90:../Sources/drivers/port/port.h ****  *
  91:../Sources/drivers/port/port.h ****  * Sadas		:  Nenhuma.
  92:../Sources/drivers/port/port.h ****  *
  93:../Sources/drivers/port/port.h ****  * Comentrios 	:  Nenhum.
  94:../Sources/drivers/port/port.h ****  * ********************************************************************/
  95:../Sources/drivers/port/port.h **** void PORT_ClearIRQFlag(PORT_Type *base, uint8_t pin);
  96:../Sources/drivers/port/port.h **** 
  97:../Sources/drivers/port/port.h **** /*FIM: PROTOTIPOS - FUNES PBLICAS*/
  98:../Sources/drivers/port/port.h **** /*=======================================================================================*/
  99:../Sources/drivers/port/port.h **** 
 100:../Sources/drivers/port/port.h **** 
 101:../Sources/drivers/port/port.h **** /*PROTOTIPOS - FUNES INLINE*/
 102:../Sources/drivers/port/port.h **** /*=======================================================================================*/
 103:../Sources/drivers/port/port.h **** 
 104:../Sources/drivers/port/port.h **** static inline void PORT_Init(PORT_Type* base);
 105:../Sources/drivers/port/port.h **** static inline void PORT_SetMux(PORT_Type *base, uint8_t pin, portMux_t mux);
 106:../Sources/drivers/port/port.h **** static inline void PORT_PullEnable(PORT_Type *base, uint8_t pin);
 107:../Sources/drivers/port/port.h **** static inline void PORT_HighStrengthEnable(PORT_Type *base, uint8_t pin);
 108:../Sources/drivers/port/port.h **** 
 109:../Sources/drivers/port/port.h **** /*FIM: PROTOTIPOS - FUNES INLINE*/
 110:../Sources/drivers/port/port.h **** /*=======================================================================================*/
 111:../Sources/drivers/port/port.h **** 
 112:../Sources/drivers/port/port.h **** /*FUNES INLINE*/
 113:../Sources/drivers/port/port.h **** /*=======================================================================================*/
 114:../Sources/drivers/port/port.h **** 
 115:../Sources/drivers/port/port.h **** /**********************************************************************
 116:../Sources/drivers/port/port.h ****  * Funo		:	PORT_Init
 117:../Sources/drivers/port/port.h ****  *
 118:../Sources/drivers/port/port.h ****  * Descrio	:   Deve ser chamado antes de utilizar um mdulo PORT.
 119:../Sources/drivers/port/port.h ****  *
 120:../Sources/drivers/port/port.h ****  * Entradas		:   *base - registrador base do perifrico PORT.
 121:../Sources/drivers/port/port.h ****  *
 122:../Sources/drivers/port/port.h ****  * Sadas 		:   Nenhuma.
 123:../Sources/drivers/port/port.h ****  *
 124:../Sources/drivers/port/port.h ****  * Comentrios 	: 	Nenhum.
 125:../Sources/drivers/port/port.h ****  * ********************************************************************/
 126:../Sources/drivers/port/port.h **** static inline void PORT_Init(PORT_Type* base)
 127:../Sources/drivers/port/port.h **** {
 120              		.loc 2 127 0
 121              		.cfi_startproc
 122 0000 80B5     		push	{r7, lr}
 123              		.cfi_def_cfa_offset 8
 124              		.cfi_offset 7, -8
 125              		.cfi_offset 14, -4
 126 0002 82B0     		sub	sp, sp, #8
 127              		.cfi_def_cfa_offset 16
 128 0004 00AF     		add	r7, sp, #0
 129              		.cfi_def_cfa_register 7
 130 0006 7860     		str	r0, [r7, #4]
 128:../Sources/drivers/port/port.h **** 	assert(base);
 131              		.loc 2 128 0
 132 0008 7B68     		ldr	r3, [r7, #4]
 133 000a 002B     		cmp	r3, #0
 134 000c 06D1     		bne	.L8
 135              		.loc 2 128 0 is_stmt 0 discriminator 1
 136 000e 1949     		ldr	r1, .L11
 137 0010 194A     		ldr	r2, .L11+4
 138 0012 1A4B     		ldr	r3, .L11+8
 139 0014 081C     		mov	r0, r1
 140 0016 8021     		mov	r1, #128
 141 0018 FFF7FEFF 		bl	__assert_func
 142              	.L8:
 129:../Sources/drivers/port/port.h **** 
 130:../Sources/drivers/port/port.h **** 	if( PORTA == base )
 143              		.loc 2 130 0 is_stmt 1
 144 001c 7A68     		ldr	r2, [r7, #4]
 145 001e 184B     		ldr	r3, .L11+12
 146 0020 9A42     		cmp	r2, r3
 147 0022 09D1     		bne	.L9
 131:../Sources/drivers/port/port.h **** 	{
 132:../Sources/drivers/port/port.h **** 		   SIM_SCGC5 |= SIM_SCGC5_PORTA_MASK; /* Ativa o clock do perifrico da porta A*/
 148              		.loc 2 132 0
 149 0024 174A     		ldr	r2, .L11+16
 150 0026 1749     		ldr	r1, .L11+16
 151 0028 174B     		ldr	r3, .L11+20
 152 002a CB58     		ldr	r3, [r1, r3]
 153 002c 8021     		mov	r1, #128
 154 002e 8900     		lsl	r1, r1, #2
 155 0030 1943     		orr	r1, r3
 156 0032 154B     		ldr	r3, .L11+20
 157 0034 D150     		str	r1, [r2, r3]
 158 0036 19E0     		b	.L7
 159              	.L9:
 133:../Sources/drivers/port/port.h **** 	}
 134:../Sources/drivers/port/port.h **** 	else
 135:../Sources/drivers/port/port.h **** 	{
 136:../Sources/drivers/port/port.h **** 		if( PORTB == base )
 160              		.loc 2 136 0
 161 0038 7A68     		ldr	r2, [r7, #4]
 162 003a 144B     		ldr	r3, .L11+24
 163 003c 9A42     		cmp	r2, r3
 164 003e 15D1     		bne	.L7
 137:../Sources/drivers/port/port.h **** 		{
 138:../Sources/drivers/port/port.h **** 			SIM_SCGC5 |= SIM_SCGC5_PORTB_MASK; /* Ativa o clock do perifrico da porta B*/
 165              		.loc 2 138 0
 166 0040 104A     		ldr	r2, .L11+16
 167 0042 1049     		ldr	r1, .L11+16
 168 0044 104B     		ldr	r3, .L11+20
 169 0046 CB58     		ldr	r3, [r1, r3]
 170 0048 8021     		mov	r1, #128
 171 004a C900     		lsl	r1, r1, #3
 172 004c 1943     		orr	r1, r3
 173 004e 0E4B     		ldr	r3, .L11+20
 174 0050 D150     		str	r1, [r2, r3]
 139:../Sources/drivers/port/port.h **** 			/*Desabilita NMI em PTB5 e habilita como GPIO*/
 140:../Sources/drivers/port/port.h **** 			base->PCR[5] &= ~PORT_PCR_MUX_MASK; /*Limpa configuraes anteriores*/
 175              		.loc 2 140 0
 176 0052 7B68     		ldr	r3, [r7, #4]
 177 0054 5A69     		ldr	r2, [r3, #20]
 178 0056 0E4B     		ldr	r3, .L11+28
 179 0058 1A40     		and	r2, r3
 180 005a 7B68     		ldr	r3, [r7, #4]
 181 005c 5A61     		str	r2, [r3, #20]
 141:../Sources/drivers/port/port.h **** 			base->PCR[5] |= PORT_PCR_MUX(PORT_MUX_ALT1);
 182              		.loc 2 141 0
 183 005e 7B68     		ldr	r3, [r7, #4]
 184 0060 5B69     		ldr	r3, [r3, #20]
 185 0062 8022     		mov	r2, #128
 186 0064 5200     		lsl	r2, r2, #1
 187 0066 1A43     		orr	r2, r3
 188 0068 7B68     		ldr	r3, [r7, #4]
 189 006a 5A61     		str	r2, [r3, #20]
 190              	.L7:
 142:../Sources/drivers/port/port.h **** 		}
 143:../Sources/drivers/port/port.h **** 	}
 144:../Sources/drivers/port/port.h **** }
 191              		.loc 2 144 0
 192 006c BD46     		mov	sp, r7
 193 006e 02B0     		add	sp, sp, #8
 194              		@ sp needed
 195 0070 80BD     		pop	{r7, pc}
 196              	.L12:
 197 0072 C046     		.align	2
 198              	.L11:
 199 0074 00000000 		.word	.LC0
 200 0078 00000000 		.word	__func__.5655
 201 007c 20000000 		.word	.LC3
 202 0080 00900440 		.word	1074040832
 203 0084 00700440 		.word	1074032640
 204 0088 38100000 		.word	4152
 205 008c 00A00440 		.word	1074044928
 206 0090 FFF8FFFF 		.word	-1793
 207              		.cfi_endproc
 208              	.LFE39:
 210              		.section	.rodata
 211 0025 000000   		.align	2
 212              	.LC8:
 213 0028 28207069 		.ascii	"( pin >= 0 ) && ( pin < 32 )\000"
 213      6E203E3D 
 213      20302029 
 213      20262620 
 213      28207069 
 214              		.section	.text.PORT_PullEnable,"ax",%progbits
 215              		.align	2
 216              		.code	16
 217              		.thumb_func
 219              	PORT_PullEnable:
 220              	.LFB40:
 145:../Sources/drivers/port/port.h **** /**********************************************************************
 146:../Sources/drivers/port/port.h ****  * Funo		:	PORT_PullEnable
 147:../Sources/drivers/port/port.h ****  *
 148:../Sources/drivers/port/port.h ****  * Descrio	:   Habilita pullUp no pino do mdulo PORT.
 149:../Sources/drivers/port/port.h ****  *
 150:../Sources/drivers/port/port.h ****  * Entradas		:   *base - registrador base do perifrico PORT.
 151:../Sources/drivers/port/port.h ****  *                  pin	  - numerao do pino;
 152:../Sources/drivers/port/port.h ****  *
 153:../Sources/drivers/port/port.h ****  * Sadas		:   Nenhuma.
 154:../Sources/drivers/port/port.h ****  *
 155:../Sources/drivers/port/port.h ****  * Comentrios 	: 	Nenhum.
 156:../Sources/drivers/port/port.h ****  * ********************************************************************/
 157:../Sources/drivers/port/port.h **** static inline void PORT_PullEnable(PORT_Type *base, uint8_t pin)
 158:../Sources/drivers/port/port.h **** {
 221              		.loc 2 158 0
 222              		.cfi_startproc
 223 0000 80B5     		push	{r7, lr}
 224              		.cfi_def_cfa_offset 8
 225              		.cfi_offset 7, -8
 226              		.cfi_offset 14, -4
 227 0002 82B0     		sub	sp, sp, #8
 228              		.cfi_def_cfa_offset 16
 229 0004 00AF     		add	r7, sp, #0
 230              		.cfi_def_cfa_register 7
 231 0006 7860     		str	r0, [r7, #4]
 232 0008 0A1C     		mov	r2, r1
 233 000a FB1C     		add	r3, r7, #3
 234 000c 1A70     		strb	r2, [r3]
 159:../Sources/drivers/port/port.h **** 	assert(base);
 235              		.loc 2 159 0
 236 000e 7B68     		ldr	r3, [r7, #4]
 237 0010 002B     		cmp	r3, #0
 238 0012 06D1     		bne	.L14
 239              		.loc 2 159 0 is_stmt 0 discriminator 1
 240 0014 1049     		ldr	r1, .L16
 241 0016 114A     		ldr	r2, .L16+4
 242 0018 114B     		ldr	r3, .L16+8
 243 001a 081C     		mov	r0, r1
 244 001c 9F21     		mov	r1, #159
 245 001e FFF7FEFF 		bl	__assert_func
 246              	.L14:
 160:../Sources/drivers/port/port.h **** 	assert( ( pin >= 0 ) && ( pin < 32 ) );
 247              		.loc 2 160 0 is_stmt 1
 248 0022 FB1C     		add	r3, r7, #3
 249 0024 1B78     		ldrb	r3, [r3]
 250 0026 1F2B     		cmp	r3, #31
 251 0028 06D9     		bls	.L15
 252              		.loc 2 160 0 is_stmt 0 discriminator 1
 253 002a 0B49     		ldr	r1, .L16
 254 002c 0B4A     		ldr	r2, .L16+4
 255 002e 0D4B     		ldr	r3, .L16+12
 256 0030 081C     		mov	r0, r1
 257 0032 A021     		mov	r1, #160
 258 0034 FFF7FEFF 		bl	__assert_func
 259              	.L15:
 161:../Sources/drivers/port/port.h **** 
 162:../Sources/drivers/port/port.h **** 	base->PCR[pin] |= PORT_PCR_PE_MASK;
 260              		.loc 2 162 0 is_stmt 1
 261 0038 FB1C     		add	r3, r7, #3
 262 003a 1A78     		ldrb	r2, [r3]
 263 003c FB1C     		add	r3, r7, #3
 264 003e 1978     		ldrb	r1, [r3]
 265 0040 7B68     		ldr	r3, [r7, #4]
 266 0042 8900     		lsl	r1, r1, #2
 267 0044 CB58     		ldr	r3, [r1, r3]
 268 0046 0221     		mov	r1, #2
 269 0048 1943     		orr	r1, r3
 270 004a 7B68     		ldr	r3, [r7, #4]
 271 004c 9200     		lsl	r2, r2, #2
 272 004e D150     		str	r1, [r2, r3]
 163:../Sources/drivers/port/port.h **** }
 273              		.loc 2 163 0
 274 0050 BD46     		mov	sp, r7
 275 0052 02B0     		add	sp, sp, #8
 276              		@ sp needed
 277 0054 80BD     		pop	{r7, pc}
 278              	.L17:
 279 0056 C046     		.align	2
 280              	.L16:
 281 0058 00000000 		.word	.LC0
 282 005c 00000000 		.word	__func__.5660
 283 0060 20000000 		.word	.LC3
 284 0064 28000000 		.word	.LC8
 285              		.cfi_endproc
 286              	.LFE40:
 288              		.section	.text.PORT_SetMux,"ax",%progbits
 289              		.align	2
 290              		.code	16
 291              		.thumb_func
 293              	PORT_SetMux:
 294              	.LFB42:
 164:../Sources/drivers/port/port.h **** 
 165:../Sources/drivers/port/port.h **** /**********************************************************************
 166:../Sources/drivers/port/port.h ****  * Funo		:	PORT_HighStrengthEnable
 167:../Sources/drivers/port/port.h ****  *
 168:../Sources/drivers/port/port.h ****  * Descrio	:   Habilita a intensidade da corrente do pino como alta.
 169:../Sources/drivers/port/port.h ****  *
 170:../Sources/drivers/port/port.h ****  * Entradas		:   *base - registrador base do perifrico PORT.
 171:../Sources/drivers/port/port.h ****  *                  pin	  - numerao do pino;
 172:../Sources/drivers/port/port.h ****  *
 173:../Sources/drivers/port/port.h ****  * Sadas		:   Nenhuma.
 174:../Sources/drivers/port/port.h ****  *
 175:../Sources/drivers/port/port.h ****  * Comentrios 	: 	Nenhum.
 176:../Sources/drivers/port/port.h ****  * ********************************************************************/
 177:../Sources/drivers/port/port.h **** static inline void PORT_HighStrengthEnable(PORT_Type *base, uint8_t pin)
 178:../Sources/drivers/port/port.h **** {
 179:../Sources/drivers/port/port.h **** 	assert(base);
 180:../Sources/drivers/port/port.h **** 	assert( ( pin >= 0 ) && ( pin < 32 ) );
 181:../Sources/drivers/port/port.h **** 
 182:../Sources/drivers/port/port.h **** 	base->PCR[pin] |= PORT_PCR_DSE_MASK;
 183:../Sources/drivers/port/port.h **** }
 184:../Sources/drivers/port/port.h **** 
 185:../Sources/drivers/port/port.h **** /**********************************************************************
 186:../Sources/drivers/port/port.h ****  * Funo		:	PORTB_SetMux
 187:../Sources/drivers/port/port.h ****  *
 188:../Sources/drivers/port/port.h ****  * Descrio	:   Configura a multiplexao no pino do mdulo PORTB.
 189:../Sources/drivers/port/port.h ****  *
 190:../Sources/drivers/port/port.h ****  * Entradas		:   *base - registrador base do perifrico PORT.
 191:../Sources/drivers/port/port.h ****  *                  pin	- numerao do pino;
 192:../Sources/drivers/port/port.h ****  * 					mux - uma das alternativas de multiplexao do pino.
 193:../Sources/drivers/port/port.h ****  *
 194:../Sources/drivers/port/port.h ****  * Sadas		:   Nenhuma.
 195:../Sources/drivers/port/port.h ****  *
 196:../Sources/drivers/port/port.h ****  * Comentrios 	: 	Nenhum.
 197:../Sources/drivers/port/port.h ****  * ********************************************************************/
 198:../Sources/drivers/port/port.h **** static inline void PORT_SetMux(PORT_Type *base, uint8_t pin, portMux_t mux)
 199:../Sources/drivers/port/port.h **** {
 295              		.loc 2 199 0
 296              		.cfi_startproc
 297 0000 80B5     		push	{r7, lr}
 298              		.cfi_def_cfa_offset 8
 299              		.cfi_offset 7, -8
 300              		.cfi_offset 14, -4
 301 0002 82B0     		sub	sp, sp, #8
 302              		.cfi_def_cfa_offset 16
 303 0004 00AF     		add	r7, sp, #0
 304              		.cfi_def_cfa_register 7
 305 0006 7860     		str	r0, [r7, #4]
 306 0008 FB1C     		add	r3, r7, #3
 307 000a 1970     		strb	r1, [r3]
 308 000c BB1C     		add	r3, r7, #2
 309 000e 1A70     		strb	r2, [r3]
 200:../Sources/drivers/port/port.h **** 	assert(base);
 310              		.loc 2 200 0
 311 0010 7B68     		ldr	r3, [r7, #4]
 312 0012 002B     		cmp	r3, #0
 313 0014 06D1     		bne	.L19
 314              		.loc 2 200 0 is_stmt 0 discriminator 1
 315 0016 1949     		ldr	r1, .L21
 316 0018 194A     		ldr	r2, .L21+4
 317 001a 1A4B     		ldr	r3, .L21+8
 318 001c 081C     		mov	r0, r1
 319 001e C821     		mov	r1, #200
 320 0020 FFF7FEFF 		bl	__assert_func
 321              	.L19:
 201:../Sources/drivers/port/port.h **** 	assert( ( pin >= 0 ) && ( pin < 32 ) );
 322              		.loc 2 201 0 is_stmt 1
 323 0024 FB1C     		add	r3, r7, #3
 324 0026 1B78     		ldrb	r3, [r3]
 325 0028 1F2B     		cmp	r3, #31
 326 002a 06D9     		bls	.L20
 327              		.loc 2 201 0 is_stmt 0 discriminator 1
 328 002c 1349     		ldr	r1, .L21
 329 002e 144A     		ldr	r2, .L21+4
 330 0030 154B     		ldr	r3, .L21+12
 331 0032 081C     		mov	r0, r1
 332 0034 C921     		mov	r1, #201
 333 0036 FFF7FEFF 		bl	__assert_func
 334              	.L20:
 202:../Sources/drivers/port/port.h **** 
 203:../Sources/drivers/port/port.h **** 	base->PCR[pin] &= ~PORT_PCR_MUX_MASK; /*Limpa configuraes anteriores*/
 335              		.loc 2 203 0 is_stmt 1
 336 003a FB1C     		add	r3, r7, #3
 337 003c 1A78     		ldrb	r2, [r3]
 338 003e FB1C     		add	r3, r7, #3
 339 0040 1978     		ldrb	r1, [r3]
 340 0042 7B68     		ldr	r3, [r7, #4]
 341 0044 8900     		lsl	r1, r1, #2
 342 0046 C958     		ldr	r1, [r1, r3]
 343 0048 104B     		ldr	r3, .L21+16
 344 004a 1940     		and	r1, r3
 345 004c 7B68     		ldr	r3, [r7, #4]
 346 004e 9200     		lsl	r2, r2, #2
 347 0050 D150     		str	r1, [r2, r3]
 204:../Sources/drivers/port/port.h **** 	base->PCR[pin] |= PORT_PCR_MUX(mux);
 348              		.loc 2 204 0
 349 0052 FB1C     		add	r3, r7, #3
 350 0054 1A78     		ldrb	r2, [r3]
 351 0056 FB1C     		add	r3, r7, #3
 352 0058 1978     		ldrb	r1, [r3]
 353 005a 7B68     		ldr	r3, [r7, #4]
 354 005c 8900     		lsl	r1, r1, #2
 355 005e C958     		ldr	r1, [r1, r3]
 356 0060 BB1C     		add	r3, r7, #2
 357 0062 1B78     		ldrb	r3, [r3]
 358 0064 1802     		lsl	r0, r3, #8
 359 0066 E023     		mov	r3, #224
 360 0068 DB00     		lsl	r3, r3, #3
 361 006a 0340     		and	r3, r0
 362 006c 1943     		orr	r1, r3
 363 006e 7B68     		ldr	r3, [r7, #4]
 364 0070 9200     		lsl	r2, r2, #2
 365 0072 D150     		str	r1, [r2, r3]
 205:../Sources/drivers/port/port.h **** }
 366              		.loc 2 205 0
 367 0074 BD46     		mov	sp, r7
 368 0076 02B0     		add	sp, sp, #8
 369              		@ sp needed
 370 0078 80BD     		pop	{r7, pc}
 371              	.L22:
 372 007a C046     		.align	2
 373              	.L21:
 374 007c 00000000 		.word	.LC0
 375 0080 00000000 		.word	__func__.5671
 376 0084 20000000 		.word	.LC3
 377 0088 28000000 		.word	.LC8
 378 008c FFF8FFFF 		.word	-1793
 379              		.cfi_endproc
 380              	.LFE42:
 382              		.section	.rodata
 383 0045 000000   		.align	2
 384              	.LC14:
 385 0048 2E2E2F53 		.ascii	"../Sources/drivers/tpm/tpm.h\000"
 385      6F757263 
 385      65732F64 
 385      72697665 
 385      72732F74 
 386              		.section	.text.TPM_InitCounter,"ax",%progbits
 387              		.align	2
 388              		.code	16
 389              		.thumb_func
 391              	TPM_InitCounter:
 392              	.LFB50:
 393              		.file 3 "../Sources/drivers/tpm/tpm.h"
   1:../Sources/drivers/tpm/tpm.h **** /***************************************************************************************
   2:../Sources/drivers/tpm/tpm.h ****  * Mdulo      : tpm.h
   3:../Sources/drivers/tpm/tpm.h ****  *
   4:../Sources/drivers/tpm/tpm.h ****  * Reviso     : 1.0
   5:../Sources/drivers/tpm/tpm.h ****  *
   6:../Sources/drivers/tpm/tpm.h ****  * Data        : 16/02/2022
   7:../Sources/drivers/tpm/tpm.h ****  *
   8:../Sources/drivers/tpm/tpm.h ****  * Descrio   : Arquivo com implementaes dos Mdulos Timer/PWM (TPM) da Familia Kinetis KL05.
   9:../Sources/drivers/tpm/tpm.h ****  *
  10:../Sources/drivers/tpm/tpm.h ****  * Comentrios : Nenhum.
  11:../Sources/drivers/tpm/tpm.h ****  *
  12:../Sources/drivers/tpm/tpm.h ****  * Autor(es)   : Matheus Leitzke Pinto
  13:../Sources/drivers/tpm/tpm.h ****  ***************************************************************************************/
  14:../Sources/drivers/tpm/tpm.h **** 
  15:../Sources/drivers/tpm/tpm.h **** #ifndef TPM_DRV_H_
  16:../Sources/drivers/tpm/tpm.h **** #define TPM_DRV_H_
  17:../Sources/drivers/tpm/tpm.h **** 
  18:../Sources/drivers/tpm/tpm.h **** /*ARQUIVOS DE CABEALHO*/
  19:../Sources/drivers/tpm/tpm.h **** /*=======================================================================================*/
  20:../Sources/drivers/tpm/tpm.h **** 
  21:../Sources/drivers/tpm/tpm.h **** #include "drivers/common_driver.h"
  22:../Sources/drivers/tpm/tpm.h **** 
  23:../Sources/drivers/tpm/tpm.h **** /*FIM: ARQUIVOS DE CABEALHO*/
  24:../Sources/drivers/tpm/tpm.h **** /*=======================================================================================*/
  25:../Sources/drivers/tpm/tpm.h **** 
  26:../Sources/drivers/tpm/tpm.h **** /*TIPOS ENUMERADOS*/
  27:../Sources/drivers/tpm/tpm.h **** /*=======================================================================================*/
  28:../Sources/drivers/tpm/tpm.h **** 
  29:../Sources/drivers/tpm/tpm.h **** /*Possveis modos de operao dos mdulos TPM*/
  30:../Sources/drivers/tpm/tpm.h **** typedef enum{
  31:../Sources/drivers/tpm/tpm.h **** 	TPM_OUT_COMPARE_MODE, 		/* Modo comparador de sada*/
  32:../Sources/drivers/tpm/tpm.h **** 	TPM_IN_COMPARE_MODE	,		/* Modo captura de entrada*/
  33:../Sources/drivers/tpm/tpm.h **** 	TPM_EDGE_PWM_MODE	,		/* Modo PWM alinhado a borda*/
  34:../Sources/drivers/tpm/tpm.h **** 	TPM_CENTER_PWM_MODE			/* Modo PWM alinhado ao centro */
  35:../Sources/drivers/tpm/tpm.h **** }tpmChMode_t;
  36:../Sources/drivers/tpm/tpm.h **** 
  37:../Sources/drivers/tpm/tpm.h **** /*Possveis configuraes do modos de operao dos mdulos TPM*/
  38:../Sources/drivers/tpm/tpm.h **** typedef enum{
  39:../Sources/drivers/tpm/tpm.h **** 	TPM_OUT_TOGGLE_GONFIG		, 	/*Modo comparao de sada: inverte lgica de sada*/
  40:../Sources/drivers/tpm/tpm.h **** 	TPM_OUT_CLEAR_GONFIG		,  	/*Modo comparao de sada: limpa sada*/
  41:../Sources/drivers/tpm/tpm.h **** 	TPM_OUT_SET_GONFIG			,  	/*Modo comparao de sada: seta sada*/
  42:../Sources/drivers/tpm/tpm.h **** 	TPM_IN_RISING_EDGE_CONFIG	, 	/*Modo captura de entrada: borda de subida*/
  43:../Sources/drivers/tpm/tpm.h **** 	TPM_IN_FALLING_EDGE_CONFIG	, 	/*Modo captura de entrada: borda de descida*/
  44:../Sources/drivers/tpm/tpm.h **** 	TPM_IN_BOTH_EDGE_CONFIG		, 	/*Modo captura de entrada: borda de subida/descida*/
  45:../Sources/drivers/tpm/tpm.h **** 	TPM_PWM_HIGH_TRUE_CONFIG	,	/*Modos PWM: Pulso  o nvel*/
  46:../Sources/drivers/tpm/tpm.h **** 	TPM_PWM_HIGH_LOW_CONFIG		,	/*Modos PWM: Pulso  o baixo*/
  47:../Sources/drivers/tpm/tpm.h **** }tpmChConfig_t;
  48:../Sources/drivers/tpm/tpm.h **** 
  49:../Sources/drivers/tpm/tpm.h **** /*Possveis valores de divises do prescaler dos mdulos TPM*/
  50:../Sources/drivers/tpm/tpm.h **** typedef enum{
  51:../Sources/drivers/tpm/tpm.h **** 	TPM_PRESCALER_DIV_1		=	0x0, 	/*Prescaler do mdulo TPM divide por 0*/
  52:../Sources/drivers/tpm/tpm.h **** 	TPM_PRESCALER_DIV_2		=	0x1,  	/*Prescaler do mdulo TPM divide por 1*/
  53:../Sources/drivers/tpm/tpm.h **** 	TPM_PRESCALER_DIV_4		=	0x2,  	/*Prescaler do mdulo TPM divide por 2*/
  54:../Sources/drivers/tpm/tpm.h **** 	TPM_PRESCALER_DIV_8		=	0x3,  	/*Prescaler do mdulo TPM divide por 3*/
  55:../Sources/drivers/tpm/tpm.h **** 	TPM_PRESCALER_DIV_16	=	0x4,  	/*Prescaler do mdulo TPM divide por 4*/
  56:../Sources/drivers/tpm/tpm.h **** 	TPM_PRESCALER_DIV_32	=	0x5,  	/*Prescaler do mdulo TPM divide por 5*/
  57:../Sources/drivers/tpm/tpm.h **** 	TPM_PRESCALER_DIV_64	=	0x6,  	/*Prescaler do mdulo TPM divide por 6*/
  58:../Sources/drivers/tpm/tpm.h **** 	TPM_PRESCALER_DIV_128	=	0x7,  	/*Prescaler do mdulo TPM divide por 7*/
  59:../Sources/drivers/tpm/tpm.h **** }tpmPrescalerValues_t;
  60:../Sources/drivers/tpm/tpm.h **** 
  61:../Sources/drivers/tpm/tpm.h **** /*Possveis fontes de clock*/
  62:../Sources/drivers/tpm/tpm.h **** typedef enum{
  63:../Sources/drivers/tpm/tpm.h **** 	TPM_CNT_CLOCK_DISABLE = 0U,
  64:../Sources/drivers/tpm/tpm.h **** 	TPM_CNT_CLOCK_FLL = 1U,
  65:../Sources/drivers/tpm/tpm.h **** 	TPM_CNT_CLOCK_OSC = 2U,
  66:../Sources/drivers/tpm/tpm.h **** 	TPM_CNT_CLOCK_IRC = 3U
  67:../Sources/drivers/tpm/tpm.h **** }tpmClkSrc_t;
  68:../Sources/drivers/tpm/tpm.h **** 
  69:../Sources/drivers/tpm/tpm.h **** /*FIM: TIPOS ENUMERADOS*/
  70:../Sources/drivers/tpm/tpm.h **** /*=======================================================================================*/
  71:../Sources/drivers/tpm/tpm.h **** 
  72:../Sources/drivers/tpm/tpm.h **** /*PROTTIPOS - FUNES INLINE*/
  73:../Sources/drivers/tpm/tpm.h **** /*=======================================================================================*/
  74:../Sources/drivers/tpm/tpm.h **** 
  75:../Sources/drivers/tpm/tpm.h **** static inline void TPM_InitCounter(TPM_Type *base);
  76:../Sources/drivers/tpm/tpm.h **** static inline uint16_t TPM_GetChValue(TPM_Type *base, uint8_t channel);
  77:../Sources/drivers/tpm/tpm.h **** static inline void TPM_SetChMatch(TPM_Type *base, uint8_t channel, uint16_t match);
  78:../Sources/drivers/tpm/tpm.h **** static inline void TPM_EnableIRQ(TPM_Type *base);
  79:../Sources/drivers/tpm/tpm.h **** static inline uint8_t TPM_GetIRQFlag(TPM_Type *base);
  80:../Sources/drivers/tpm/tpm.h **** static inline void TPM_ClearIRQFlag(TPM_Type *base);
  81:../Sources/drivers/tpm/tpm.h **** static inline void TPM_SetModulo(TPM_Type *base, uint16_t modulo);
  82:../Sources/drivers/tpm/tpm.h **** 
  83:../Sources/drivers/tpm/tpm.h **** /*FIM: PROTTIPOS - FUNES INLINE*/
  84:../Sources/drivers/tpm/tpm.h **** /*=======================================================================================*/
  85:../Sources/drivers/tpm/tpm.h **** 
  86:../Sources/drivers/tpm/tpm.h **** /*PROTTIPOS - FUNES PBLICAS*/
  87:../Sources/drivers/tpm/tpm.h **** /*=======================================================================================*/
  88:../Sources/drivers/tpm/tpm.h **** 
  89:../Sources/drivers/tpm/tpm.h **** /**********************************************************************
  90:../Sources/drivers/tpm/tpm.h ****  * Funo		:	TPM_SetCounterClkSrc
  91:../Sources/drivers/tpm/tpm.h ****  *
  92:../Sources/drivers/tpm/tpm.h ****  * Descrio	:   Define a fonte de clock utilizada pelo contador.
  93:../Sources/drivers/tpm/tpm.h ****  *
  94:../Sources/drivers/tpm/tpm.h ****  * Entradas		:   *base - registrador base do perifrico TPM;
  95:../Sources/drivers/tpm/tpm.h ****  *                  src   - tipo enumerado que define a fonte de clock.
  96:../Sources/drivers/tpm/tpm.h ****  *
  97:../Sources/drivers/tpm/tpm.h ****  * Sadas 		:   STATUS_SUCCESS, se configurao ocorreu corretamente;
  98:../Sources/drivers/tpm/tpm.h ****  *                  STATUS_FAIL, caso contrrio.
  99:../Sources/drivers/tpm/tpm.h ****  *
 100:../Sources/drivers/tpm/tpm.h ****  * Comentrios 	: 	Pode ser chamada aps a inicializao (TPM_Init).
 101:../Sources/drivers/tpm/tpm.h ****  *                  Porm, contador vai iniciar contagem apenas quando
 102:../Sources/drivers/tpm/tpm.h ****  *                  essa funo for chamada.
 103:../Sources/drivers/tpm/tpm.h ****  * ********************************************************************/
 104:../Sources/drivers/tpm/tpm.h **** uint8_t TPM_SetCounterClkSrc(TPM_Type *base, tpmClkSrc_t src);
 105:../Sources/drivers/tpm/tpm.h **** 
 106:../Sources/drivers/tpm/tpm.h **** /**********************************************************************
 107:../Sources/drivers/tpm/tpm.h ****  * Funo		:	TPM_Init
 108:../Sources/drivers/tpm/tpm.h ****  *
 109:../Sources/drivers/tpm/tpm.h ****  * Descrio	:   Inicializao do driver do mdulo TPM.
 110:../Sources/drivers/tpm/tpm.h ****  *
 111:../Sources/drivers/tpm/tpm.h ****  * Entradas		:   *base    - registrador base do perifrico TPM;
 112:../Sources/drivers/tpm/tpm.h ****  *                  modulo   - valor de final de contagem;
 113:../Sources/drivers/tpm/tpm.h ****  *                  prescale - tipo enumerado com um dos possveis
 114:../Sources/drivers/tpm/tpm.h ****  *                             valores de prescaler.
 115:../Sources/drivers/tpm/tpm.h ****  *
 116:../Sources/drivers/tpm/tpm.h ****  * Sadas 		:   Nenhuma.
 117:../Sources/drivers/tpm/tpm.h ****  *
 118:../Sources/drivers/tpm/tpm.h ****  * Comentrios 	: 	Nenhum.
 119:../Sources/drivers/tpm/tpm.h ****  * ********************************************************************/
 120:../Sources/drivers/tpm/tpm.h **** void TPM_Init(TPM_Type *base, uint16_t modulo, tpmPrescalerValues_t prescale);
 121:../Sources/drivers/tpm/tpm.h **** 
 122:../Sources/drivers/tpm/tpm.h **** /**********************************************************************
 123:../Sources/drivers/tpm/tpm.h ****  * Funo		:	TPM_InitChannel
 124:../Sources/drivers/tpm/tpm.h ****  *
 125:../Sources/drivers/tpm/tpm.h ****  * Descrio	:   Inicializa um canal do mdulo TPM.
 126:../Sources/drivers/tpm/tpm.h ****  *
 127:../Sources/drivers/tpm/tpm.h ****  * Entradas		:   *base  - registrador base do perifrico TPM;
 128:../Sources/drivers/tpm/tpm.h ****  *                  chNum  - numro do canal;
 129:../Sources/drivers/tpm/tpm.h ****  *                  mode   - modo de operao do canal, sendo
 130:../Sources/drivers/tpm/tpm.h ****  * 							 definidos pelo tipo TPM_chMode_t.
 131:../Sources/drivers/tpm/tpm.h ****  * 					config - possveisconfiguraes de cada modo de
 132:../Sources/drivers/tpm/tpm.h ****  * 							 operao do canal, sendo definidos pelo
 133:../Sources/drivers/tpm/tpm.h ****  * 							 tipo TPM_chConfig_t.
 134:../Sources/drivers/tpm/tpm.h ****  *
 135:../Sources/drivers/tpm/tpm.h ****  * Sadas		:   Nenhuma.
 136:../Sources/drivers/tpm/tpm.h ****  *
 137:../Sources/drivers/tpm/tpm.h ****  * Comentrios 	: 	Nenhum.
 138:../Sources/drivers/tpm/tpm.h ****  * ********************************************************************/
 139:../Sources/drivers/tpm/tpm.h **** void TPM_InitChannel(TPM_Type *base, uint8_t chNum, tpmChMode_t mode, tpmChConfig_t config);
 140:../Sources/drivers/tpm/tpm.h **** 
 141:../Sources/drivers/tpm/tpm.h **** 
 142:../Sources/drivers/tpm/tpm.h **** /*FIM: PROTTIPOS - FUNES PBLICAS*/
 143:../Sources/drivers/tpm/tpm.h **** /*=======================================================================================*/
 144:../Sources/drivers/tpm/tpm.h **** 
 145:../Sources/drivers/tpm/tpm.h **** /*FUNES INLINE*/
 146:../Sources/drivers/tpm/tpm.h **** /*=======================================================================================*/
 147:../Sources/drivers/tpm/tpm.h **** 
 148:../Sources/drivers/tpm/tpm.h **** /**********************************************************************
 149:../Sources/drivers/tpm/tpm.h ****  * Funo		:	TPM_InitCounter
 150:../Sources/drivers/tpm/tpm.h ****  *
 151:../Sources/drivers/tpm/tpm.h ****  * Descrio	:   Inicializa registrador contador do mdulo TPM0.
 152:../Sources/drivers/tpm/tpm.h ****  *
 153:../Sources/drivers/tpm/tpm.h ****  * Entradas		:   *base - registrador base do perifrico TPM.
 154:../Sources/drivers/tpm/tpm.h ****  *
 155:../Sources/drivers/tpm/tpm.h ****  * Sadas		:   Nenhuma.
 156:../Sources/drivers/tpm/tpm.h ****  *
 157:../Sources/drivers/tpm/tpm.h ****  * Comentrios 	: 	Nenhum.
 158:../Sources/drivers/tpm/tpm.h ****  * ********************************************************************/
 159:../Sources/drivers/tpm/tpm.h **** static inline void TPM_InitCounter(TPM_Type *base)
 160:../Sources/drivers/tpm/tpm.h **** {
 394              		.loc 3 160 0
 395              		.cfi_startproc
 396 0000 80B5     		push	{r7, lr}
 397              		.cfi_def_cfa_offset 8
 398              		.cfi_offset 7, -8
 399              		.cfi_offset 14, -4
 400 0002 82B0     		sub	sp, sp, #8
 401              		.cfi_def_cfa_offset 16
 402 0004 00AF     		add	r7, sp, #0
 403              		.cfi_def_cfa_register 7
 404 0006 7860     		str	r0, [r7, #4]
 161:../Sources/drivers/tpm/tpm.h **** 	assert(base);
 405              		.loc 3 161 0
 406 0008 7B68     		ldr	r3, [r7, #4]
 407 000a 002B     		cmp	r3, #0
 408 000c 06D1     		bne	.L24
 409              		.loc 3 161 0 is_stmt 0 discriminator 1
 410 000e 0849     		ldr	r1, .L25
 411 0010 084A     		ldr	r2, .L25+4
 412 0012 094B     		ldr	r3, .L25+8
 413 0014 081C     		mov	r0, r1
 414 0016 A121     		mov	r1, #161
 415 0018 FFF7FEFF 		bl	__assert_func
 416              	.L24:
 162:../Sources/drivers/tpm/tpm.h **** 	base->SC |= (TPM_SC_CMOD(0x1U));
 417              		.loc 3 162 0 is_stmt 1
 418 001c 7B68     		ldr	r3, [r7, #4]
 419 001e 1B68     		ldr	r3, [r3]
 420 0020 0822     		mov	r2, #8
 421 0022 1A43     		orr	r2, r3
 422 0024 7B68     		ldr	r3, [r7, #4]
 423 0026 1A60     		str	r2, [r3]
 163:../Sources/drivers/tpm/tpm.h **** }
 424              		.loc 3 163 0
 425 0028 BD46     		mov	sp, r7
 426 002a 02B0     		add	sp, sp, #8
 427              		@ sp needed
 428 002c 80BD     		pop	{r7, pc}
 429              	.L26:
 430 002e C046     		.align	2
 431              	.L25:
 432 0030 48000000 		.word	.LC14
 433 0034 00000000 		.word	__func__.5802
 434 0038 20000000 		.word	.LC3
 435              		.cfi_endproc
 436              	.LFE50:
 438              		.section	.text.TPM_SetChMatch,"ax",%progbits
 439              		.align	2
 440              		.code	16
 441              		.thumb_func
 443              	TPM_SetChMatch:
 444              	.LFB52:
 164:../Sources/drivers/tpm/tpm.h **** 
 165:../Sources/drivers/tpm/tpm.h **** /**********************************************************************
 166:../Sources/drivers/tpm/tpm.h ****  * Funo		:	TPM_GetChValue
 167:../Sources/drivers/tpm/tpm.h ****  *
 168:../Sources/drivers/tpm/tpm.h ****  * Descrio	:   Retorna o valor do registrador contador no modo "Captura
 169:../Sources/drivers/tpm/tpm.h ****  * 					de Entrada" ou o valor de "match" no modo "Comparao de Sada"
 170:../Sources/drivers/tpm/tpm.h ****  * 					do canal 0 mdulo TPM.
 171:../Sources/drivers/tpm/tpm.h ****  *
 172:../Sources/drivers/tpm/tpm.h ****  * Entradas		:   *base - registrador base do perifrico TPM;
 173:../Sources/drivers/tpm/tpm.h ****  *                  channel - valor do canal do TPM.
 174:../Sources/drivers/tpm/tpm.h ****  *
 175:../Sources/drivers/tpm/tpm.h ****  * Sadas		:   modulo: valor de 1  65535.
 176:../Sources/drivers/tpm/tpm.h ****  *
 177:../Sources/drivers/tpm/tpm.h ****  * Comentrios 	: 	Nenhum.
 178:../Sources/drivers/tpm/tpm.h ****  * ********************************************************************/
 179:../Sources/drivers/tpm/tpm.h **** static inline uint16_t TPM_GetChValue(TPM_Type *base, uint8_t channel)
 180:../Sources/drivers/tpm/tpm.h **** {
 181:../Sources/drivers/tpm/tpm.h **** 	assert(base);
 182:../Sources/drivers/tpm/tpm.h **** 
 183:../Sources/drivers/tpm/tpm.h **** 	return (uint16_t)base->CONTROLS[channel].CnV;
 184:../Sources/drivers/tpm/tpm.h **** }
 185:../Sources/drivers/tpm/tpm.h **** 
 186:../Sources/drivers/tpm/tpm.h **** 
 187:../Sources/drivers/tpm/tpm.h **** /**********************************************************************
 188:../Sources/drivers/tpm/tpm.h ****  * Funo		:	TPM_SetChMatch
 189:../Sources/drivers/tpm/tpm.h ****  *
 190:../Sources/drivers/tpm/tpm.h ****  * Descrio	:    Define valor de "match" em canal do mdulo TPM0.
 191:../Sources/drivers/tpm/tpm.h ****  *
 192:../Sources/drivers/tpm/tpm.h ****  * Entradas		:   *base - registrador base do perifrico TPM;
 193:../Sources/drivers/tpm/tpm.h ****  *                  channel - valor do canal do TPM;
 194:../Sources/drivers/tpm/tpm.h ****  *                  match: valor de 2  65535.
 195:../Sources/drivers/tpm/tpm.h ****  *
 196:../Sources/drivers/tpm/tpm.h ****  * Sadas		:   Nenhuma.
 197:../Sources/drivers/tpm/tpm.h ****  *
 198:../Sources/drivers/tpm/tpm.h ****  * Comentrios 	: 	Nenhum.
 199:../Sources/drivers/tpm/tpm.h ****  * ********************************************************************/
 200:../Sources/drivers/tpm/tpm.h **** static inline void TPM_SetChMatch(TPM_Type *base, uint8_t channel, uint16_t match)
 201:../Sources/drivers/tpm/tpm.h **** {
 445              		.loc 3 201 0
 446              		.cfi_startproc
 447 0000 80B5     		push	{r7, lr}
 448              		.cfi_def_cfa_offset 8
 449              		.cfi_offset 7, -8
 450              		.cfi_offset 14, -4
 451 0002 82B0     		sub	sp, sp, #8
 452              		.cfi_def_cfa_offset 16
 453 0004 00AF     		add	r7, sp, #0
 454              		.cfi_def_cfa_register 7
 455 0006 7860     		str	r0, [r7, #4]
 456 0008 FB1C     		add	r3, r7, #3
 457 000a 1970     		strb	r1, [r3]
 458 000c 3B1C     		mov	r3, r7
 459 000e 1A80     		strh	r2, [r3]
 202:../Sources/drivers/tpm/tpm.h **** 	assert(base);
 460              		.loc 3 202 0
 461 0010 7B68     		ldr	r3, [r7, #4]
 462 0012 002B     		cmp	r3, #0
 463 0014 06D1     		bne	.L28
 464              		.loc 3 202 0 is_stmt 0 discriminator 1
 465 0016 0949     		ldr	r1, .L29
 466 0018 094A     		ldr	r2, .L29+4
 467 001a 0A4B     		ldr	r3, .L29+8
 468 001c 081C     		mov	r0, r1
 469 001e CA21     		mov	r1, #202
 470 0020 FFF7FEFF 		bl	__assert_func
 471              	.L28:
 203:../Sources/drivers/tpm/tpm.h **** 
 204:../Sources/drivers/tpm/tpm.h **** 	base->CONTROLS[channel].CnV = match;
 472              		.loc 3 204 0 is_stmt 1
 473 0024 FB1C     		add	r3, r7, #3
 474 0026 1B78     		ldrb	r3, [r3]
 475 0028 3A1C     		mov	r2, r7
 476 002a 1288     		ldrh	r2, [r2]
 477 002c 7968     		ldr	r1, [r7, #4]
 478 002e 0133     		add	r3, r3, #1
 479 0030 DB00     		lsl	r3, r3, #3
 480 0032 CB18     		add	r3, r1, r3
 481 0034 9A60     		str	r2, [r3, #8]
 205:../Sources/drivers/tpm/tpm.h **** }
 482              		.loc 3 205 0
 483 0036 BD46     		mov	sp, r7
 484 0038 02B0     		add	sp, sp, #8
 485              		@ sp needed
 486 003a 80BD     		pop	{r7, pc}
 487              	.L30:
 488              		.align	2
 489              	.L29:
 490 003c 48000000 		.word	.LC14
 491 0040 00000000 		.word	__func__.5813
 492 0044 20000000 		.word	.LC3
 493              		.cfi_endproc
 494              	.LFE52:
 496              		.section	.text.TPM_SetModulo,"ax",%progbits
 497              		.align	2
 498              		.code	16
 499              		.thumb_func
 501              	TPM_SetModulo:
 502              	.LFB56:
 206:../Sources/drivers/tpm/tpm.h **** 
 207:../Sources/drivers/tpm/tpm.h **** /**********************************************************************
 208:../Sources/drivers/tpm/tpm.h ****  * Funo		:	TPM_EnableIRQ
 209:../Sources/drivers/tpm/tpm.h ****  *
 210:../Sources/drivers/tpm/tpm.h ****  * Descrio	:   Habilita a gerao de interrupo pelo mdulo TPM.
 211:../Sources/drivers/tpm/tpm.h ****  *
 212:../Sources/drivers/tpm/tpm.h ****  * Entradas		:   *base - registrador base do perifrico TPM.
 213:../Sources/drivers/tpm/tpm.h ****  *
 214:../Sources/drivers/tpm/tpm.h ****  * Sadas		:   Nenhuma.
 215:../Sources/drivers/tpm/tpm.h ****  *
 216:../Sources/drivers/tpm/tpm.h ****  * Comentrios 	: 	Nenhum.
 217:../Sources/drivers/tpm/tpm.h ****  * ********************************************************************/
 218:../Sources/drivers/tpm/tpm.h **** static inline void TPM_EnableIRQ(TPM_Type *base)
 219:../Sources/drivers/tpm/tpm.h **** {
 220:../Sources/drivers/tpm/tpm.h ****    base->SC |= TPM_SC_TOIE_MASK;
 221:../Sources/drivers/tpm/tpm.h **** }
 222:../Sources/drivers/tpm/tpm.h **** 
 223:../Sources/drivers/tpm/tpm.h **** /**********************************************************************
 224:../Sources/drivers/tpm/tpm.h ****  * Funo		:	TPM_GetIRQFlag
 225:../Sources/drivers/tpm/tpm.h ****  *
 226:../Sources/drivers/tpm/tpm.h ****  * Descrio	:   Retorna o valor da flag de interrupo gerada
 227:../Sources/drivers/tpm/tpm.h ****  * 					pelo mdulo TPM.
 228:../Sources/drivers/tpm/tpm.h ****  *
 229:../Sources/drivers/tpm/tpm.h ****  * Entradas		:   *base - registrador base do perifrico TPM.
 230:../Sources/drivers/tpm/tpm.h ****  *
 231:../Sources/drivers/tpm/tpm.h ****  * Sadas		:   0	,  se no houve interrupo;
 232:../Sources/drivers/tpm/tpm.h ****  * 					!0	,  se houve interrupo.
 233:../Sources/drivers/tpm/tpm.h ****  *
 234:../Sources/drivers/tpm/tpm.h ****  * Comentrios 	: 	Nenhum.
 235:../Sources/drivers/tpm/tpm.h ****  * ********************************************************************/
 236:../Sources/drivers/tpm/tpm.h **** static inline uint8_t TPM_GetIRQFlag(TPM_Type *base)
 237:../Sources/drivers/tpm/tpm.h **** {
 238:../Sources/drivers/tpm/tpm.h ****    return base->SC & TPM_SC_TOF_MASK;
 239:../Sources/drivers/tpm/tpm.h **** }
 240:../Sources/drivers/tpm/tpm.h **** 
 241:../Sources/drivers/tpm/tpm.h **** /**********************************************************************
 242:../Sources/drivers/tpm/tpm.h ****  * Funo		:	TPM_ClearIRQFlag
 243:../Sources/drivers/tpm/tpm.h ****  *
 244:../Sources/drivers/tpm/tpm.h ****  * Descrio	:   Limpa a flag de interrupo gerada pelo mdulo TPM.
 245:../Sources/drivers/tpm/tpm.h ****  *
 246:../Sources/drivers/tpm/tpm.h ****  * Entradas		:   *base - registrador base do perifrico TPM.
 247:../Sources/drivers/tpm/tpm.h ****  *
 248:../Sources/drivers/tpm/tpm.h ****  * Sadas		:   Nenhuma.
 249:../Sources/drivers/tpm/tpm.h ****  *
 250:../Sources/drivers/tpm/tpm.h ****  * Comentrios 	: 	Nenhum.
 251:../Sources/drivers/tpm/tpm.h ****  * ********************************************************************/
 252:../Sources/drivers/tpm/tpm.h **** static inline void TPM_ClearIRQFlag(TPM_Type *base)
 253:../Sources/drivers/tpm/tpm.h **** {
 254:../Sources/drivers/tpm/tpm.h **** 	base->SC |= TPM_SC_TOF_MASK;
 255:../Sources/drivers/tpm/tpm.h **** }
 256:../Sources/drivers/tpm/tpm.h **** 
 257:../Sources/drivers/tpm/tpm.h **** /**********************************************************************
 258:../Sources/drivers/tpm/tpm.h ****  * Funo		:	TPM_SetModulo
 259:../Sources/drivers/tpm/tpm.h ****  *
 260:../Sources/drivers/tpm/tpm.h ****  * Descrio	:   Define valor de fim de contagem do mdulo do TPM.
 261:../Sources/drivers/tpm/tpm.h ****  *
 262:../Sources/drivers/tpm/tpm.h ****  * Entradas		:   *base - registrador base do perifrico TPM;
 263:../Sources/drivers/tpm/tpm.h ****  * 					modulo - valor de fim de contagem.
 264:../Sources/drivers/tpm/tpm.h ****  *
 265:../Sources/drivers/tpm/tpm.h ****  * Sadas		:   Nenhuma.
 266:../Sources/drivers/tpm/tpm.h ****  *
 267:../Sources/drivers/tpm/tpm.h ****  * Comentrios 	: 	Nenhum.
 268:../Sources/drivers/tpm/tpm.h ****  * ********************************************************************/
 269:../Sources/drivers/tpm/tpm.h **** static inline void TPM_SetModulo(TPM_Type *base, uint16_t modulo)
 270:../Sources/drivers/tpm/tpm.h **** {
 503              		.loc 3 270 0
 504              		.cfi_startproc
 505 0000 80B5     		push	{r7, lr}
 506              		.cfi_def_cfa_offset 8
 507              		.cfi_offset 7, -8
 508              		.cfi_offset 14, -4
 509 0002 82B0     		sub	sp, sp, #8
 510              		.cfi_def_cfa_offset 16
 511 0004 00AF     		add	r7, sp, #0
 512              		.cfi_def_cfa_register 7
 513 0006 7860     		str	r0, [r7, #4]
 514 0008 0A1C     		mov	r2, r1
 515 000a BB1C     		add	r3, r7, #2
 516 000c 1A80     		strh	r2, [r3]
 271:../Sources/drivers/tpm/tpm.h **** 	assert(base);
 517              		.loc 3 271 0
 518 000e 7B68     		ldr	r3, [r7, #4]
 519 0010 002B     		cmp	r3, #0
 520 0012 07D1     		bne	.L32
 521              		.loc 3 271 0 is_stmt 0 discriminator 1
 522 0014 0748     		ldr	r0, .L33
 523 0016 1023     		mov	r3, #16
 524 0018 191C     		mov	r1, r3
 525 001a FF31     		add	r1, r1, #255
 526 001c 064A     		ldr	r2, .L33+4
 527 001e 074B     		ldr	r3, .L33+8
 528 0020 FFF7FEFF 		bl	__assert_func
 529              	.L32:
 272:../Sources/drivers/tpm/tpm.h **** 
 273:../Sources/drivers/tpm/tpm.h **** 	base->MOD = modulo;
 530              		.loc 3 273 0 is_stmt 1
 531 0024 BB1C     		add	r3, r7, #2
 532 0026 1A88     		ldrh	r2, [r3]
 533 0028 7B68     		ldr	r3, [r7, #4]
 534 002a 9A60     		str	r2, [r3, #8]
 274:../Sources/drivers/tpm/tpm.h **** }
 535              		.loc 3 274 0
 536 002c BD46     		mov	sp, r7
 537 002e 02B0     		add	sp, sp, #8
 538              		@ sp needed
 539 0030 80BD     		pop	{r7, pc}
 540              	.L34:
 541 0032 C046     		.align	2
 542              	.L33:
 543 0034 48000000 		.word	.LC14
 544 0038 00000000 		.word	__func__.5827
 545 003c 20000000 		.word	.LC3
 546              		.cfi_endproc
 547              	.LFE56:
 549              		.comm	lcd0Config,4,4
 550              		.comm	lcd0,4,4
 551              		.comm	pwmDuty,1,1
 552              		.global	pwmFreq
 553              		.section	.data.pwmFreq,"aw",%progbits
 554              		.align	1
 557              	pwmFreq:
 558 0000 C800     		.short	200
 559              		.global	tpmPwmModulo
 560              		.section	.data.tpmPwmModulo,"aw",%progbits
 561              		.align	1
 564              	tpmPwmModulo:
 565 0000 CDCC     		.short	-13107
 566              		.comm	dutyKeyFlag,1,1
 567              		.comm	freqKeyFlag,1,1
 568              		.comm	portaISRFlag,1,1
 569              		.section	.text.PORTA_IRQHandler,"ax",%progbits
 570              		.align	2
 571              		.global	PORTA_IRQHandler
 572              		.code	16
 573              		.thumb_func
 575              	PORTA_IRQHandler:
 576              	.LFB76:
 577              		.file 4 "../Sources/main.c"
   1:../Sources/main.c **** /*
   2:../Sources/main.c ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   3:../Sources/main.c ****  * All rights reserved.
   4:../Sources/main.c ****  *
   5:../Sources/main.c ****  * Redistribution and use in source and binary forms, with or without modification,
   6:../Sources/main.c ****  * are permitted provided that the following conditions are met:
   7:../Sources/main.c ****  *
   8:../Sources/main.c ****  * o Redistributions of source code must retain the above copyright notice, this list
   9:../Sources/main.c ****  *   of conditions and the following disclaimer.
  10:../Sources/main.c ****  *
  11:../Sources/main.c ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  12:../Sources/main.c ****  *   list of conditions and the following disclaimer in the documentation and/or
  13:../Sources/main.c ****  *   other materials provided with the distribution.
  14:../Sources/main.c ****  *
  15:../Sources/main.c ****  * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
  16:../Sources/main.c ****  *   contributors may be used to endorse or promote products derived from this
  17:../Sources/main.c ****  *   software without specific prior written permission.
  18:../Sources/main.c ****  *
  19:../Sources/main.c ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  20:../Sources/main.c ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  21:../Sources/main.c ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  22:../Sources/main.c ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  23:../Sources/main.c ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  24:../Sources/main.c ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  25:../Sources/main.c ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  26:../Sources/main.c ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  27:../Sources/main.c ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  28:../Sources/main.c ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  29:../Sources/main.c ****  */
  30:../Sources/main.c **** 
  31:../Sources/main.c **** #include "mcu_general_config.h"
  32:../Sources/main.c **** #include "generic_drivers/lcd/lcd.h"
  33:../Sources/main.c **** #include "libraries/delay/delay.h"
  34:../Sources/main.c **** #include "libraries/emb_util/emb_util.h"
  35:../Sources/main.c **** #include "drivers/port/port.h"
  36:../Sources/main.c **** #include "drivers/gpio/gpio.h"
  37:../Sources/main.c **** #include "drivers/tpm/tpm.h"
  38:../Sources/main.c **** #include "drivers/adc/adc.h"
  39:../Sources/main.c **** 
  40:../Sources/main.c **** 
  41:../Sources/main.c **** #define BOARD_TIMER_PORT PORTB
  42:../Sources/main.c **** #define BOARD_TIMER_PIN 13
  43:../Sources/main.c **** 
  44:../Sources/main.c **** #define BOARD_KEY0_GPIO GPIOA
  45:../Sources/main.c **** #define BOARD_KEY0_PORT PORTA
  46:../Sources/main.c **** #define BOARD_KEY0_PIN 11
  47:../Sources/main.c **** #define BOARD_KEY0_PIN_MASK (1 << BOARD_LCD_D4_PIN)
  48:../Sources/main.c **** 
  49:../Sources/main.c **** #define BOARD_KEY1_GPIO GPIOA
  50:../Sources/main.c **** #define BOARD_KEY1_PORT PORTA
  51:../Sources/main.c **** #define BOARD_KEY1_PIN 1
  52:../Sources/main.c **** #define BOARD_KEY1_PIN_MASK (1 << BOARD_LCD_D4_PIN)
  53:../Sources/main.c **** 
  54:../Sources/main.c **** #define BOARD_LCD_D4_GPIO GPIOA
  55:../Sources/main.c **** #define BOARD_LCD_D4_PORT PORTA
  56:../Sources/main.c **** #define BOARD_LCD_D4_PIN 10
  57:../Sources/main.c **** #define BOARD_LCD_D4_PIN_MASK (1 << BOARD_LCD_D4_PIN)
  58:../Sources/main.c **** 
  59:../Sources/main.c **** #define BOARD_LCD_D5_GPIO GPIOA
  60:../Sources/main.c **** #define BOARD_LCD_D5_PORT PORTA
  61:../Sources/main.c **** #define BOARD_LCD_D5_PIN 12
  62:../Sources/main.c **** #define BOARD_LCD_D5_PIN_MASK (1 << BOARD_LCD_D5_PIN)
  63:../Sources/main.c **** 
  64:../Sources/main.c **** #define BOARD_LCD_D6_GPIO GPIOB
  65:../Sources/main.c **** #define BOARD_LCD_D6_PORT PORTB
  66:../Sources/main.c **** #define BOARD_LCD_D6_PIN 6
  67:../Sources/main.c **** #define BOARD_LCD_D6_PIN_MASK (1 << BOARD_LCD_D6_PIN)
  68:../Sources/main.c **** 
  69:../Sources/main.c **** #define BOARD_LCD_D7_GPIO GPIOB
  70:../Sources/main.c **** #define BOARD_LCD_D7_PORT PORTB
  71:../Sources/main.c **** #define BOARD_LCD_D7_PIN 7
  72:../Sources/main.c **** #define BOARD_LCD_D7_PIN_MASK (1 << BOARD_LCD_D7_PIN)
  73:../Sources/main.c **** 
  74:../Sources/main.c **** #define BOARD_LCD_RS_GPIO GPIOB
  75:../Sources/main.c **** #define BOARD_LCD_RS_PORT PORTB
  76:../Sources/main.c **** #define BOARD_LCD_RS_PIN 10
  77:../Sources/main.c **** #define BOARD_LCD_RS_PIN_MASK (1 << BOARD_LCD_RS_PIN)
  78:../Sources/main.c **** 
  79:../Sources/main.c **** #define BOARD_LCD_EN_GPIO GPIOB
  80:../Sources/main.c **** #define BOARD_LCD_EN_PORT PORTB
  81:../Sources/main.c **** #define BOARD_LCD_EN_PIN 11
  82:../Sources/main.c **** #define BOARD_LCD_EN_PIN_MASK (1 << BOARD_LCD_EN_PIN)
  83:../Sources/main.c **** 
  84:../Sources/main.c **** lcdConfig_t *lcd0Config;
  85:../Sources/main.c **** lcdHandle_t lcd0;
  86:../Sources/main.c **** 
  87:../Sources/main.c **** uint8_t pwmDuty;
  88:../Sources/main.c **** uint16_t pwmFreq = 200, tpmPwmModulo = 52429;
  89:../Sources/main.c **** volatile uint8_t dutyKeyFlag, freqKeyFlag, portaISRFlag;
  90:../Sources/main.c **** 
  91:../Sources/main.c **** void PORTA_IRQHandler(void)
  92:../Sources/main.c **** {
 578              		.loc 4 92 0
 579              		.cfi_startproc
 580 0000 80B5     		push	{r7, lr}
 581              		.cfi_def_cfa_offset 8
 582              		.cfi_offset 7, -8
 583              		.cfi_offset 14, -4
 584 0002 00AF     		add	r7, sp, #0
 585              		.cfi_def_cfa_register 7
  93:../Sources/main.c **** 	portaISRFlag = 1;
 586              		.loc 4 93 0
 587 0004 104B     		ldr	r3, .L38
 588 0006 0122     		mov	r2, #1
 589 0008 1A70     		strb	r2, [r3]
  94:../Sources/main.c **** 
  95:../Sources/main.c **** 	if( PORTA->ISFR & BOARD_KEY0_PIN )
 590              		.loc 4 95 0
 591 000a 104A     		ldr	r2, .L38+4
 592 000c A023     		mov	r3, #160
 593 000e D258     		ldr	r2, [r2, r3]
 594 0010 0B23     		mov	r3, #11
 595 0012 1340     		and	r3, r2
 596 0014 06D0     		beq	.L36
  96:../Sources/main.c **** 	{
  97:../Sources/main.c **** 		dutyKeyFlag = 1;
 597              		.loc 4 97 0
 598 0016 0E4B     		ldr	r3, .L38+8
 599 0018 0122     		mov	r2, #1
 600 001a 1A70     		strb	r2, [r3]
  98:../Sources/main.c **** 		PORTA->ISFR = BOARD_KEY0_PIN;
 601              		.loc 4 98 0
 602 001c 0B4A     		ldr	r2, .L38+4
 603 001e A023     		mov	r3, #160
 604 0020 0B21     		mov	r1, #11
 605 0022 D150     		str	r1, [r2, r3]
 606              	.L36:
  99:../Sources/main.c **** 	}
 100:../Sources/main.c **** 
 101:../Sources/main.c **** 	if( PORTA->ISFR & BOARD_KEY1_PIN )
 607              		.loc 4 101 0
 608 0024 094A     		ldr	r2, .L38+4
 609 0026 A023     		mov	r3, #160
 610 0028 D258     		ldr	r2, [r2, r3]
 611 002a 0123     		mov	r3, #1
 612 002c 1340     		and	r3, r2
 613 002e 06D0     		beq	.L37
 102:../Sources/main.c **** 	{
 103:../Sources/main.c **** 		freqKeyFlag = 1;
 614              		.loc 4 103 0
 615 0030 084B     		ldr	r3, .L38+12
 616 0032 0122     		mov	r2, #1
 617 0034 1A70     		strb	r2, [r3]
 104:../Sources/main.c **** 		PORTA->ISFR = BOARD_KEY1_PIN;
 618              		.loc 4 104 0
 619 0036 054A     		ldr	r2, .L38+4
 620 0038 A023     		mov	r3, #160
 621 003a 0121     		mov	r1, #1
 622 003c D150     		str	r1, [r2, r3]
 623              	.L37:
 105:../Sources/main.c **** 	}
 106:../Sources/main.c **** 
 107:../Sources/main.c **** 	NVIC_DisableIRQ( PORTA_IRQn );
 624              		.loc 4 107 0
 625 003e 1E20     		mov	r0, #30
 626 0040 FFF7FEFF 		bl	NVIC_DisableIRQ
 108:../Sources/main.c **** }
 627              		.loc 4 108 0
 628 0044 BD46     		mov	sp, r7
 629              		@ sp needed
 630 0046 80BD     		pop	{r7, pc}
 631              	.L39:
 632              		.align	2
 633              	.L38:
 634 0048 00000000 		.word	portaISRFlag
 635 004c 00900440 		.word	1074040832
 636 0050 00000000 		.word	dutyKeyFlag
 637 0054 00000000 		.word	freqKeyFlag
 638              		.cfi_endproc
 639              	.LFE76:
 641              		.section	.rodata
 642 0065 000000   		.align	2
 643              	.LC30:
 644 0068 50574D20 		.ascii	"PWM Duty: \000"
 644      44757479 
 644      3A2000
 645 0073 00       		.align	2
 646              	.LC32:
 647 0074 20202020 		.ascii	"              \000"
 647      20202020 
 647      20202020 
 647      202000
 648 0083 00       		.align	2
 649              	.LC34:
 650 0084 3000     		.ascii	"0\000"
 651 0086 0000     		.align	2
 652              	.LC36:
 653 0088 50574D20 		.ascii	"PWM Freq.: \000"
 653      46726571 
 653      2E3A2000 
 654              		.align	2
 655              	.LC38:
 656 0094 32303000 		.ascii	"200\000"
 657              		.global	__aeabi_idiv
 658              		.global	__aeabi_uidiv
 659              		.section	.text.main,"ax",%progbits
 660              		.align	2
 661              		.global	main
 662              		.code	16
 663              		.thumb_func
 665              	main:
 666              	.LFB77:
 109:../Sources/main.c **** 
 110:../Sources/main.c **** int main(void)
 111:../Sources/main.c **** {
 667              		.loc 4 111 0
 668              		.cfi_startproc
 669 0000 80B5     		push	{r7, lr}
 670              		.cfi_def_cfa_offset 8
 671              		.cfi_offset 7, -8
 672              		.cfi_offset 14, -4
 673 0002 84B0     		sub	sp, sp, #16
 674              		.cfi_def_cfa_offset 24
 675 0004 00AF     		add	r7, sp, #0
 676              		.cfi_def_cfa_register 7
 112:../Sources/main.c **** 	uint32_t adcValue;
 113:../Sources/main.c **** 	char lcdString[10];
 114:../Sources/main.c **** 
 115:../Sources/main.c ****     /* Write your code here */
 116:../Sources/main.c **** 	TPM_SetCounterClkSrc(TPM1, TPM_CNT_CLOCK_FLL);
 677              		.loc 4 116 0
 678 0006 EA4B     		ldr	r3, .L49
 679 0008 181C     		mov	r0, r3
 680 000a 0121     		mov	r1, #1
 681 000c FFF7FEFF 		bl	TPM_SetCounterClkSrc
 117:../Sources/main.c **** 	TPM_Init(TPM1, tpmPwmModulo, TPM_PRESCALER_DIV_2); /*Inicializa TPM1*/
 682              		.loc 4 117 0
 683 0010 E84B     		ldr	r3, .L49+4
 684 0012 1B88     		ldrh	r3, [r3]
 685 0014 E64A     		ldr	r2, .L49
 686 0016 101C     		mov	r0, r2
 687 0018 191C     		mov	r1, r3
 688 001a 0122     		mov	r2, #1
 689 001c FFF7FEFF 		bl	TPM_Init
 118:../Sources/main.c **** 
 119:../Sources/main.c **** 	PORT_Init(PORTA);
 690              		.loc 4 119 0
 691 0020 E54B     		ldr	r3, .L49+8
 692 0022 181C     		mov	r0, r3
 693 0024 FFF7FEFF 		bl	PORT_Init
 120:../Sources/main.c **** 	PORT_Init(PORTB);
 694              		.loc 4 120 0
 695 0028 E44B     		ldr	r3, .L49+12
 696 002a 181C     		mov	r0, r3
 697 002c FFF7FEFF 		bl	PORT_Init
 121:../Sources/main.c **** 
 122:../Sources/main.c **** 	GPIO_InitOutputPin(BOARD_LCD_D4_GPIO, BOARD_LCD_D4_PIN, 0);
 698              		.loc 4 122 0
 699 0030 E34B     		ldr	r3, .L49+16
 700 0032 181C     		mov	r0, r3
 701 0034 0A21     		mov	r1, #10
 702 0036 0022     		mov	r2, #0
 703 0038 FFF7FEFF 		bl	GPIO_InitOutputPin
 123:../Sources/main.c **** 	GPIO_InitOutputPin(BOARD_LCD_D5_GPIO, BOARD_LCD_D5_PIN, 0);
 704              		.loc 4 123 0
 705 003c E04B     		ldr	r3, .L49+16
 706 003e 181C     		mov	r0, r3
 707 0040 0C21     		mov	r1, #12
 708 0042 0022     		mov	r2, #0
 709 0044 FFF7FEFF 		bl	GPIO_InitOutputPin
 124:../Sources/main.c **** 	GPIO_InitOutputPin(BOARD_LCD_D6_GPIO, BOARD_LCD_D6_PIN, 0);
 710              		.loc 4 124 0
 711 0048 DE4B     		ldr	r3, .L49+20
 712 004a 181C     		mov	r0, r3
 713 004c 0621     		mov	r1, #6
 714 004e 0022     		mov	r2, #0
 715 0050 FFF7FEFF 		bl	GPIO_InitOutputPin
 125:../Sources/main.c **** 	GPIO_InitOutputPin(BOARD_LCD_D7_GPIO, BOARD_LCD_D7_PIN, 0);
 716              		.loc 4 125 0
 717 0054 DB4B     		ldr	r3, .L49+20
 718 0056 181C     		mov	r0, r3
 719 0058 0721     		mov	r1, #7
 720 005a 0022     		mov	r2, #0
 721 005c FFF7FEFF 		bl	GPIO_InitOutputPin
 126:../Sources/main.c **** 	GPIO_InitOutputPin(BOARD_LCD_RS_GPIO, BOARD_LCD_RS_PIN, 0);
 722              		.loc 4 126 0
 723 0060 D84B     		ldr	r3, .L49+20
 724 0062 181C     		mov	r0, r3
 725 0064 0A21     		mov	r1, #10
 726 0066 0022     		mov	r2, #0
 727 0068 FFF7FEFF 		bl	GPIO_InitOutputPin
 127:../Sources/main.c **** 	GPIO_InitOutputPin(BOARD_LCD_EN_GPIO, BOARD_LCD_EN_PIN, 0);
 728              		.loc 4 127 0
 729 006c D54B     		ldr	r3, .L49+20
 730 006e 181C     		mov	r0, r3
 731 0070 0B21     		mov	r1, #11
 732 0072 0022     		mov	r2, #0
 733 0074 FFF7FEFF 		bl	GPIO_InitOutputPin
 128:../Sources/main.c **** 
 129:../Sources/main.c **** 	GPIO_InitInputPin(BOARD_KEY0_GPIO, BOARD_KEY0_PIN);
 734              		.loc 4 129 0
 735 0078 D14B     		ldr	r3, .L49+16
 736 007a 181C     		mov	r0, r3
 737 007c 0B21     		mov	r1, #11
 738 007e FFF7FEFF 		bl	GPIO_InitInputPin
 130:../Sources/main.c **** 	GPIO_InitInputPin(BOARD_KEY1_GPIO, BOARD_KEY1_PIN);
 739              		.loc 4 130 0
 740 0082 CF4B     		ldr	r3, .L49+16
 741 0084 181C     		mov	r0, r3
 742 0086 0121     		mov	r1, #1
 743 0088 FFF7FEFF 		bl	GPIO_InitInputPin
 131:../Sources/main.c **** 
 132:../Sources/main.c **** 	PORT_IRQEnable(BOARD_KEY0_PORT, BOARD_KEY0_PIN, PORT_IRQ_ON_FALLING_EDGE);
 744              		.loc 4 132 0
 745 008c CA4B     		ldr	r3, .L49+8
 746 008e 181C     		mov	r0, r3
 747 0090 0B21     		mov	r1, #11
 748 0092 0A22     		mov	r2, #10
 749 0094 FFF7FEFF 		bl	PORT_IRQEnable
 133:../Sources/main.c **** 	PORT_PullEnable(BOARD_KEY0_PORT, BOARD_KEY0_PIN);
 750              		.loc 4 133 0
 751 0098 C74B     		ldr	r3, .L49+8
 752 009a 181C     		mov	r0, r3
 753 009c 0B21     		mov	r1, #11
 754 009e FFF7FEFF 		bl	PORT_PullEnable
 134:../Sources/main.c **** 
 135:../Sources/main.c **** 	PORT_IRQEnable(BOARD_KEY1_PORT, BOARD_KEY1_PIN, PORT_IRQ_ON_FALLING_EDGE);
 755              		.loc 4 135 0
 756 00a2 C54B     		ldr	r3, .L49+8
 757 00a4 181C     		mov	r0, r3
 758 00a6 0121     		mov	r1, #1
 759 00a8 0A22     		mov	r2, #10
 760 00aa FFF7FEFF 		bl	PORT_IRQEnable
 136:../Sources/main.c **** 	PORT_PullEnable(BOARD_KEY1_PORT, BOARD_KEY1_PIN);
 761              		.loc 4 136 0
 762 00ae C24B     		ldr	r3, .L49+8
 763 00b0 181C     		mov	r0, r3
 764 00b2 0121     		mov	r1, #1
 765 00b4 FFF7FEFF 		bl	PORT_PullEnable
 137:../Sources/main.c **** 
 138:../Sources/main.c **** 	PORT_SetMux(BOARD_TIMER_PORT, BOARD_TIMER_PIN, PORT_MUX_ALT2);
 766              		.loc 4 138 0
 767 00b8 C04B     		ldr	r3, .L49+12
 768 00ba 181C     		mov	r0, r3
 769 00bc 0D21     		mov	r1, #13
 770 00be 0222     		mov	r2, #2
 771 00c0 FFF7FEFF 		bl	PORT_SetMux
 139:../Sources/main.c **** 	/* O canal que controla o pino PTB13  o TPM1_Ch1
 140:../Sources/main.c **** 	 * Ir ser utilizado o PWM alinhado a borda, com o duty cycle em nvel alto*/
 141:../Sources/main.c **** 	TPM_InitChannel(TPM1, 0, TPM_EDGE_PWM_MODE, TPM_PWM_HIGH_TRUE_CONFIG);
 772              		.loc 4 141 0
 773 00c4 BA4B     		ldr	r3, .L49
 774 00c6 181C     		mov	r0, r3
 775 00c8 0021     		mov	r1, #0
 776 00ca 0222     		mov	r2, #2
 777 00cc 0623     		mov	r3, #6
 778 00ce FFF7FEFF 		bl	TPM_InitChannel
 142:../Sources/main.c **** 	TPM_SetChMatch(TPM1, 0, 0); /*Configurao do duty cycle (valor de match)*/
 779              		.loc 4 142 0
 780 00d2 B74B     		ldr	r3, .L49
 781 00d4 181C     		mov	r0, r3
 782 00d6 0021     		mov	r1, #0
 783 00d8 0022     		mov	r2, #0
 784 00da FFF7FEFF 		bl	TPM_SetChMatch
 143:../Sources/main.c **** 
 144:../Sources/main.c **** 	TPM_InitCounter(TPM1); /*Inicializa registrador contador*/
 785              		.loc 4 144 0
 786 00de B44B     		ldr	r3, .L49
 787 00e0 181C     		mov	r0, r3
 788 00e2 FFF7FEFF 		bl	TPM_InitCounter
 145:../Sources/main.c **** 
 146:../Sources/main.c **** 	Delay_Init();
 789              		.loc 4 146 0
 790 00e6 FFF7FEFF 		bl	Delay_Init
 147:../Sources/main.c **** 
 148:../Sources/main.c **** 	lcd0Config = LCD_CreateConfig();
 791              		.loc 4 148 0
 792 00ea FFF7FEFF 		bl	LCD_CreateConfig
 793 00ee 021C     		mov	r2, r0
 794 00f0 B54B     		ldr	r3, .L49+24
 795 00f2 1A60     		str	r2, [r3]
 149:../Sources/main.c **** 	lcd0Config->lines = 2;
 796              		.loc 4 149 0
 797 00f4 B44B     		ldr	r3, .L49+24
 798 00f6 1B68     		ldr	r3, [r3]
 799 00f8 0222     		mov	r2, #2
 800 00fa 5A70     		strb	r2, [r3, #1]
 150:../Sources/main.c **** 	lcd0Config->cols = 16;
 801              		.loc 4 150 0
 802 00fc B24B     		ldr	r3, .L49+24
 803 00fe 1B68     		ldr	r3, [r3]
 804 0100 1022     		mov	r2, #16
 805 0102 1A70     		strb	r2, [r3]
 151:../Sources/main.c **** 	lcd0Config->charsize = LCD_5x8DOTS;
 806              		.loc 4 151 0
 807 0104 B04B     		ldr	r3, .L49+24
 808 0106 1B68     		ldr	r3, [r3]
 809 0108 0022     		mov	r2, #0
 810 010a 9A70     		strb	r2, [r3, #2]
 152:../Sources/main.c **** 	lcd0Config->bus.data[0].portRegister = BOARD_LCD_D4_GPIO;
 811              		.loc 4 152 0
 812 010c AE4B     		ldr	r3, .L49+24
 813 010e 1B68     		ldr	r3, [r3]
 814 0110 AB4A     		ldr	r2, .L49+16
 815 0112 5A60     		str	r2, [r3, #4]
 153:../Sources/main.c **** 	lcd0Config->bus.data[0].pinMask =  BOARD_LCD_D4_PIN_MASK;
 816              		.loc 4 153 0
 817 0114 AC4B     		ldr	r3, .L49+24
 818 0116 1B68     		ldr	r3, [r3]
 819 0118 8022     		mov	r2, #128
 820 011a D200     		lsl	r2, r2, #3
 821 011c 9A60     		str	r2, [r3, #8]
 154:../Sources/main.c **** 	lcd0Config->bus.data[1].portRegister = BOARD_LCD_D5_GPIO;
 822              		.loc 4 154 0
 823 011e AA4B     		ldr	r3, .L49+24
 824 0120 1B68     		ldr	r3, [r3]
 825 0122 A74A     		ldr	r2, .L49+16
 826 0124 DA60     		str	r2, [r3, #12]
 155:../Sources/main.c **** 	lcd0Config->bus.data[1].pinMask =  BOARD_LCD_D5_PIN_MASK;
 827              		.loc 4 155 0
 828 0126 A84B     		ldr	r3, .L49+24
 829 0128 1B68     		ldr	r3, [r3]
 830 012a 8022     		mov	r2, #128
 831 012c 5201     		lsl	r2, r2, #5
 832 012e 1A61     		str	r2, [r3, #16]
 156:../Sources/main.c **** 	lcd0Config->bus.data[2].portRegister = BOARD_LCD_D6_GPIO;
 833              		.loc 4 156 0
 834 0130 A54B     		ldr	r3, .L49+24
 835 0132 1B68     		ldr	r3, [r3]
 836 0134 A34A     		ldr	r2, .L49+20
 837 0136 5A61     		str	r2, [r3, #20]
 157:../Sources/main.c **** 	lcd0Config->bus.data[2].pinMask =  BOARD_LCD_D6_PIN_MASK;
 838              		.loc 4 157 0
 839 0138 A34B     		ldr	r3, .L49+24
 840 013a 1B68     		ldr	r3, [r3]
 841 013c 4022     		mov	r2, #64
 842 013e 9A61     		str	r2, [r3, #24]
 158:../Sources/main.c **** 	lcd0Config->bus.data[3].portRegister = BOARD_LCD_D7_GPIO;
 843              		.loc 4 158 0
 844 0140 A14B     		ldr	r3, .L49+24
 845 0142 1B68     		ldr	r3, [r3]
 846 0144 9F4A     		ldr	r2, .L49+20
 847 0146 DA61     		str	r2, [r3, #28]
 159:../Sources/main.c **** 	lcd0Config->bus.data[3].pinMask =  BOARD_LCD_D7_PIN_MASK;
 848              		.loc 4 159 0
 849 0148 9F4B     		ldr	r3, .L49+24
 850 014a 1B68     		ldr	r3, [r3]
 851 014c 8022     		mov	r2, #128
 852 014e 1A62     		str	r2, [r3, #32]
 160:../Sources/main.c **** 	lcd0Config->bus.rs.portRegister = BOARD_LCD_RS_GPIO;
 853              		.loc 4 160 0
 854 0150 9D4B     		ldr	r3, .L49+24
 855 0152 1B68     		ldr	r3, [r3]
 856 0154 9B4A     		ldr	r2, .L49+20
 857 0156 5A62     		str	r2, [r3, #36]
 161:../Sources/main.c **** 	lcd0Config->bus.rs.pinMask =  BOARD_LCD_RS_PIN_MASK;
 858              		.loc 4 161 0
 859 0158 9B4B     		ldr	r3, .L49+24
 860 015a 1B68     		ldr	r3, [r3]
 861 015c 8022     		mov	r2, #128
 862 015e D200     		lsl	r2, r2, #3
 863 0160 9A62     		str	r2, [r3, #40]
 162:../Sources/main.c **** 	lcd0Config->bus.en.portRegister = BOARD_LCD_EN_GPIO;
 864              		.loc 4 162 0
 865 0162 994B     		ldr	r3, .L49+24
 866 0164 1B68     		ldr	r3, [r3]
 867 0166 974A     		ldr	r2, .L49+20
 868 0168 DA62     		str	r2, [r3, #44]
 163:../Sources/main.c **** 	lcd0Config->bus.en.pinMask =  BOARD_LCD_EN_PIN_MASK;
 869              		.loc 4 163 0
 870 016a 974B     		ldr	r3, .L49+24
 871 016c 1B68     		ldr	r3, [r3]
 872 016e 8022     		mov	r2, #128
 873 0170 1201     		lsl	r2, r2, #4
 874 0172 1A63     		str	r2, [r3, #48]
 164:../Sources/main.c **** 
 165:../Sources/main.c **** 	lcd0 = LCD_Init(lcd0Config);
 875              		.loc 4 165 0
 876 0174 944B     		ldr	r3, .L49+24
 877 0176 1B68     		ldr	r3, [r3]
 878 0178 181C     		mov	r0, r3
 879 017a FFF7FEFF 		bl	LCD_Init
 880 017e 021C     		mov	r2, r0
 881 0180 924B     		ldr	r3, .L49+28
 882 0182 1A60     		str	r2, [r3]
 166:../Sources/main.c **** 
 167:../Sources/main.c ****     Delay_Waitms(1000);
 883              		.loc 4 167 0
 884 0184 FA23     		mov	r3, #250
 885 0186 9B00     		lsl	r3, r3, #2
 886 0188 181C     		mov	r0, r3
 887 018a FFF7FEFF 		bl	Delay_Waitms
 168:../Sources/main.c **** 
 169:../Sources/main.c ****     LCD_Clear(lcd0);
 888              		.loc 4 169 0
 889 018e 8F4B     		ldr	r3, .L49+28
 890 0190 1B68     		ldr	r3, [r3]
 891 0192 181C     		mov	r0, r3
 892 0194 FFF7FEFF 		bl	LCD_Clear
 170:../Sources/main.c **** 
 171:../Sources/main.c ****     LCD_SetCursor(lcd0, 0, 0);
 893              		.loc 4 171 0
 894 0198 8C4B     		ldr	r3, .L49+28
 895 019a 1B68     		ldr	r3, [r3]
 896 019c 181C     		mov	r0, r3
 897 019e 0021     		mov	r1, #0
 898 01a0 0022     		mov	r2, #0
 899 01a2 FFF7FEFF 		bl	LCD_SetCursor
 172:../Sources/main.c ****     LCD_WriteString(lcd0, "PWM Duty: ");
 900              		.loc 4 172 0
 901 01a6 894B     		ldr	r3, .L49+28
 902 01a8 1A68     		ldr	r2, [r3]
 903 01aa 894B     		ldr	r3, .L49+32
 904 01ac 101C     		mov	r0, r2
 905 01ae 191C     		mov	r1, r3
 906 01b0 FFF7FEFF 		bl	LCD_WriteString
 173:../Sources/main.c ****     LCD_SetCursor(lcd0, sizeof("PWM Duty:"), 0);
 907              		.loc 4 173 0
 908 01b4 854B     		ldr	r3, .L49+28
 909 01b6 1B68     		ldr	r3, [r3]
 910 01b8 181C     		mov	r0, r3
 911 01ba 0A21     		mov	r1, #10
 912 01bc 0022     		mov	r2, #0
 913 01be FFF7FEFF 		bl	LCD_SetCursor
 174:../Sources/main.c **** 	LCD_WriteString(lcd0, "              ");
 914              		.loc 4 174 0
 915 01c2 824B     		ldr	r3, .L49+28
 916 01c4 1A68     		ldr	r2, [r3]
 917 01c6 834B     		ldr	r3, .L49+36
 918 01c8 101C     		mov	r0, r2
 919 01ca 191C     		mov	r1, r3
 920 01cc FFF7FEFF 		bl	LCD_WriteString
 175:../Sources/main.c **** 	LCD_SetCursor(lcd0, sizeof("PWM Duty:"), 0);
 921              		.loc 4 175 0
 922 01d0 7E4B     		ldr	r3, .L49+28
 923 01d2 1B68     		ldr	r3, [r3]
 924 01d4 181C     		mov	r0, r3
 925 01d6 0A21     		mov	r1, #10
 926 01d8 0022     		mov	r2, #0
 927 01da FFF7FEFF 		bl	LCD_SetCursor
 176:../Sources/main.c ****    	LCD_WriteString(lcd0, "0");
 928              		.loc 4 176 0
 929 01de 7B4B     		ldr	r3, .L49+28
 930 01e0 1A68     		ldr	r2, [r3]
 931 01e2 7D4B     		ldr	r3, .L49+40
 932 01e4 101C     		mov	r0, r2
 933 01e6 191C     		mov	r1, r3
 934 01e8 FFF7FEFF 		bl	LCD_WriteString
 177:../Sources/main.c **** 
 178:../Sources/main.c ****     LCD_SetCursor(lcd0, 0, 1);
 935              		.loc 4 178 0
 936 01ec 774B     		ldr	r3, .L49+28
 937 01ee 1B68     		ldr	r3, [r3]
 938 01f0 181C     		mov	r0, r3
 939 01f2 0021     		mov	r1, #0
 940 01f4 0122     		mov	r2, #1
 941 01f6 FFF7FEFF 		bl	LCD_SetCursor
 179:../Sources/main.c ****     LCD_WriteString(lcd0, "PWM Freq.: ");
 942              		.loc 4 179 0
 943 01fa 744B     		ldr	r3, .L49+28
 944 01fc 1A68     		ldr	r2, [r3]
 945 01fe 774B     		ldr	r3, .L49+44
 946 0200 101C     		mov	r0, r2
 947 0202 191C     		mov	r1, r3
 948 0204 FFF7FEFF 		bl	LCD_WriteString
 180:../Sources/main.c ****     LCD_SetCursor(lcd0, sizeof("PWM Freq.:"), 1);
 949              		.loc 4 180 0
 950 0208 704B     		ldr	r3, .L49+28
 951 020a 1B68     		ldr	r3, [r3]
 952 020c 181C     		mov	r0, r3
 953 020e 0B21     		mov	r1, #11
 954 0210 0122     		mov	r2, #1
 955 0212 FFF7FEFF 		bl	LCD_SetCursor
 181:../Sources/main.c **** 	LCD_WriteString(lcd0, "              ");
 956              		.loc 4 181 0
 957 0216 6D4B     		ldr	r3, .L49+28
 958 0218 1A68     		ldr	r2, [r3]
 959 021a 6E4B     		ldr	r3, .L49+36
 960 021c 101C     		mov	r0, r2
 961 021e 191C     		mov	r1, r3
 962 0220 FFF7FEFF 		bl	LCD_WriteString
 182:../Sources/main.c **** 	LCD_SetCursor(lcd0, sizeof("PWM Freq.:"), 1);
 963              		.loc 4 182 0
 964 0224 694B     		ldr	r3, .L49+28
 965 0226 1B68     		ldr	r3, [r3]
 966 0228 181C     		mov	r0, r3
 967 022a 0B21     		mov	r1, #11
 968 022c 0122     		mov	r2, #1
 969 022e FFF7FEFF 		bl	LCD_SetCursor
 183:../Sources/main.c ****    	LCD_WriteString(lcd0, "200");
 970              		.loc 4 183 0
 971 0232 664B     		ldr	r3, .L49+28
 972 0234 1A68     		ldr	r2, [r3]
 973 0236 6A4B     		ldr	r3, .L49+48
 974 0238 101C     		mov	r0, r2
 975 023a 191C     		mov	r1, r3
 976 023c FFF7FEFF 		bl	LCD_WriteString
 977              	.L48:
 184:../Sources/main.c **** 
 185:../Sources/main.c **** 
 186:../Sources/main.c ****    	uint8_t keyFlagTmp, freqKeyFlagTmp;
 187:../Sources/main.c **** 
 188:../Sources/main.c ****     for (;;) {
 189:../Sources/main.c **** 
 190:../Sources/main.c ****     	if ( keyFlagTmp )
 978              		.loc 4 190 0
 979 0240 3B1C     		mov	r3, r7
 980 0242 0F33     		add	r3, r3, #15
 981 0244 1B78     		ldrb	r3, [r3]
 982 0246 002B     		cmp	r3, #0
 983 0248 46D0     		beq	.L41
 191:../Sources/main.c ****     	{
 192:../Sources/main.c ****     		dutyKeyFlag = 0;
 984              		.loc 4 192 0
 985 024a 664B     		ldr	r3, .L49+52
 986 024c 0022     		mov	r2, #0
 987 024e 1A70     		strb	r2, [r3]
 193:../Sources/main.c **** 
 194:../Sources/main.c ****     		if( pwmDuty == 100)
 988              		.loc 4 194 0
 989 0250 654B     		ldr	r3, .L49+56
 990 0252 1B78     		ldrb	r3, [r3]
 991 0254 642B     		cmp	r3, #100
 992 0256 03D1     		bne	.L42
 195:../Sources/main.c ****     		{
 196:../Sources/main.c ****     			pwmDuty = 0;
 993              		.loc 4 196 0
 994 0258 634B     		ldr	r3, .L49+56
 995 025a 0022     		mov	r2, #0
 996 025c 1A70     		strb	r2, [r3]
 997 025e 05E0     		b	.L43
 998              	.L42:
 197:../Sources/main.c ****     		}
 198:../Sources/main.c ****     		else
 199:../Sources/main.c ****     		{
 200:../Sources/main.c ****     			pwmDuty += 10;
 999              		.loc 4 200 0
 1000 0260 614B     		ldr	r3, .L49+56
 1001 0262 1B78     		ldrb	r3, [r3]
 1002 0264 0A33     		add	r3, r3, #10
 1003 0266 DAB2     		uxtb	r2, r3
 1004 0268 5F4B     		ldr	r3, .L49+56
 1005 026a 1A70     		strb	r2, [r3]
 1006              	.L43:
 201:../Sources/main.c ****     		}
 202:../Sources/main.c ****             TPM_SetChMatch(TPM1, 0, ( pwmDuty * tpmPwmModulo ) / 100 ); /*Configurao do duty cycl
 1007              		.loc 4 202 0
 1008 026c 5E4B     		ldr	r3, .L49+56
 1009 026e 1B78     		ldrb	r3, [r3]
 1010 0270 504A     		ldr	r2, .L49+4
 1011 0272 1288     		ldrh	r2, [r2]
 1012 0274 5343     		mul	r3, r2
 1013 0276 181C     		mov	r0, r3
 1014 0278 6421     		mov	r1, #100
 1015 027a FFF7FEFF 		bl	__aeabi_idiv
 1016 027e 031C     		mov	r3, r0
 1017 0280 9BB2     		uxth	r3, r3
 1018 0282 4B4A     		ldr	r2, .L49
 1019 0284 101C     		mov	r0, r2
 1020 0286 0021     		mov	r1, #0
 1021 0288 1A1C     		mov	r2, r3
 1022 028a FFF7FEFF 		bl	TPM_SetChMatch
 203:../Sources/main.c ****         	EmbUtil_ItoA(pwmDuty, lcdString, 10);
 1023              		.loc 4 203 0
 1024 028e 564B     		ldr	r3, .L49+56
 1025 0290 1B78     		ldrb	r3, [r3]
 1026 0292 1A1C     		mov	r2, r3
 1027 0294 3B1D     		add	r3, r7, #4
 1028 0296 101C     		mov	r0, r2
 1029 0298 191C     		mov	r1, r3
 1030 029a 0A22     		mov	r2, #10
 1031 029c FFF7FEFF 		bl	EmbUtil_ItoA
 204:../Sources/main.c ****         	LCD_SetCursor(lcd0, sizeof("PWM Duty:"), 0);
 1032              		.loc 4 204 0
 1033 02a0 4A4B     		ldr	r3, .L49+28
 1034 02a2 1B68     		ldr	r3, [r3]
 1035 02a4 181C     		mov	r0, r3
 1036 02a6 0A21     		mov	r1, #10
 1037 02a8 0022     		mov	r2, #0
 1038 02aa FFF7FEFF 		bl	LCD_SetCursor
 205:../Sources/main.c ****         	LCD_WriteString(lcd0, "              ");
 1039              		.loc 4 205 0
 1040 02ae 474B     		ldr	r3, .L49+28
 1041 02b0 1A68     		ldr	r2, [r3]
 1042 02b2 484B     		ldr	r3, .L49+36
 1043 02b4 101C     		mov	r0, r2
 1044 02b6 191C     		mov	r1, r3
 1045 02b8 FFF7FEFF 		bl	LCD_WriteString
 206:../Sources/main.c ****         	LCD_SetCursor(lcd0, sizeof("PWM Duty:"), 0);
 1046              		.loc 4 206 0
 1047 02bc 434B     		ldr	r3, .L49+28
 1048 02be 1B68     		ldr	r3, [r3]
 1049 02c0 181C     		mov	r0, r3
 1050 02c2 0A21     		mov	r1, #10
 1051 02c4 0022     		mov	r2, #0
 1052 02c6 FFF7FEFF 		bl	LCD_SetCursor
 207:../Sources/main.c ****         	LCD_WriteString(lcd0, lcdString);
 1053              		.loc 4 207 0
 1054 02ca 404B     		ldr	r3, .L49+28
 1055 02cc 1A68     		ldr	r2, [r3]
 1056 02ce 3B1D     		add	r3, r7, #4
 1057 02d0 101C     		mov	r0, r2
 1058 02d2 191C     		mov	r1, r3
 1059 02d4 FFF7FEFF 		bl	LCD_WriteString
 1060              	.L41:
 208:../Sources/main.c ****     	}
 209:../Sources/main.c **** 
 210:../Sources/main.c ****     	if ( freqKeyFlagTmp )
 1061              		.loc 4 210 0
 1062 02d8 3B1C     		mov	r3, r7
 1063 02da 0E33     		add	r3, r3, #14
 1064 02dc 1B78     		ldrb	r3, [r3]
 1065 02de 002B     		cmp	r3, #0
 1066 02e0 49D0     		beq	.L44
 211:../Sources/main.c ****     	{
 212:../Sources/main.c ****     		freqKeyFlag = 0;
 1067              		.loc 4 212 0
 1068 02e2 424B     		ldr	r3, .L49+60
 1069 02e4 0022     		mov	r2, #0
 1070 02e6 1A70     		strb	r2, [r3]
 213:../Sources/main.c **** 
 214:../Sources/main.c ****     		if( pwmFreq == 1000)
 1071              		.loc 4 214 0
 1072 02e8 414B     		ldr	r3, .L49+64
 1073 02ea 1A88     		ldrh	r2, [r3]
 1074 02ec FA23     		mov	r3, #250
 1075 02ee 9B00     		lsl	r3, r3, #2
 1076 02f0 9A42     		cmp	r2, r3
 1077 02f2 03D1     		bne	.L45
 215:../Sources/main.c ****     		{
 216:../Sources/main.c ****     			pwmFreq = 200;
 1078              		.loc 4 216 0
 1079 02f4 3E4B     		ldr	r3, .L49+64
 1080 02f6 C822     		mov	r2, #200
 1081 02f8 1A80     		strh	r2, [r3]
 1082 02fa 05E0     		b	.L46
 1083              	.L45:
 217:../Sources/main.c ****     		}
 218:../Sources/main.c ****     		else
 219:../Sources/main.c ****     		{
 220:../Sources/main.c ****     			pwmFreq += 50;
 1084              		.loc 4 220 0
 1085 02fc 3C4B     		ldr	r3, .L49+64
 1086 02fe 1B88     		ldrh	r3, [r3]
 1087 0300 3233     		add	r3, r3, #50
 1088 0302 9AB2     		uxth	r2, r3
 1089 0304 3A4B     		ldr	r3, .L49+64
 1090 0306 1A80     		strh	r2, [r3]
 1091              	.L46:
 221:../Sources/main.c ****     		}
 222:../Sources/main.c ****     		tpmPwmModulo = 10485760U / pwmFreq;
 1092              		.loc 4 222 0
 1093 0308 394B     		ldr	r3, .L49+64
 1094 030a 1B88     		ldrh	r3, [r3]
 1095 030c A022     		mov	r2, #160
 1096 030e 1004     		lsl	r0, r2, #16
 1097 0310 191C     		mov	r1, r3
 1098 0312 FFF7FEFF 		bl	__aeabi_uidiv
 1099 0316 031C     		mov	r3, r0
 1100 0318 9AB2     		uxth	r2, r3
 1101 031a 264B     		ldr	r3, .L49+4
 1102 031c 1A80     		strh	r2, [r3]
 223:../Sources/main.c **** 
 224:../Sources/main.c ****     		TPM_SetModulo(TPM1, tpmPwmModulo); /*Seta o valor de mdulo - fim de contagem (borda)*/
 1103              		.loc 4 224 0
 1104 031e 254B     		ldr	r3, .L49+4
 1105 0320 1B88     		ldrh	r3, [r3]
 1106 0322 234A     		ldr	r2, .L49
 1107 0324 101C     		mov	r0, r2
 1108 0326 191C     		mov	r1, r3
 1109 0328 FFF7FEFF 		bl	TPM_SetModulo
 225:../Sources/main.c ****         	EmbUtil_ItoA(pwmFreq, lcdString, 10);
 1110              		.loc 4 225 0
 1111 032c 304B     		ldr	r3, .L49+64
 1112 032e 1B88     		ldrh	r3, [r3]
 1113 0330 1A1C     		mov	r2, r3
 1114 0332 3B1D     		add	r3, r7, #4
 1115 0334 101C     		mov	r0, r2
 1116 0336 191C     		mov	r1, r3
 1117 0338 0A22     		mov	r2, #10
 1118 033a FFF7FEFF 		bl	EmbUtil_ItoA
 226:../Sources/main.c ****         	LCD_SetCursor(lcd0, sizeof("PWM Freq.:"), 1);
 1119              		.loc 4 226 0
 1120 033e 234B     		ldr	r3, .L49+28
 1121 0340 1B68     		ldr	r3, [r3]
 1122 0342 181C     		mov	r0, r3
 1123 0344 0B21     		mov	r1, #11
 1124 0346 0122     		mov	r2, #1
 1125 0348 FFF7FEFF 		bl	LCD_SetCursor
 227:../Sources/main.c ****         	LCD_WriteString(lcd0, "              ");
 1126              		.loc 4 227 0
 1127 034c 1F4B     		ldr	r3, .L49+28
 1128 034e 1A68     		ldr	r2, [r3]
 1129 0350 204B     		ldr	r3, .L49+36
 1130 0352 101C     		mov	r0, r2
 1131 0354 191C     		mov	r1, r3
 1132 0356 FFF7FEFF 		bl	LCD_WriteString
 228:../Sources/main.c ****         	LCD_SetCursor(lcd0, sizeof("PWM Freq.:"), 1);
 1133              		.loc 4 228 0
 1134 035a 1C4B     		ldr	r3, .L49+28
 1135 035c 1B68     		ldr	r3, [r3]
 1136 035e 181C     		mov	r0, r3
 1137 0360 0B21     		mov	r1, #11
 1138 0362 0122     		mov	r2, #1
 1139 0364 FFF7FEFF 		bl	LCD_SetCursor
 229:../Sources/main.c ****         	LCD_WriteString(lcd0, lcdString);
 1140              		.loc 4 229 0
 1141 0368 184B     		ldr	r3, .L49+28
 1142 036a 1A68     		ldr	r2, [r3]
 1143 036c 3B1D     		add	r3, r7, #4
 1144 036e 101C     		mov	r0, r2
 1145 0370 191C     		mov	r1, r3
 1146 0372 FFF7FEFF 		bl	LCD_WriteString
 1147              	.L44:
 230:../Sources/main.c ****     	}
 231:../Sources/main.c **** 
 232:../Sources/main.c ****     	Delay_Waitms(100);
 1148              		.loc 4 232 0
 1149 0376 6420     		mov	r0, #100
 1150 0378 FFF7FEFF 		bl	Delay_Waitms
 233:../Sources/main.c ****     	NVIC_DisableIRQ( PORTA_IRQn );
 1151              		.loc 4 233 0
 1152 037c 1E20     		mov	r0, #30
 1153 037e FFF7FEFF 		bl	NVIC_DisableIRQ
 234:../Sources/main.c ****     	if(portaISRFlag) /* Verifica se ISR j estava habilitada e ja foi chamada*/
 1154              		.loc 4 234 0
 1155 0382 1C4B     		ldr	r3, .L49+68
 1156 0384 1B78     		ldrb	r3, [r3]
 1157 0386 DBB2     		uxtb	r3, r3
 1158 0388 002B     		cmp	r3, #0
 1159 038a 0CD0     		beq	.L47
 235:../Sources/main.c ****         {
 236:../Sources/main.c ****     		portaISRFlag = 0;
 1160              		.loc 4 236 0
 1161 038c 194B     		ldr	r3, .L49+68
 1162 038e 0022     		mov	r2, #0
 1163 0390 1A70     		strb	r2, [r3]
 237:../Sources/main.c ****     		keyFlagTmp =  dutyKeyFlag;
 1164              		.loc 4 237 0
 1165 0392 3B1C     		mov	r3, r7
 1166 0394 0F33     		add	r3, r3, #15
 1167 0396 134A     		ldr	r2, .L49+52
 1168 0398 1278     		ldrb	r2, [r2]
 1169 039a 1A70     		strb	r2, [r3]
 238:../Sources/main.c ****     		freqKeyFlagTmp =  freqKeyFlag;
 1170              		.loc 4 238 0
 1171 039c 3B1C     		mov	r3, r7
 1172 039e 0E33     		add	r3, r3, #14
 1173 03a0 124A     		ldr	r2, .L49+60
 1174 03a2 1278     		ldrb	r2, [r2]
 1175 03a4 1A70     		strb	r2, [r3]
 1176              	.L47:
 239:../Sources/main.c ****         }
 240:../Sources/main.c **** 
 241:../Sources/main.c **** 		NVIC_EnableIRQ( PORTA_IRQn );
 1177              		.loc 4 241 0
 1178 03a6 1E20     		mov	r0, #30
 1179 03a8 FFF7FEFF 		bl	NVIC_EnableIRQ
 242:../Sources/main.c **** 
 243:../Sources/main.c ****     }
 1180              		.loc 4 243 0
 1181 03ac 48E7     		b	.L48
 1182              	.L50:
 1183 03ae C046     		.align	2
 1184              	.L49:
 1185 03b0 00900340 		.word	1073975296
 1186 03b4 00000000 		.word	tpmPwmModulo
 1187 03b8 00900440 		.word	1074040832
 1188 03bc 00A00440 		.word	1074044928
 1189 03c0 00F00F40 		.word	1074786304
 1190 03c4 40F00F40 		.word	1074786368
 1191 03c8 00000000 		.word	lcd0Config
 1192 03cc 00000000 		.word	lcd0
 1193 03d0 68000000 		.word	.LC30
 1194 03d4 74000000 		.word	.LC32
 1195 03d8 84000000 		.word	.LC34
 1196 03dc 88000000 		.word	.LC36
 1197 03e0 94000000 		.word	.LC38
 1198 03e4 00000000 		.word	dutyKeyFlag
 1199 03e8 00000000 		.word	pwmDuty
 1200 03ec 00000000 		.word	freqKeyFlag
 1201 03f0 00000000 		.word	pwmFreq
 1202 03f4 00000000 		.word	portaISRFlag
 1203              		.cfi_endproc
 1204              	.LFE77:
 1206              		.section	.rodata.__func__.5655,"a",%progbits
 1207              		.align	2
 1210              	__func__.5655:
 1211 0000 504F5254 		.ascii	"PORT_Init\000"
 1211      5F496E69 
 1211      7400
 1212 000a 0000     		.section	.rodata.__func__.5660,"a",%progbits
 1213              		.align	2
 1216              	__func__.5660:
 1217 0000 504F5254 		.ascii	"PORT_PullEnable\000"
 1217      5F50756C 
 1217      6C456E61 
 1217      626C6500 
 1218              		.section	.rodata.__func__.5671,"a",%progbits
 1219              		.align	2
 1222              	__func__.5671:
 1223 0000 504F5254 		.ascii	"PORT_SetMux\000"
 1223      5F536574 
 1223      4D757800 
 1224              		.section	.rodata.__func__.5802,"a",%progbits
 1225              		.align	2
 1228              	__func__.5802:
 1229 0000 54504D5F 		.ascii	"TPM_InitCounter\000"
 1229      496E6974 
 1229      436F756E 
 1229      74657200 
 1230              		.section	.rodata.__func__.5813,"a",%progbits
 1231              		.align	2
 1234              	__func__.5813:
 1235 0000 54504D5F 		.ascii	"TPM_SetChMatch\000"
 1235      53657443 
 1235      684D6174 
 1235      636800
 1236 000f 00       		.section	.rodata.__func__.5827,"a",%progbits
 1237              		.align	2
 1240              	__func__.5827:
 1241 0000 54504D5F 		.ascii	"TPM_SetModulo\000"
 1241      5365744D 
 1241      6F64756C 
 1241      6F00
 1242 000e 0000     		.text
 1243              	.Letext0:
 1244              		.file 5 "c:\\freescale\\kds_v3\\toolchain\\arm-none-eabi\\include\\machine\\_default_types.h"
 1245              		.file 6 "c:\\freescale\\kds_v3\\toolchain\\arm-none-eabi\\include\\stdint.h"
 1246              		.file 7 "../Includes/MKL05Z4.h"
 1247              		.file 8 "../Sources/mcu_general_config.h"
 1248              		.file 9 "../Sources/generic_drivers/lcd/lcd.h"
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
C:\Users\mathe\AppData\Local\Temp\cc5GY4jk.s:18     .text.NVIC_EnableIRQ:00000000 $t
C:\Users\mathe\AppData\Local\Temp\cc5GY4jk.s:22     .text.NVIC_EnableIRQ:00000000 NVIC_EnableIRQ
C:\Users\mathe\AppData\Local\Temp\cc5GY4jk.s:58     .text.NVIC_EnableIRQ:00000028 $d
C:\Users\mathe\AppData\Local\Temp\cc5GY4jk.s:63     .text.NVIC_DisableIRQ:00000000 $t
C:\Users\mathe\AppData\Local\Temp\cc5GY4jk.s:67     .text.NVIC_DisableIRQ:00000000 NVIC_DisableIRQ
C:\Users\mathe\AppData\Local\Temp\cc5GY4jk.s:101    .text.NVIC_DisableIRQ:00000028 $d
C:\Users\mathe\AppData\Local\Temp\cc5GY4jk.s:106    .rodata:00000000 $d
C:\Users\mathe\AppData\Local\Temp\cc5GY4jk.s:113    .text.PORT_Init:00000000 $t
C:\Users\mathe\AppData\Local\Temp\cc5GY4jk.s:117    .text.PORT_Init:00000000 PORT_Init
C:\Users\mathe\AppData\Local\Temp\cc5GY4jk.s:199    .text.PORT_Init:00000074 $d
C:\Users\mathe\AppData\Local\Temp\cc5GY4jk.s:1210   .rodata.__func__.5655:00000000 __func__.5655
C:\Users\mathe\AppData\Local\Temp\cc5GY4jk.s:215    .text.PORT_PullEnable:00000000 $t
C:\Users\mathe\AppData\Local\Temp\cc5GY4jk.s:219    .text.PORT_PullEnable:00000000 PORT_PullEnable
C:\Users\mathe\AppData\Local\Temp\cc5GY4jk.s:281    .text.PORT_PullEnable:00000058 $d
C:\Users\mathe\AppData\Local\Temp\cc5GY4jk.s:1216   .rodata.__func__.5660:00000000 __func__.5660
C:\Users\mathe\AppData\Local\Temp\cc5GY4jk.s:289    .text.PORT_SetMux:00000000 $t
C:\Users\mathe\AppData\Local\Temp\cc5GY4jk.s:293    .text.PORT_SetMux:00000000 PORT_SetMux
C:\Users\mathe\AppData\Local\Temp\cc5GY4jk.s:374    .text.PORT_SetMux:0000007c $d
C:\Users\mathe\AppData\Local\Temp\cc5GY4jk.s:1222   .rodata.__func__.5671:00000000 __func__.5671
C:\Users\mathe\AppData\Local\Temp\cc5GY4jk.s:387    .text.TPM_InitCounter:00000000 $t
C:\Users\mathe\AppData\Local\Temp\cc5GY4jk.s:391    .text.TPM_InitCounter:00000000 TPM_InitCounter
C:\Users\mathe\AppData\Local\Temp\cc5GY4jk.s:432    .text.TPM_InitCounter:00000030 $d
C:\Users\mathe\AppData\Local\Temp\cc5GY4jk.s:1228   .rodata.__func__.5802:00000000 __func__.5802
C:\Users\mathe\AppData\Local\Temp\cc5GY4jk.s:439    .text.TPM_SetChMatch:00000000 $t
C:\Users\mathe\AppData\Local\Temp\cc5GY4jk.s:443    .text.TPM_SetChMatch:00000000 TPM_SetChMatch
C:\Users\mathe\AppData\Local\Temp\cc5GY4jk.s:490    .text.TPM_SetChMatch:0000003c $d
C:\Users\mathe\AppData\Local\Temp\cc5GY4jk.s:1234   .rodata.__func__.5813:00000000 __func__.5813
C:\Users\mathe\AppData\Local\Temp\cc5GY4jk.s:497    .text.TPM_SetModulo:00000000 $t
C:\Users\mathe\AppData\Local\Temp\cc5GY4jk.s:501    .text.TPM_SetModulo:00000000 TPM_SetModulo
C:\Users\mathe\AppData\Local\Temp\cc5GY4jk.s:543    .text.TPM_SetModulo:00000034 $d
C:\Users\mathe\AppData\Local\Temp\cc5GY4jk.s:1240   .rodata.__func__.5827:00000000 __func__.5827
                            *COM*:00000004 lcd0Config
                            *COM*:00000004 lcd0
                            *COM*:00000001 pwmDuty
C:\Users\mathe\AppData\Local\Temp\cc5GY4jk.s:557    .data.pwmFreq:00000000 pwmFreq
C:\Users\mathe\AppData\Local\Temp\cc5GY4jk.s:554    .data.pwmFreq:00000000 $d
C:\Users\mathe\AppData\Local\Temp\cc5GY4jk.s:564    .data.tpmPwmModulo:00000000 tpmPwmModulo
C:\Users\mathe\AppData\Local\Temp\cc5GY4jk.s:561    .data.tpmPwmModulo:00000000 $d
                            *COM*:00000001 dutyKeyFlag
                            *COM*:00000001 freqKeyFlag
                            *COM*:00000001 portaISRFlag
C:\Users\mathe\AppData\Local\Temp\cc5GY4jk.s:570    .text.PORTA_IRQHandler:00000000 $t
C:\Users\mathe\AppData\Local\Temp\cc5GY4jk.s:575    .text.PORTA_IRQHandler:00000000 PORTA_IRQHandler
C:\Users\mathe\AppData\Local\Temp\cc5GY4jk.s:634    .text.PORTA_IRQHandler:00000048 $d
C:\Users\mathe\AppData\Local\Temp\cc5GY4jk.s:660    .text.main:00000000 $t
C:\Users\mathe\AppData\Local\Temp\cc5GY4jk.s:665    .text.main:00000000 main
C:\Users\mathe\AppData\Local\Temp\cc5GY4jk.s:1185   .text.main:000003b0 $d
C:\Users\mathe\AppData\Local\Temp\cc5GY4jk.s:1207   .rodata.__func__.5655:00000000 $d
C:\Users\mathe\AppData\Local\Temp\cc5GY4jk.s:1213   .rodata.__func__.5660:00000000 $d
C:\Users\mathe\AppData\Local\Temp\cc5GY4jk.s:1219   .rodata.__func__.5671:00000000 $d
C:\Users\mathe\AppData\Local\Temp\cc5GY4jk.s:1225   .rodata.__func__.5802:00000000 $d
C:\Users\mathe\AppData\Local\Temp\cc5GY4jk.s:1231   .rodata.__func__.5813:00000000 $d
C:\Users\mathe\AppData\Local\Temp\cc5GY4jk.s:1237   .rodata.__func__.5827:00000000 $d
                     .debug_frame:00000010 $d
                           .group:00000000 wm4.0.e19fef13b9966be9a9a0df56dde4c190
                           .group:00000000 wm4.features.h.22.6a4ca7cd053637cc1d0db6c16f39b2d7
                           .group:00000000 wm4._default_types.h.15.8b2cb27e528498f8ff711db085d6e489
                           .group:00000000 wm4.stdint.h.20.796e373797e732130a803d4c0338fa1b
                           .group:00000000 wm4.MKL05Z4.h.103.c5a242a6313ded8e4c7cb62acb8df21b
                           .group:00000000 wm4.core_cm0plus.h.43.8d0a7c3b62d57d3de08e0cf260e796f5
                           .group:00000000 wm4.core_cmInstr.h.39.440aa208ad4c1679c5765c09acc09994
                           .group:00000000 wm4.core_cm0plus.h.160.b16144213bf005ce96482cc39658f3eb
                           .group:00000000 wm4.system_MKL05Z4.h.101.1304ea5d52ecf5deae71ccb0772f8612
                           .group:00000000 wm4.MKL05Z4.h.274.69d105c645fb54a4873c1961c705a2ed
                           .group:00000000 wm4.mcu_general_config.h.49.464b67ff30c511db75624d944293d898
                           .group:00000000 wm4.lcd.h.59.7bba9926f48e0bbbc91322b4531ef773
                           .group:00000000 wm4.delay.h.39.43a7ebb51f451ed360034624059d6293
                           .group:00000000 wm4.stddef.h.39.daafd3d79fe2f3a84d2d73d7d4e706f8
                           .group:00000000 wm4.stdbool.h.29.1c9ee6859ce8145f7838a4f2549ccec2
                           .group:00000000 wm4.newlib.h.8.fec018e441fee7bfa1923812ad010f97
                           .group:00000000 wm4.config.h.212.4163ef2871a828c674038d036b081cfd
                           .group:00000000 wm4._ansi.h.23.2147fde150631f5584b9dc29b914d1b8
                           .group:00000000 wm4.stdlib.h.13.4ed386f5c1a80d71e72172885d946ef2
                           .group:00000000 wm4.stddef.h.158.a7efb00f6cbc6f43213b50e183c9830c
                           .group:00000000 wm4.lock.h.2.9bc98482741e5e2a9450b12934a684ea
                           .group:00000000 wm4._types.h.54.d3d34a3b7f3cc230cd159baf022b4b08
                           .group:00000000 wm4.stddef.h.158.61317cdbfb4026324507d123a50b0fd6
                           .group:00000000 wm4.reent.h.17.8bd9e4098e0428508c282cad794fae43
                           .group:00000000 wm4.stdlib.h.53.a73f7e963d962393b7f9086194931e4a
                           .group:00000000 wm4.cdefs.h.56.a2d04de9d47039852021e66fca39bb58
                           .group:00000000 wm4.string.h.15.dab3980bf35408a4c507182805e2de3a
                           .group:00000000 wm4.math.h.35.543015094efee9028e0e4b7949018580
                           .group:00000000 wm4.emb_util.h.51.8ea7742b72b4040e74b9712312555cf1
                           .group:00000000 wm4.assert.h.11.7fe9eb241be6b0fee772a1e693b81ae3

UNDEFINED SYMBOLS
__assert_func
__aeabi_idiv
__aeabi_uidiv
TPM_SetCounterClkSrc
TPM_Init
GPIO_InitOutputPin
GPIO_InitInputPin
PORT_IRQEnable
TPM_InitChannel
Delay_Init
LCD_CreateConfig
LCD_Init
Delay_Waitms
LCD_Clear
LCD_SetCursor
LCD_WriteString
EmbUtil_ItoA
